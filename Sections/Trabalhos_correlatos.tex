\label{chapter:correlatos}
O capítulo a seguir apresenta o método de pesquisa utilizado para o levantamento bibliográfico, os resultados e os artigos e suas contribuições para o desenvolvimento do projeto descrito no método proposto.

%==========================================================
% REVISÃO SISTEMÁTICA
%==========================================================
\section{Revisão sistemática}
\par
A revisão sistemática consiste em um método de identificação, análise e interpretação de pesquisas relevantes em determinada área ou questão de pesquisa\cite{kitchenham2004procedures}. A aplicação da revisão sistemática requer que seja seguido um conjunto bem definido e sequencial de passos e, por conta disso, é necessário um esforço considerável, se comparado a uma revisão informal a literatura\cite{MafraTravassos}.

\par
Vale ser observado que o objetivo do trabalho é realizar um estudo exploratório de caracterização de área, podendo assim dizer que esta revisão sistemática se caracteriza como uma quasi-sistemática\cite{travassos2008environment}. Baseado nisso, as seguintes questões foram formuladas:
\begin{itemize}
\item \textbf{Q1:} Quais são os métodos para verificação de circuitos lógicos descritos na linguagem de programação VHDL?
	\begin{itemize}
	\item \textbf{Q1.1:} Foi desenvolvido e está disponível alguma ferramenta para aplicação do método?
	\item \textbf{Q1.2:} Qual a técnica de exploração de estados para circuitos lógicos?
	\item \textbf{Q1.3:} O método proposto é baseado em técnicas de verificação de software?
	\item \textbf{Q1.4:} Como o método proposto valida pré e pós condições no programa?
	\item \textbf{Q1.3:} Foi utilizado algum \textit{benchmark} de programas em VHDL para experimentação e o mesmo encontra-se disponível?
	\item \textbf{Q1.4:} Quais as perspectivas futuras para melhorar a aplicação do método proposto?
	\end{itemize}
\end{itemize}

\par
A biblioteca digital utilizada para pesquisa foi a Scopus, acessível em http://www.scopus.com, que possui uma base de dados com mais de 22.800 títulos, abrangendo as áreas de tecnologia, medicina, ciências sociais, bem como, atualizações diárias em seus arquivos.

\par
Devido ao tempo necessário para realização completa de todas as etapas, apenas o primeiro filtro da revisão sistemática foi realizado. Em contrapartida, cinco artigos foram selecionados e servirão como ferramentas de estudo para o desenvolvimento deste projeto. Mais informações sobre como foi executada a revisão sistemática se encontra na \autoref{sec:ApendiceA}. Os cinco artigos selecionados serão apresentados nas seções a seguir. Estes trabalhos são relevantes para o desenvolvimento do método proposto. 

%===============================
%V2C - A verilog to C translator
%===============================
\section{V2c-A verilog to C translator}

O artigo de \citeonline{mukherjee2016v2c} apresenta uma ferramenta implementada em C++ chamada \texttt{v2c}, utilizada na transformação de código da linguagem de descrição Verilog para a linguagem de programação C. A ferramenta é executada a nível de palavra, visto que, esta abordagem garante uma aumento na escalabilidade, mas também proporcionando que técnicas, como a interpolação\cite{beyer2011cpachecker}, possam ser utilizadas para verificação, algo inviável, caso a tradução fosse executada a nível de bit. O sistema recebe como entrada um código em Verilog, onde são aplicadas regras semânticas e mapeados os bit de operação, é gerado um código em linguagem C a nível de palavra chamado software \textit{netlist}.

\par
A contribuição do trabalho de \citeonline{mukherjee2016v2c} consiste na utilização de transformações de código como base principal e, partindo deste pressuposto, torna-se vantajoso devido a utilização de outras ferramentas que não apresente suporte a certas linguagens. Tais como a ferramenta ESBMC, utilizada neste trabalho, que não apresenta suporte a VHDL, porém apresenta suporte as linguagens C/C++, em outras palavras, a principal contribuição de tal artigo foi a utilização de traduções de códigos e utilização deste conceito como ponto de partida para a análise de circuitos desenvolvidos no método.

% ====================================================
%Unbounded safety verification for hardware using software analyzers
% ====================================================
\section{Unbounded safety verification for hardware using software analyzers}
No artigo de \citeonline{mukherjee2016unbounded} foi apresentado uma metodologia que aborda a utilização de técnicas e analisadores de software, com o objetivo de abordar a análise de circuitos e, com isso, traçar um paralelo entre as abordagens. Para testes, foram utilizadas três metodologias de análise usando interpolação:\cite{beyer2011cpachecker} interpolação abstrata\cite{blanchet2003static}, \textit{k-induction}\cite{donaldson2011software} e tecnologias híbridas. 

\par
Como resultado dos testes, foram observadas as principais causas de erros, como por exemplo, bits não precisos e, no caso das operações a \textit{bit-level}, ocorria a perda de informações.Também foi observado que apesar de não serem otimizados para análises de hardware, alguns analisadores de software podem, dependendo da técnica utilizada no analisador, serem utilizados para análise de hardware\cite{mukherjee2016unbounded}.

\par
O fato de analisadores de software possuírem a capacidade de utilizar hardware, deve-se ao uso de técnicas de análise a nível de bit. Contudo, estas análises são menos precisas e menos testadas em software, além de usarem abstrações numéricas, o que gera perda de informações e, por isso, a grande quantidade de resultados errados gerados~\cite{mukherjee2016unbounded}.

\par
A utilização de técnicas de análise de software para o desenvolvimento de análise de \textit{hardware} é o foco a ser abordado neste trabalho de maneira prática, utilizando os princípios analisados por \cite{mukherjee2016unbounded}. Neste contexto, utilizando um \textit{Bounded model checking}, como o ESBMC, é possível utilizar técnicas como \textit{k-induction} para a análise conforme apresentado no artigo.

% ====================================================
%Formal verification of timed VHDL programs
% ====================================================
\section{Formal verification of timed VHDL programs}
No trabalho apresentado por \citeonline{bara2010formal} é proposta uma abordagem para a análise de tempo, relacionada a cada porta lógica dentro de um dado circuito analisado. A abordagem apresenta a tradução de um circuito lógico codificado em VHDL, para um formalismo baseado em autômato de tempo\cite{alur1994theory}. Tal formalismo é representado por um autômato de estados finitos, com relógios simbólicos que evoluem em taxa uniforme. A tradução é executada de modo automático, baseada na emulação da propagação de cada transação ao longo de cada sinal, ou seja, são autômatos programados e cronometrados do circuito. Após a tradução para autômato, a análise é feita pela ferramenta UPPAAL\cite{larsen1997uppaal} que é um \textit{model checking} de verificação de propriedades de tempo. Seguindo esta metodologia, a análise pode ser extraída de modo independente de cada bloco, desta forma, a análise é feita de modo mais preciso, podendo ser analisados inúmeros fatores, tais como limites de intervalo e sinal de correlação.

\par
O artigo de \citeonline{bara2010formal} apresenta uma abordagem interessante que pode ser adicionado ao método, pois além da utilização da linguagem VHDL, também apresenta um novo modelo de análise, baseado na utilização de autômato de tempo para verificação de circuitos e, desta forma, identificar a estabilidade dos sinais de entrada e saída baseados nos \textit{delays} das portas do circuito.

% ====================================================
%On the use of assertions for embedded-software dynamic verification
% ====================================================
\section{On the use of assertions for embedded-software dynamic verification}
Em \citeonline{di2012use} é apresentado uma metodologia para a integração dinâmica de \textit{Assertion-Based Verification} para várias fases da análise da verificação de fluxo em sistemas embarcados, por exemplo, emulação, diagnósticos e \textit{Debug}, mas também um ferramenta chamada \textit{RadCheck}. O método de aplicação, chamado \textit{V-model} é dividido em fases de verificação em paralelo com as fases de \textit{design} do circuito. Com base no \textit{V-model}, o método é aplicado, iniciando com o nível de sistema e as especificação do sistema, neste caso especificado usando PSL. Neste nível é especificado todas as funcionalidades gerais da aplicação. No nível de integração visa investigar problemas de interação que possam ocorrer, definindo propriedades que cobrem incrementalmente as unidades estruturais interativas de aplicação. No nível de unidade descrevem comportamentos internos e são definidas através de parâmetros de entrada/saída das unidades e estruturas de dados internas.

\par
A contribuição deste projeto está relacionado a utilização de assertivas no contexto da verificação de software. As assertivas são o principal meio de análise proposto neste projeto, visto que estas mesma assertivas serão analisadas pelo ESBMC. Aliado a isso em \citeonline{di2012use} é apresentado modelos de utilização de assertivas no processo de verificação de hardware, e tais assertivas foram adaptadas para um modelo proposto neste trabalho.

% ====================================================
%Incorporating efficient assertion checkers into hardware emulation
% ====================================================
\section{Incorporating efficient assertion checkers into hardware emulation}
\par
No trabalho de \citeonline{boule2005incorporating} é apresentado uma ferramenta de geração de assertivas no contexto da emulação de circuitos, de modo que estas assertivas descrita em PSL possam transformadas para o modelo de linguagem de descrição de hardware. As instruções são transformadas percorrendo a \textit{parse tree} na qual estão armazenadas. Cada sub-expressão é conectada recursivamente pelo uso de pré-condição e resultado, desta forma se determinado nó na \textit{parse tree} aceita um sinal de pré-condição de seu pai, se transforma recursivamente no circuito adequado e, em seguida, retorna o sinal de resultado para o pai.

\par
O trabalho de \citeonline{boule2005incorporating} consolida e apresenta aspectos importantes, tais como a utilização de uma ferramenta para geração de assertivas, o que torna-se no contexto deste projeto, extremamente importante, visto que o modelo adotado atualmente consiste tanto na geração automática das assertivas, bem como a inserção manual por parte do usuário.

%==================
%Tabela comparativa
%==================
\section{Tabela comparativa}
\par
A tabela apresenta os os artigos resultantes da revisão sistemática em comparação ao trabalho apresentado. Desta forma é possivel apresentar a contibuição de cada um no desenvolvimento do método proposto. Na prieira coluna é apresentado os artigos para analise, na segunda, terceira e quarta coluna apresenta as tecnicas utilizadas no trabalho, bem como se os artigos utilizaram ou não desta técnica.

\par
Por meio da \autoref{tab:apresentacao_artigo} é possível demonstrar que nem todos os elementos apresentados foram utilizados por todos os artigos, contudo, atráves de análise experimental foi possível comprovar que este elementos podem relacionar-se entre si. Desta forma também comprova a contribuição dos mesmo para o desenvolvimento do método.

\par
Com relação ao artigo \textbf{Formal verification of timed VHDL programs} o mesmo apresenta outra abordagem de análise para a ferramenta proposta, porém, ainda não foi adicionada. A utilização de automatos de tempo permite a utilização de outras ferramentas que propicie novas abrodagens de análise. 

\begin{table}[H]
\centering
  \caption{Tabela de apresentação}
  \label{tab:apresentacao_artigo}
\begin{tabular}{|p{6,5cm}|p{3cm}|p{2,5cm}|p{2cm}|}
\hline
%\rowcolor[HTML]{9B9B9B} 
\textbf{Artigos} & \textbf{Transformação de código} & \textbf{Utilização de assertivas} & \textbf{Analise de código} \\ \hline
\textbf{V2c - A verilog to C translator} & Sim & Não & Não \\ \hline
\textbf{Unbounded safety verification for hardware using software analyzers} & Não & Não & Sim \\ \hline
\textbf{Formal verification of timed VHDL programs} & Não & Não & Não \\ \hline
\textbf{On the use of assertions for embedded software dynamic verification} & Não & Sim & Sim \\ \hline
\textbf{Incorporating efficient assertion checkers into hardware emulation} & Não & Sim & Sim \\ \hline
%\rowcolor[HTML]{C0C0C0} 
\textbf{Ferramenta apresentada} & Sim & Sim & Sim \\ \hline
\end{tabular}
\legend{Fonte: Própria}
\end{table}

%========================
%===Resumo do capitulo===
%========================
\section{Resumo do capitulo}
\par
Neste capítulo foi apresentado de maneira resumida o método de levantamento bibliográfico utilizado, revisão sistemática, e algumas das etapas realizadas. Também foi apresentado 5 artigos que foram extraídos do resultado da revisão sistemática e a contribuição de cada artigo no desenvolvimento do método. Ao final foi apresentado uma tabela comparativas entre os artigos, explicitando a contribuição de cada artigo de modo mais visual.