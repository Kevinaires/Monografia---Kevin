<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'><style type="text/css"> body, table { font-size: 14px } /* Table Style - This is what you want ------------------------------------------------------------------ */ table a:link, table a:visited { 	color: #2D4FD6; 	text-decoration:none; } table a:active, table a:hover { 	color: #bd5a35; 	text-decoration:underline; }  /* para descatar os candidatos similares*/  table tr.sim_1, table tr.sim_1 a { color: #C74444; }    table { 	font-family:Arial, Helvetica, sans-serif; 	color:#333; 	/* font-size:12px; 	text-shadow: 1px 1px 0px #fff;  */ 	background:#eaebec; 	border:#ccc 1px solid;     /* 	-moz-border-radius:3px; 	-webkit-border-radius:3px; 	border-radius:3px;  	-moz-box-shadow: 0 1px 2px #d1d1d1; 	-webkit-box-shadow: 0 1px 2px #d1d1d1; 	box-shadow: 0 1px 2px #d1d1d1;         */     width: 100%; } table th { 	padding:5px 5px 5px 5px; 	border-top:1px solid #fafafa; 	border-bottom:1px solid #e0e0e0;  	background: #ededed; 	background: -webkit-gradient(linear, left top, left bottom, from(#ededed), to(#ebebeb)); 	background: -moz-linear-gradient(top,  #ededed,  #ebebeb); } table th:first-child{ 	text-align: left; 	padding-left:20px; } table tr:first-child th:first-child{ 	-moz-border-radius-topleft:3px; 	-webkit-border-top-left-radius:3px; 	border-top-left-radius:3px; } table tr:first-child th:last-child{ 	-moz-border-radius-topright:3px; 	-webkit-border-top-right-radius:3px; 	border-top-right-radius:3px; } table tr{ 	text-align: center; 	padding-left:20px; } table tr td:first-child{ 	text-align: left; 	padding-left:20px; 	border-left: 0; } table tr td { 	padding:5px 5px 5px 5px; 	/* border-top: 1px solid #ffffff; 	border-bottom:1px solid #e0e0e0; 	border-left: 1px solid #e0e0e0;     */  	background: #fafafa; 	background: -webkit-gradient(linear, left top, left bottom, from(#fbfbfb), to(#fafafa)); 	background: -moz-linear-gradient(top,  #fbfbfb,  #fafafa); } table tr.even td{ 	background: #f6f6f6; 	background: -webkit-gradient(linear, left top, left bottom, from(#f5f5f5), to(#f3f3f3)); 	background: -moz-linear-gradient(top,  #f8f8f8,  #f6f6f6); } table tr:last-child td{  border-bottom:0; } table tr:last-child td:first-child{ 	-moz-border-radius-bottomleft:3px; 	-webkit-border-bottom-left-radius:3px; 	border-bottom-left-radius:3px; } table tr:last-child td:last-child{ 	-moz-border-radius-bottomright:3px; 	-webkit-border-bottom-right-radius:3px; 	border-bottom-right-radius:3px; } table tr:hover td{ 	background: #f2f2f2; 	background: -webkit-gradient(linear, left top, left bottom, from(#E4EDFF), to(#E4EDFF)); 	background: -moz-linear-gradient(top,  #f2f2f2,  #f0f0f0); }  .common_chunk{color:#f00;text-decoration: none;}.divisor-texto{display: none;} #cand_listAll{display: block;} span.f1 {   color:#ff0000; } </style><script>function toggle( idCandidate ){ 	var candidateToShow = 'cand_'+idCandidate;	var divs = document.getElementsByClassName('divisor');	for (i = 0; i < divs.length; i++)	{		divs[i].style.display = 'none';	}	if( candidateToShow && document.getElementById(candidateToShow) ){		document.getElementById(candidateToShow).style.display = 'block';			}		if( $('.select-cand') ){	  $('.select-cand').removeClass('active');	}	if( $('#li-cand-'+idCandidate) ){	  $('#li-cand-'+idCandidate).addClass('active');	}		return false;	}</script><script>window.onload = function() {toggle("listAll");};</script>

<div id'divisor-list' class='col-xs-6 col-sm-6 col-md-4 col-lg-3'>
<ul class='nav nav-pills nav-stacked'>
<li role='presentation' id='li-cand-listAll' class='select-cand'><a href='#' onclick='return toggle("listAll");'>Candidates </a></li>
<li role='presentation' id='li-cand-_file7' class='select-cand'><a href='#' onclick='return toggle("_file7");'>arxiv.org/pdf/1504.0... [0.94%]</a></li>
<li role='presentation' id='li-cand-_file9' class='select-cand'><a href='#' onclick='return toggle("_file9");'>www2.pcs.usp.br/~lab... [0.8%]</a></li>
<li role='presentation' id='li-cand-_file1' class='select-cand'><a href='#' onclick='return toggle("_file1");'>pt.wikipedia.org/wik... [0.51%]</a></li>
<li role='presentation' id='li-cand-_file3' class='select-cand'><a href='#' onclick='return toggle("_file3");'>ufrr.br/pic/index.ph... [0.27%]</a></li>
<li role='presentation' id='li-cand-_file2' class='select-cand'><a href='#' onclick='return toggle("_file2");'>docplayer.com.br/778... [0.25%]</a></li>
<li role='presentation' id='li-cand-_file5' class='select-cand'><a href='#' onclick='return toggle("_file5");'>ufrr.br/pic/index.ph... [0.21%]</a></li>
<li role='presentation' id='li-cand-_file4' class='select-cand'><a href='#' onclick='return toggle("_file4");'>decom.ufop.br/imobil... [0.21%]</a></li>
<li role='presentation' id='li-cand-_file6' class='select-cand'><a href='#' onclick='return toggle("_file6");'>passeidireto.com/arq... [0.11%]</a></li>
<li role='presentation' id='li-cand-_file10' class='select-cand'><a href='#' onclick='return toggle("_file10");'>books.google.com.br/ [0%]</a></li>
<li role='presentation' id='li-cand-_file8' class='select-cand'><a href='#' onclick='return toggle("_file8");'>books.google.com/ [0%]</a></li>
</ul>
</div>

<div id='content-candidates' class='col-xs-6 col-sm-6 col-md-8 col-lg-9' >
<div class='divisor divisor-texto' id="cand_listAll"><span><hr class='text-separator'><br>Input file: <a target='_blank' href='#'>main.pdf</a> (12773 chunks)</span><table cellspacing='0' id='table-indice-report'><thead><tr class='table-ui-widget-header'><th>File found</th><th width='10%'></th><th width='10%'>Chunks total</th><th width='10%'>Chunks in common</th><th width='10%'>Similarity (%)</th><th width='13%'></th></tr></thead><tbody><tr class=' even'>
<td><a href='https://arxiv.org/pdf/1504.01027' title='https://arxiv.org/pdf/1504.01027' target='_blank'>arxiv.org/pdf/1504.0...</a></td>
<td><a href='#' onclick='return toggle("_file7");'>Visualize</a></td>
<td>22619</td>
<td>332</td>
<td>0.94</td>
<td></td>
</tr><tr class=''>
<td><a href='http://www2.pcs.usp.br/~labdig/material/intro-hdl.pdf' title='http://www2.pcs.usp.br/~labdig/material/intro-hdl.pdf' target='_blank'>www2.pcs.usp.br/~lab...</a></td>
<td><a href='#' onclick='return toggle("_file9");'>Visualize</a></td>
<td>3756</td>
<td>132</td>
<td>0.8</td>
<td></td>
</tr><tr class=' even'>
<td><a href='https://pt.wikipedia.org/wiki/Linguagem_de_descrição_de_hardware' title='https://pt.wikipedia.org/wiki/Linguagem_de_descrição_de_hardware' target='_blank'>pt.wikipedia.org/wik...</a></td>
<td><a href='#' onclick='return toggle("_file1");'>Visualize</a></td>
<td>3143</td>
<td>82</td>
<td>0.51</td>
<td></td>
</tr><tr class=''>
<td><a href='http://ufrr.br/pic/index.php/component/phocadownload/category/24-editais-pibic.html?download=471:edital-05-2017-pibic' title='http://ufrr.br/pic/index.php/component/phocadownload/category/24-editais-pibic.html?download=471:edital-05-2017-pibic' target='_blank'>ufrr.br/pic/index.ph...</a></td>
<td><a href='#' onclick='return toggle("_file3");'>Visualize</a></td>
<td>4618</td>
<td>47</td>
<td>0.27</td>
<td></td>
</tr><tr class=' even'>
<td><a href='http://docplayer.com.br/77844321-Coordenacao-do-programa-de-iniciacao-cientifica.html' title='http://docplayer.com.br/77844321-Coordenacao-do-programa-de-iniciacao-cientifica.html' target='_blank'>docplayer.com.br/778...</a></td>
<td><a href='#' onclick='return toggle("_file2");'>Visualize</a></td>
<td>5885</td>
<td>47</td>
<td>0.25</td>
<td></td>
</tr><tr class=''>
<td><a href='https://ufrr.br/pic/index.php/component/phocadownload/category/24-editais-pibic.html?download=508:resultado-preliminar-pibic-2017-2018' title='https://ufrr.br/pic/index.php/component/phocadownload/category/24-editais-pibic.html?download=508:resultado-preliminar-pibic-2017-2018' target='_blank'>ufrr.br/pic/index.ph...</a></td>
<td><a href='#' onclick='return toggle("_file5");'>Visualize</a></td>
<td>2710</td>
<td>33</td>
<td>0.21</td>
<td></td>
</tr><tr class=' even'>
<td><a href='http://www.decom.ufop.br/imobilis/fpga-flexibilidade-no-projeto-de-hardware-parte-3-de-3/' title='http://www.decom.ufop.br/imobilis/fpga-flexibilidade-no-projeto-de-hardware-parte-3-de-3/' target='_blank'>decom.ufop.br/imobil...</a></td>
<td><a href='#' onclick='return toggle("_file4");'>Visualize</a></td>
<td>963</td>
<td>29</td>
<td>0.21</td>
<td></td>
</tr><tr class=''>
<td><a href='https://www.passeidireto.com/arquivo/2297149/modulo-06-linguagens-de-descricaode-hardware-hdl-introducao' title='https://www.passeidireto.com/arquivo/2297149/modulo-06-linguagens-de-descricaode-hardware-hdl-introducao' target='_blank'>passeidireto.com/arq...</a></td>
<td><a href='#' onclick='return toggle("_file6");'>Visualize</a></td>
<td>791</td>
<td>15</td>
<td>0.11</td>
<td></td>
</tr><tr class=' even'>
<td><a href='https://books.google.com.br/' title='https://books.google.com.br/' target='_blank'>books.google.com.br/</a></td>
<td><a href='#' onclick='return toggle("_file10");'>Visualize</a></td>
<td>40</td>
<td>0</td>
<td>0</td>
<td></td>
</tr><tr class=''>
<td><a href='https://books.google.com/' title='https://books.google.com/' target='_blank'>books.google.com/</a></td>
<td><a href='#' onclick='return toggle("_file8");'>Visualize</a></td>
<td>40</td>
<td>0</td>
<td>0</td>
<td></td>
</tr></tbody></table></div>
<!-- DIVISOR_DIV_CANDIDATE -->

<div class='divisor divisor-texto' id="cand__file1"><hr class='text-separator'><br>Input file: <a href='#'>main.pdf</a> (12773 chunks)<br>File found: <a href='https://pt.wikipedia.org/wiki/Linguagem_de_descrição_de_hardware' target='_blank'>https://pt.wikipedia.org/wiki/Linguagem_de_descrição_de_hardware</a> (3143 chunks)<br><br>Chunks in common: 82<br>Similarity: 0.51%<br><br><div class='textInfo'>The following is the content of the document <br>&nbsp;"<b>main.pdf</b>". <br>The terms in red were found in the document <br>&nbsp;"<b>https://pt.wikipedia.org/wiki/Linguagem_de_descrição_de_hardware</b>".<br><hr class='text-separator'></div>  UNIVERSIDADE FEDERAL DE RORAIMA<br>
PRÓ-REITORIA DE ENSINO E EXTENSÃO<br>
DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código<br>
com Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau<br>
de Bacharel em Ciência da Computação.<br>
Orientador: Dr. Herbert Oliveira Rocha<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau de<br>
Bacharel em Ciência da Computação.<br>
Defendido em 06 de março de 2017 e<br>
aprovado pela seguinte banca examinadora:<br>
Prof. Dr. Herbert Oliveira Rocha<br>
Orientador / Curso de Ciência da Computação -<br>
UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Fazer dedicatória<br>
ACKNOWLEDGEMENTS<br>
Fazer agradecimentos!!<br>
Procurar frase massa!!<br>
ABSTRACT<br>
Fazer resumo!!<br>
Palavras-chaves: ??<br>
ABSTRACT<br>
Fazer Abstract!!<br>
Key-words: ??<br>
LISTA DE FIGURAS<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog. . . . . . . . . . . . . . . . 15<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL. . . . . . . . . . . . . . . . . 16<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade. . . . . . . . . . . . . . . 17<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL. . . . . . . . . . . . . . . . 17<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1. . . . . . . . . . 18<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas. . . . . . . . . 18<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas. . . . . . . . . . 19<br>
Figure 8 – Arvore de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
Figure 9 – Rede de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL. . . . . . . . . . . . . . . . . 27<br>
Figure 11 – Trecho de código em VHDL representando porta AND. . . . . . . . . . . . 28<br>
Figure 12 – Trecho de código traduzido para linguagem C. . . . . . . . . . . . . . . . . 29<br>
Figure 13 – Exemplo de bloco basico de código. . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 14 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 15 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 31<br>
Figure 16 – Ciclo da ferramenta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR. . . . . . . 41<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR. . . . . . . . . . . . . . 42<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume(). . . . . . . . . . . 43<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19. . . . . . . . . . . . . . . 44<br>
Figure 22 – Macros das assertivas implementadas em linguagem C . . . . . . . . . . . . 45<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas. . . . . . . 47<br>
Figure 25 – Imagem de claims contendo assertivas. . . . . . . . . . . . . . . . . . . . . 48<br>
Figure 26 – Pseudocódigo da função de análise das claims. . . . . . . . . . . . . . . . . 49<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta. . . . . . . . . . . . . . 49<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C. . . . . . . . . . . . . 50<br>
Figure 23 – Código com assertivas traduzida para linguagem C . . . . . . . . . . . . . . 51<br>
LISTA DE TABELAS<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM . . . . . . . . . . . . . . . 33<br>
SUMÁRIO<br>
1 INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11<br>
1.1 Definição do problema . . . . . . . . . . . . . . . . . . . . . . . . . . . 12<br>
1.2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13<br>
1.3 Organização do trabalho . . . . . . . . . . . . . . . . . . . . . . . . . 14<br>
2 CONCEITOS E DEFINIÇÕES . . . . . . . . . . . . . . . . . . . . . . 15<br>
2.1 Linguagens de descrição de hardware . . . . . . . . . . . . . . . . . 15<br>
2.1.1 VHSIC <span class='f1 c_48' id='c_48_1' href='#c_48_2' cs_f='.c_48' >Hardware Description Language</span> - VHDL . . . . . . . . . . . . . 16<br>
2.1.2 Portas lógicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18<br>
2.2 Verificação de sistemas . . . . . . . . . . . . . . . . . . . . . . . . . . 19<br>
2.2.1 Diagrama de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.2 Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.3 Bounded Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . 21<br>
2.2.4 Redes de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22<br>
2.2.5 Verificação de hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
2.2.6 Verificação formal de software . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.7 Lógica proposicional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.8 Linguagem de especificação de propriedades . . . . . . . . . . . . . . 26<br>
2.2.9 Verificação baseada em assertivas . . . . . . . . . . . . . . . . . . . . 26<br>
2.2.10 Propriedades de segurança . . . . . . . . . . . . . . . . . . . . . . . . 27<br>
2.3 Técnicas de compiladores . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.1 Transformações de código . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2 Otimização de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2.1 Grafo Acliclico Direcional - GAD . . . . . . . . . . . . . . . . . . . . . . . . 29<br>
2.3.2.2 Grafo <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >de Fluxo de</span> Controle - GFC . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.3 Eliminção de código morto . . . . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.4 Análise do <span class='f1 c_74' id='c_74_1' href='#c_74_2' cs_f='.c_74' >fluxo de dados</span> . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
2.3.2.5 Gerador de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
3 TRABALHOS CORRELATOS . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1 Revisão sistemática . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1.1 Planejamento da Revisão Sistemática . . . . . . . . . . . . . . . . . . 33<br>
3.1.1.1 Procedimentos de Seleção e Critérios . . . . . . . . . . . . . . . . . . . . 35<br>
3.2 Revisão da literatura . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.1 V2c-A verilog to C translator . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.2 Unbounded safety verification for hardware using software analyzers . 37<br>
3.2.3 Formal verification of timed VHDL programs . . . . . . . . . . . . . . . 38<br>
3.2.4 On the use of assertions for embedded-software dynamic verification 38<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation . . 39<br>
4 MÉTODO PROPOSTO . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.1 Visão geral do método . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.2 Preprocessamento do VHDL e inserção de assertivas . . . . . . . 42<br>
4.3 Tradução de código VHDL para a linguagem C . . . . . . . . . . . . 43<br>
4.4 Instrumentação de código . . . . . . . . . . . . . . . . . . . . . . . . 45<br>
4.5 Verificação de assertivas usando Model Checker . . . . . . . . . . 46<br>
5 CRONOGRAMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52<br>
6 CONSIDERAÇÕES PARCIAIS E TRABALHOS FUTUROS . . . . . 53<br>
BIBLIOGRAPHY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54<br>
11<br>
1 INTRODUÇÃO<br>
A complexidade de sistemas computacionais cresce exponencialmente. Muitas compan- Exemplificar<br>
este<br>
cresci-<br>
mento.<br>
hias e organizações estão rotineiramente lidando com software que contém milhares de linhas<br>
de código, escritos por diferentes pessoas, que usam linguagens distintas, ferramentas, estilos e<br>
hardware projetados de diversas formas e combinações (HODER et al., 2011).<br>
No contexto de sistemas compostos <span class='f1 c_59' id='c_59_1' href='#c_59_2' cs_f='.c_59' >de hardware e software</span>, tem-se os sistemas embarca-<br>
dos (SE) que são dispositivos semicondutores com software integrados, os quais se conectam<br>
a outros dispositivos. Usualmente, o principal propósito dos SE é o controle e provimento de<br>
informações para uma função específica (RAMESH et al., 2012).<br>
Os SE são extremamente interativos com seu ambiente, operam geralmente em tempo real<br>
e estão disponíveis continuamente. No entanto, estes sistemas, por possuírem um curto espaço<br>
de tempo para a liberação do produto ao mercado, precisam ser desenvolvidos rapidamente e<br>
atingir um alto nível de qualidade, mas, devido a esta necessidade, os programadores podem<br>
cometer enganos durante <span class='f1 c_44' id='c_44_1' href='#c_44_2' cs_f='.c_44' >a fase de</span> desenvolvimento destes sistemas.<br>
Os SE têm se proliferado em partes consideráveis das atividades do nosso cotidiano,<br>
com a característica de possuir grande quantidade de complexidade e diversidade. Devido a esta<br>
complexidade, erros podem passar despercebidos, causando não apenas penalidades econômicas<br>
e/ou fracassos do produto no mercado, mas principalmente o risco de perda de vidas humanas<br>
(CABODI et al., 2016). Como, por exemplo, o acidente noticiado no (G1, 2012), no qual, de<br>
acordo com o secretário de transportes, uma falha na placa do circuito eletrônico responsável<br>
pelo controle de velocidade dos trens ocasionou a colisão entre duas composições na estação de<br>
metrô de São Paulo.<br>
Segundo ROCHA et al.2015b, para se obter um alto nível de qualidade no desenvolvi-<br>
mento dos sistemas <span class='f1 c_59' id='c_59_1' href='#c_59_2' cs_f='.c_59' >de hardware e software</span>, a execução desses sistemas deve ser controlada e da<br>
mesma forma deve-se buscar meios de garantir que as propriedades definidas sejam atingidas. Por<br>
exemplo, a partir do conhecimento prévio do modo de implementação de determinado hardware,<br>
é possível utilizá-lo de forma mais eficiente. Neste sentido, diversas estratégias de verificação e<br>
de teste estão sendo pesquisadas e aplicadas para garantir a qualidade do software e hardware<br>
(HODER et al., 2010; ROCHA et al., 2010; BRAYTON; MISHCHENKO, 2010; CORDEIRO et<br>
al., 2012; CABODI et al., 2016).<br>
Por este motivo, com o intuito de analisar e otimizar a descrição dos circuitos digitais,<br>
tem-se utilizado <span class='f1 c_26' id='c_26_1' href='#c_26_2' cs_f='.c_26' >as linguagens de</span> descrição de hardware (HDL). Estas se diferem das linguagens<br>
de programação por conseguirem gerar execuções não apenas sequenciais, como também con-<br>
correntes ou paralelas (CHU, 2006). Neste contexto, a VHSIC <span class='f1 c_48' id='c_48_1' href='#c_48_2' cs_f='.c_48' >Hardware Description Language</span><br>
Chapter 1. INTRODUÇÃO 12<br>
(VHDL) é uma das linguagens de descrição de hardware mais utilizadas atualmente. A descrição<br>
em VHDL pode ser em vários níveis de abstração, sendo o mais alto o nível comportamen-<br>
tal que permite a descrição do circuito através de loops e processos, definido-o na forma de<br>
algoritmo. Como características das linguagens de descrição, o VHDL permite declarações se-<br>
quenciais ou concorrentes onde as declarações continuam ativas e sua ordem torna-se irrelevante<br>
(CAPPELATTI, 2010).<br>
Aliada à linguagem de descrição <span class='f1 c_64' id='c_64_1' href='#c_64_2' cs_f='.c_64' >de hardware, a</span> verificação formal de sistemas computa-<br>
cionais tem desempenhado um papel importante para assegurar a previsibilidade e a confiabili-<br>
dade na concepção de aplicações críticas. E, para isso, tem-se utilizado a técnica denominada<br>
model checking, que é baseada em formalismos matemáticos para provar propriedades de pro-<br>
gramas reativos (BENSALEM; LAKHNECH, 1999). Esta técnica gera uma busca exaustiva no<br>
espaço de estados do modelo para determinar se uma dada propriedade é válida ou não (BAIER<br>
et al., 2008), tendo como principal razão para o seu sucesso o funcionamento completamente<br>
automático, ou seja, sem qualquer intervenção do usuário.<br>
Visando contribuir com a verificação de sistemas embarcados no âmbito de sistemas<br>
computacionais, o contexto deste trabalho está situado no uso de metodologias e técnicas de<br>
verificação formal para programas escritos em VHDL (BIERE, 2016), focando principalmente<br>
no Bounded Model Checking (CORDEIRO et al., 2012; ROCHA et al., 2015a). Este trabalho está<br>
interessado especificamente na parte de: verificação de modelos de hardware descritos em níveis<br>
de circuitos de bits na linguagem VHDL, via transformações de código para gerar modelos (com<br>
assertivas) já suportados por model checkers, como o ESBMC (CORDEIRO et al., 2012).<br>
Dessa forma, o trabalho almeja analisar as propriedades de alcançabilidade para a<br>
identificação de localizações de erro, bem como, assertivas contendo propriedades de segurança.<br>
A propriedade de alcançabilidade ou propriedade do estado de erro é satisfatória (SAT), se um<br>
estado de erro é alcançável. Caso contrário, a propriedade é considerada insatisfatória (UNSAT).<br>
No caso SAT, o model checking também gera um rastreio da validação da propriedade (contra-<br>
exemplo), ou seja, uma sequência de estados que mostra como chegar ao erro a partir de um<br>
ponto inicial.<br>
1.1 Definição do problema<br>
O avanço da tecnologia, principalmente nas áreas de design e fabricação de eletrônicos,<br>
aumentou a importância do hardware nos dias atuais. Cada vez com mais funcionalidades<br>
integradas, aliada a velocidade e circuitos menores, faz com que a complexidade dos sistemas<br>
de hardware aumente. Entretanto, devido à complexidade cada vez maior, a detecção tardia<br>
de erros no sistema pode resultar em perda de produção, mas também custos associados ao<br>
desenvolvimento do sistema(GUPTA, 1992). Devido a isso, a verificação de hardware visa<br>
assegurar que o circuito atinja as especificações para o qual foi projetado, através de técnicas<br>
Chapter 1. INTRODUÇÃO 13<br>
formais ou dinâmicas (BOULE; ZILIC, 2007).<br>
Por esta razão, a utilização de métodos formais tornou-se uma abordagem atraente<br>
para superar as limitações inerentes à validação baseada em simulação. Portanto, a maioria<br>
das empresas de semicondutores têm investigado a sua aplicabilidade. Escolhas individuais de<br>
métodos, ferramentas e áreas de aplicação das empresas têm variado, assim como o seu nível<br>
de sucesso (CABODI et al., 2016). Com os recentes avanços na escalabilidade de automação<br>
dos model checkers e nas equivalências sequenciais de verificação, a maioria das empresas têm<br>
crescido ao contar com essas técnicas(CLARKE, 2008).<br>
O problema considerado neste trabalho é expresso na seguinte questão: Como comple-<br>
mentar e aprimorar a verificação de propriedades de segurança em circuitos lógicos, de tal<br>
forma que uma propriedade possa ser mapeada em um problema de alcançabilidade sim-<br>
bólica, ou seja, se é possível alcançar um estado específico (para uma dada propriedade) a<br>
partir do estado inicial?<br>
1.2 Objetivos<br>
O objetivo principal deste trabalho é projetar e avaliar um método para efetuar verificação<br>
de circuitos, de forma automática, descritos em VHDL com portas lógicas em nível de bit<br>
pela utilização de técnicas de transformação de códigos combinado com a técnica Bounded<br>
Model Checking para exploração de estados alcançáveis no circuito, visando identificar erros ou<br>
comportamentos indevidos ou inesperados que podem resultar no funcionamento incorreto de<br>
um dado sistema.<br>
Os objetivos específicos são:<br>
1. Propor um método para especificar pré e pós-condições de circuitos digitais em nível de<br>
portas lógicas descritos em VHDL;<br>
2. Analisar ferramentas de verificação de modelos que utilizam a técnica Bounded Model<br>
Checking;<br>
3. Especificar uma técnica de conversão de circuitos em linguagem de descrição de hardware<br>
VHDL para um modelo a ser verificado usando a técnica Bounded Model Checking;<br>
4. Desenvolver um método para identificação de estados de erros ou ocorrências indevidas,<br>
de um dado circuito analisado, em modelos de hardware descritos em nível de bit <span class='f1 c_56' id='c_56_1' href='#c_56_2' cs_f='.c_56' >na<br>
linguagem de</span> descrição VHDL.<br>
5. Validar a aplicação do método proposto sobre benchmarks públicos de programas em<br>
VHDL, a fim de examinar a sua eficácia e aplicabilidade.<br>
Chapter 1. INTRODUÇÃO 14<br>
1.3 Organização do trabalho<br>
A introdução deste trabalho apresentou: o contexto, definição do problema, e objetivos<br>
deste trabalho. Os próximos capítulos estão organizados da seguinte forma:<br>
No Capítulo 2 Conceitos e Definições, são apresentados os conceitos abordados neste<br>
trabalho, especificamente: Linguagens de descrição de hardware; Verificação e validação de<br>
sistemas; e Técnicas de compiladores.<br>
No Capítulo 3 Trabalhos Correlatos, serão apresentados o método de pesquisa bibli-<br>
ográfica utilizado, sendo ele a revisão sistemática, seguido do resultado encontrado com esta<br>
pesquisa e, por fim, a contribuição dos artigos utilizados no desenvolvimento do projeto.<br>
No Capítulo 4 Método Proposto, são descritas as etapas de execução do novo método<br>
proposto que consiste na transformação do código, instrumentação de assertivas e verificação de<br>
código utilizando um model checker.<br>
No Capítulo 5, será apresentado o cronograma de atividades a ser realizado na elaboração<br>
do método durante o desenvolvimento do projeto.<br>
E, por fim, no Capítulo 6 Considerações parciais e trabalhos futuros, serão apresentas<br>
as considerações parciais e as sugestões de trabalhos futuros que podem ser desenvolvidos.<br>
15<br>
2 CONCEITOS E DEFINIÇÕES<br>
Este capítulo tem apresenta os principais conceitos e definições abordados neste tra-<br>
balho, tais <span class='f1 c_66' id='c_66_1' href='#c_66_2' cs_f='.c_66' >como: Linguagens de</span> descrição de hardware, Verificação de sistemas e Técnicas de<br>
Compiladores.<br>
2.1 Linguagens de descrição de hardware<br>
<span class='f1 c_26' id='c_26_1' href='#c_26_2' cs_f='.c_26' >As linguagens de</span> descrição de hardware (HDL) foram desenvolvidas com o intuito de<br>
auxiliar a criação de circuitos lógicos com grande número de elementos e com uma gama de<br>
abstrações lógicas e eletrônicas (THOMAS; MOORBY, 2008). Entre os exemplos, podemos<br>
citar: VDHL (IEC/IEEE. . . , 2011), Verilog (IEEE. . . , 2006) e SystemC (??).<br>
Segundo CHRISTEN; BAKALAR,1999, linguagens de descrição de hardware são lingua-<br>
gens de programação utilizadas com o intuito de descrever o comportamento de um determinado<br>
circuito, técnica conhecida como modelagem. Os modelos descritos em HDL são utilizados<br>
como entrada para um simulador, onde o mesmo pode ter seu comportamento analisado.<br>
As HDL’s trazem consigo diversas vantagens, entre elas códigos independentes de tec-<br>
nologia e fabricante, podendo ser portáteis e reutilizáveis (CAPPELATTI, 2010). As linguagens<br>
mais modernas, tais como <span class='f1 c_30' id='c_30_1' href='#c_30_2' cs_f='.c_30' >VHDL e Verilog</span>, possuem suporte tanto a descrição do circuito pro-<br>
priamente dito, quanto ao comportamento que o mesmo deve exercer (CHRISTEN; BAKALAR,<br>
1999).<br>
A Verilog, como já citado, é <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >uma linguagem de</span> descrição de hardware que fornece<br>
diversos níveis de abstração para desenvolvimento de sistemas digitais(THOMAS; MOORBY,<br>
2008). A linguagem foi desenvolvida para ser simples e efetiva nos diversos níveis de abstração<br>
incluindo o suporte ao desenvolvimento, verificação, síntese e testes de software (IEEE. . . , 2006).<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog.<br>
1 p r i m i t i v e m u l t i p l e x e r ( mux , c o n t r o l , dataA , da taB ) ;<br>
2 o u t p u t mux ;<br>
3 i n p u t c o n t r o l , dataA , da taB ;<br>
4 e n d p r i m i t i v e<br>
Fonte: Adaptado de (IEEE. . . , 2006).<br>
Na Figura 1 apresenta um exemplo de multiplexador descrito em Verilog utilizando a<br>
estrutura de modelagem, chamada UDP que permite a criação de novos primitivas para serem<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 16<br>
utilizada. Apresenta uma saída apenas(mux) e três entradas sendo uma de controle(control) e<br>
duas de dados(dataA e dataB).<br>
A VHDL é <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >uma linguagem de</span> descrição de hardware amplamente utilizada, concebida<br>
na década de 80, devido uma necessidade <span class='f1 c_47' id='c_47_1' href='#c_47_2' cs_f='.c_47' >do Departamento de Defesa dos</span> Estados Unidos<br>
da América (CAPPELATTI, 2010). Assim como a Verilog, esta linguagem também suporta o<br>
desenvolvimento, a verificação, a síntese, e os testes de hardware (IEC/IEEE. . . , 2011).<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL.<br>
1 l i b r a r y IEEE ;<br>
2 use IEEE . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 use IEEE . s t d _ l o g i c _ u n s i g n e d . a l l ;<br>
4 e n t i t y mux2x1 i s<br>
5 p o r t ( s e l : i n STD_LOGIC ;<br>
6 a , b : i n STD_LOGIC ;<br>
7 y : o u t STD_LOGIC ) ;<br>
8 end mux2x1 ;<br>
9<br>
10 a r c h i t e c t u r e d a t a f l o w of mux2x1 i s b e g i n<br>
11 y &lt;= ( a AND NOT s e l ) OR ( b AND s e l ) ;<br>
12 end d a t a f l o w .<br>
Fonte: (CAPPELATTI, 2010).<br>
Na Figura 2 está descrito um multiplexador de duas entradas descrito em VHDL, apre-<br>
sentando na parte inicial as bibliotecas e na entidade(entity) a declaração das variáveis utilizadas.<br>
Na arquitetura(architecture) apresenta <span class='f1 c_69' id='c_69_1' href='#c_69_2' cs_f='.c_69' >o funcionamento do</span> multiplexador, relacionando en-<br>
tradas e saídas conforme tenham sido declarados. Este conceitos serão melhor apresentados na<br>
subsection 2.1.1.<br>
Conforme apresentado nas Figura 1 e Figura 2, <span class='f1 c_16' id='c_16_1' href='#c_16_2' cs_f='.c_16' >ambas as linguagens</span> apresentam difer-<br>
enças no modelos de declaração e utilização para descrição de hardware. Para este trabalho foi<br>
escolhido a VHDL devido a linguagem apresentar um melhor escopo para análise, facilitando o<br>
trabalho de análise proposto para este projeto.<br>
2.1.1 VHSIC <span class='f1 c_48' id='c_48_1' href='#c_48_2' cs_f='.c_48' >Hardware Description Language</span> - VHDL<br>
Revisar textos e verificar a necessidade de mais exemplo<br>
VHDL é <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >uma linguagem de</span> descrição de hardware destinada a ser utilizada em todas<br>
as etapas da criação de sistemas eletrônicos, sendo elas: desenvolvimento; verificação; síntese;<br>
e, teste de circuitos (IEC/IEEE. . . , 2011). Segundo (CAPPELATTI, 2010), a VHDL apresenta<br>
três principais pilares: abstração, que consiste na descrição com diferentes níveis de detalhes;<br>
modularidade, que permite a divisão <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >do projeto em</span> vários blocos ou módulos para posterior<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 17<br>
interconexão; e hierarquia, permite que módulos possam ser compostos por submódulos e, os<br>
mesmos tenham níveis de abstração diferentes, dependendo da necessidade do projeto. Devido a<br>
esta versatilidade que a linguagem VHDL foi selecionada para o trabalho proposto.<br>
Segundo IEC/IEEE. . . ,2011, é necessário um padrão para formatação da descrição em<br>
VHDL: Entity (Pinos de entrada/saída) e Architecture (Arquitetura). A Entity ou entidade repre-<br>
senta o bloco onde são declaradas <span class='f1 c_77' id='c_77_1' href='#c_77_2' cs_f='.c_77' >as entradas e as</span> saídas do circuito utilizadas em todo o sistema,<br>
conforme apresentado na Figura 3. A Architecture ou arquitetura, apresentado na Figura 4, define<br>
a relação entre entradas e saídas declaradas na entidade, podendo tais especificações serem<br>
completas ou parciais. Assim como em outras linguagens, bibliotecas podem ser adicionadas,<br>
para que novas funções e atributos possam ser utilizados no projeto.<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade.<br>
1 l i b r a r y i e e e ;<br>
2 use IEEE . STD_LOGIC_1164 . ALL<br>
3<br>
4 ENTITY f u l l _ a d d e r IS PORT(<br>
5 x1 , x2 , c i n : i n s t d _ l o g i c ;<br>
6 S , c o u n t : o u t s t d _ l o g i c ) ;<br>
7 END f u l l _ a d d e r ;<br>
Fonte: Própria.<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL.<br>
1 ARCHITECTURE b e h a v i o r a l OF f u l l _ a d d e r IS<br>
2 BEGIN<br>
3 s &lt;=x1 XOR x2 XOR c i n ;<br>
4 cout &lt;=( x1 AND x2 ) OR ( x1 AND c i n ) OR ( b<br>
AND c i n ) ;<br>
5 END b e h a v i o r a l ;<br>
Fonte: Própria.<br>
Segundo CAPPELATTI,2010 uma descrição em VHDL pode conter diferentes níveis de<br>
abstração:<br>
• Comportamental: Permite descrever o circuito através de laços e processos. O circuito<br>
é definido em forma de um algoritmo, utilizando construção similares as utilizadas em<br>
linguagem de programação.<br>
• Transferência de registradores: Englobando a representação do dispositivo em nível de<br>
transferência entre registradores, que consiste na utilização de funções lógicas combina-<br>
cionais e de registradores.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 18<br>
• Estrutural: O circuito é descrito mais próximo da implementação real, podendo ser<br>
definidas portas lógicas com atrasos unitários ou com atrasos detalhados.<br>
2.1.2 Portas lógicas<br>
Segundo (IDOETA; CAPUANO, 1982), o conceito de portas lógicas é baseado na<br>
conhecida álgebra de Boole ou álgebra booleana, desenvolvida pelo matemático inglês George<br>
Boole em 1854. A álgebra booleana é representada por apenas dois valores, sendo eles o 0 e 1 e,<br>
através disso, expressa a relação entre entrada e saída dentro de um circuito. As portas lógicas<br>
podem ser construídas a partir de diodos, transistores e resistores interconectados de modo que a<br>
saída seja o resultante de uma operação lógica básica realizada sobre as entradas (TOCCI et al.,<br>
2003). A Figura 5 apresenta um exemplo de álgebra booleana sem a utilização de diagramas.<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1.<br>
Fonte: (TOCCI et al., 2003)<br>
Ainda segundo TOCCI et al.,2003, devido a esta característica, a álgebra booleana possui<br>
três operações básicas, OR (ou), AND (e) e NOT (não). Tal conjunto de operações também é<br>
denominado de operações booleanas e, por meio da utilização de tabelas verdade é possível<br>
descrever as saídas baseando-se nas entradas e na operação aplicada. Cada operação booleana<br>
possui sua tabela verdade ( Figura 6), bem como sua representação em forma de diagrama.<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas.<br>
Fonte: (TOCCI et al., 2003)<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 19<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas.<br>
Fonte: (TOCCI et al., 2003)<br>
A Figura 7 apresenta um circuito lógico formado pelas portas básicas da álgebra booleana.<br>
O circuito apresenta três entradas representadas pelas letras A, B e C, mas também formada<br>
por duas portas AND, uma porta NOT e uma porta OR. Cada uma destas portas representando<br>
operações a serem realizadas, podendo receber como entrada um valor inicial ou resultante de<br>
outra porta, como no exemplo ocorre com a última porta AND.<br>
Entetanto, segundo (KROPF, 2013), a análise de circuitos é extremamente complexa,<br>
resultando em um problema NP-Completo, algoritmos possuem tempo de execução exponencial.<br>
Contudo, este tempo de execução exponencial é uma complexidade exponencial para o pior caso,<br>
resultando crescimento exponencial da execução a medida que o tamanho do problema aumenta.<br>
Ainda, segundo (KROPF, 2013) a avaliação das funções booleanas podem ser ver-<br>
dadeiras(True) ou falso(False), com isso, para um função com n variáveis, apresenta 2n possibili-<br>
dades de avaliação. Utilizando o exemplo da Figura 7 que apresenta 3 entradas, logo apresenta 8<br>
possibilidade de avaliação ao final e este número aumenta à medida que o número de variáveis<br>
tambe aumenta<br>
2.2 Verificação de sistemas<br>
No contexto de verificação de sistemas, faz-se necessário a diferenciação entre verificação<br>
e validação. Verificação e validação possuem o intuíto de mostrar que determinado sistema fun-<br>
cione conforme o especificado, além de satisfazer as especificações do cliente (SOMMERVILLE,<br>
2011).<br>
Segundo (SARGENT, 2005), verificação é <span class='f1 c_57' id='c_57_1' href='#c_57_2' cs_f='.c_57' >o processo de</span> determinar se um modelo<br>
computacional obtido por discretização de um modelo matemático de um evento físico e o<br>
código que implementa o modelo computacional pode ser usado para representar o modelo<br>
matemático do evento com precisão suficiente e validação é <span class='f1 c_57' id='c_57_1' href='#c_57_2' cs_f='.c_57' >o processo de</span> determinar se um<br>
modelo matemático de um evento físico representa o evento físico real com precisão suficiente.<br>
A verificação consite identificação de erros e provavéis problemas que um componente<br>
pronto possa apresentar, enquanto a validação busca analisar se tal componete esta seguindo<br>
os requisitos pré-definidos para sua construção (KOSCIANSKI; SOARES, 2007). O teste de<br>
programa, na qual o software é executado com dados de teste é a principal forma de validação,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 20<br>
porém, tecnicas de verificação, tais como, inspeção e revisões também podem integrar a etapa de<br>
validação (SOMMERVILLE, 2011).<br>
2.2.1 Diagrama de decisão binária<br>
<span class='f1 c_67' id='c_67_1' href='#c_67_2' cs_f='.c_67' >Um diagrama de</span> decisão binária(DDB) pode ser definido como um grafo aciclico para<br>
representação de funcões boolenas. Existe uma ordem rigorosa na ocorrência de variáveis à me-<br>
dida que se percorre o grafo da raiz para a folha. Dado como exemplo a formula f=(a?b)?(c?d)<br>
e utilizando a ordenação de variavél a &lt; b &lt; c &lt; d, na Figura 8. Dada a atribuição de valores<br>
booleanos as variaveis a, b, c e d, pode-se decidir se a atribuição torna a fórmula verdadeira<br>
atravessando o início do gráfico na raiz e ramificação em cada nó. Definindo a, c e d = 1 e c = 0<br>
leva a folha de rótulo 1, portanto, a fórmula é verdadeira para essa tarefa (CLARKE et al., 1994).<br>
Figure 8 – Arvore de decisão binária<br>
Fonte: (CLARKE et al., 1994)<br>
Adicionar mais detalhes e descrever onde DDB é utilizado.<br>
O DDB permite o teste eficiente de satisfabilidade, validade e eficiência (KROPF, 2013).<br>
O uso e DDB em conjunto com Model Checking e técnicas de abstração permitiu o aumento na<br>
capacidade de verificação, de modo que sistemas mais realistas podessem ser verificados(??)<br>
2.2.2 Model Checking<br>
Model checking é uma técnica de verificação formal que explora todos os possíveis<br>
estados do sistema, de modo a provar se um modelo satisfaz determinada propriedade. Pode ser<br>
aplicada em uma ampla gama de aplicações, tais como sistema embarcados, design <span class='f1 c_59' id='c_59_1' href='#c_59_2' cs_f='.c_59' >de hardware<br>
e</span> engenharia de software (BAIER et al., 2008).<br>
Entre as vantagens da utilização de Model Checking estão:<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 21<br>
• Possuem suporte a verificação parcial, em outras palavras, a verificação individual de<br>
propriedades, permitido foco primeiro as propriedades essenciais(BAIER et al., 2008).<br>
• Não requer qualquer interação do usuário, nem um alto grau de especialização <span class='f1 c_61' id='c_61_1' href='#c_61_2' cs_f='.c_61' >para o uso</span><br>
de model checking(BAIER et al., 2008).<br>
• Possui como base a teoria de grafos, estruturas de dados e lógica no desenvolvimento da<br>
solução(BAIER et al., 2008).<br>
• Útil para fins de depuração, pois formece informações em caso de uma propriedade seja<br>
invalidada(BAIER et al., 2008).<br>
<span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Por outro lado</span>, apresenta também algumas desvantagens:<br>
• Sofre do problema de explosão de espaço de estados, ou seja, a quantidade de estados<br>
necessários pode ser maior que a memória disponivel pelo sistema(BAIER et al., 2008).<br>
• Faz a verificação apenas dos requisios declarados, logo, não a garantia de integridade.<br>
Baseado nisso, a validade de propriedades não verificadas não pode ser julgada(BAIER et<br>
al., 2008).<br>
• A verificação de modelos geralmente não é computável, isso deve-se a questões de decidi-<br>
bilidade utilizada (BAIER et al., 2008).<br>
Outras técnicas foram implementadas em conjuntos com Model checkings com o intuito<br>
de aumentas <span class='f1 c_36' id='c_36_1' href='#c_36_2' cs_f='.c_36' >a capacidade de</span> verificação, como a técnica SAT na qual não sofre do problema de<br>
explosão de estados existente usando DDB. A técnica SAT em conjuto com Model Checking é<br>
conhecida como Bounded Model Checking (??).<br>
2.2.3 Bounded Model Checking<br>
Segundo ROCHA et al., Bounded Model Checking (BMC) é um tipo especial de Model<br>
Checking que usualmente adota o método de satisfabilidade booleana, o qual tem sido introduzido<br>
como uma técnica complementar para diagrama de decisão binaria para aliviar o problema da<br>
explosão de estados, visto que a técnica de Model Checking busca todos os estados possíveis<br>
para verificação.<br>
Bounded Model Checking é uma técnica para a verificação de uma dada propriedade<br>
em uma determinada profundidade do sistema analisado. Logo, dado um sistema de transições<br>
M, uma propriedade ?, e um limite (bound) k, o BMC desenrola o sistema k vezes e traduz o<br>
sistema em uma condição de verificação(CV) ? tal que ? é satisfeito se e somente se ? tem um<br>
contra-exemplo de profundidade menor ou igual a k (ROCHA et al., 2015b).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 22<br>
O Extended SMT-Based Bounded Model Checker (ESBMC) é um Bounded Model<br>
Checking baseado em satisfabilidade booleana (SAT) que permite verificação aritmética de Já tem<br>
su-<br>
porte<br>
a<br>
SMT<br>
adi-<br>
cionar<br>
ao<br>
texto<br>
overflow e undeflow, segurança de ponteiros, limite de array, de gerar propriedades de segurança<br>
em programas <span class='f1 c_60' id='c_60_1' href='#c_60_2' cs_f='.c_60' >em C/C</span>++. ESBMC utiliza uma versão modificada do CBMC no front-end para<br>
analisar o código ANSI-C e para gerar as condições de verificação através de execução simbólica<br>
(CORDEIRO et al., 2012; ROCHA et al., 2015b).<br>
No ESBMC, o programa analisado é modelado em um sistema de transição de estados,<br>
conforme a trupla: M = (S,R, S0), o qual é gerado um grafo de controle de fluxo (GFC), onde<br>
S representa o conjunto de estados, R ? SxS representa as transições e S ? S representa<br>
o conjuto de estados iniciais. Um estado s ? S consiste no valor do contador de programa<br>
(PC) e os valores de todas as variáveis dos programas. O estado inicial S0 atribui o inicio do<br>
programa GFC ao PC, desta forma o ESBMC identifica as transições, conforme a formula lógica,<br>
?=(Si,Si+1) que captura as retrições sobre os valores correspondntes do PC e das variáveis do<br>
programa (CORDEIRO et al., 2012).<br>
Segundo o site do ESBMC(??), a ferramenta permite ao usuário indicar propriedades<br>
adicionaisusando assertivas que também são verificadas. O ESBMC converte as condições Descrever<br>
quais<br>
pro-<br>
priedades<br>
o<br>
esbmc<br>
su-<br>
porta<br>
usando diferentes técnicas de backgroundpara posteriormente passar para verificador SMT. Outra<br>
apresentar<br>
exem-<br>
plo<br>
vantagem é a ferramenta permitir verificação de software single-thread e multi-thread.<br>
Descrever qual a razão da escolha para o trabalho, apresentar resultados do SV-COMP<br>
dos últimos 3 anos<br>
2.2.4 Redes de petri<br>
Apresentar definição formal para RP<br>
corrigir o texto abaixo RP não é uma ferramenta e sim um método de modelagem<br>
Redes de petri são utilizadas como ferramentas de modelagem gráfica com propriedades<br>
matemática. Como ferramenta gráfica são utilizadas como comunicação visual, como fluxogra-<br>
mas, por exemplo, e como ferramenta matemática podem configurar modelos matemáticos que<br>
regem o comportamento dos sistemas. A grade premissa desta ferramenta é descrever sistemas<br>
de processamento de informações caracterizados como concorrentes, assíncronos, distribuídos,<br>
paralelos, não deterministas e/ou estocásticos (MURATA, 1989).<br>
As redes de petri são representados como grafos direcionais compostos por nós e arcos,<br>
conforme apresentado na Figura 9. Os nós representam as transições e eventos e os arcos<br>
representam os pesos. Dentro desta representação, os arcos e eventos são componentes passivos<br>
enquanto as transições são ativos. A principal vantagem da utilização das redes de petri esta<br>
relacionado ao chamado "Token game" que consiste no comportamento da rede de petri, em<br>
outras palavras, representa <span class='f1 c_69' id='c_69_1' href='#c_69_2' cs_f='.c_69' >o funcionamento do</span> sistema representado pela rede(HALDER;<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 23<br>
VENKATESWARLU, 2006).<br>
Figure 9 – Rede de petri<br>
Fonte: (HALDER; VENKATESWARLU, 2006)<br>
<span class='f1 c_65' id='c_65_1' href='#c_65_2' cs_f='.c_65' >Descrever o funcionamento</span> da RP apresentado na IMG<br>
Descrever quais <span class='f1 c_7' id='c_7_1' href='#c_7_2' cs_f='.c_7' >propriedades podem ser</span> verificadas com RP e onde será utilizado no seu<br>
trabalho.<br>
2.2.5 Verificação de hardware<br>
Para a verificação de hardware diversas técnicas têm sido propostas (). Por meio da Apresentar<br>
exem-<br>
plos<br>
com<br>
refer-<br>
ências<br>
simulação, visa assegurar que uma implemetação, descrição do hardware em qualquer qualquer<br>
nível de abstração da hierarquia de hardware, atinja suas especificações, propriedades que devem<br>
ser respeitadas para que a corretude do mesmo seja comprovada (GUPTA, 1992). A Verificação<br>
formal de hardware consiste na utilização de técnicas para corretude de circuitos lógicos, ou<br>
seja, consiste na utilização de modelos matemáticos para descrição de propriedade e/ou de<br>
comportamento de um dado sistema (KROPF, 2013).<br>
Entre as abordagens utilizadas na verificação formal de hardware consiste tanto na imple-<br>
mentação quanto a especificação estarem descritas em lógica formal, neste caso a corretude será<br>
obtida através da comprovada relação entre a implementação e a especificação (SEGER, 1992).<br>
A especificação formal consiste na descrição do comportamento, bem como, das propriedades<br>
do sistema em linguagem matemática, tornando-se crucial para <span class='f1 c_57' id='c_57_1' href='#c_57_2' cs_f='.c_57' >o processo de</span> verificação. Na<br>
implementação formal, o nível de abstração, tais como, Gate level e RTL são importantes infor-<br>
mações <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento</span> do formalismo, bem como as classes, por exemplo se o circuito<br>
é sequencial ou combinacional, se utiliza pipeline, etc (KROPF, 2013).<br>
Apresentar um exemplo de RTL<br>
A utilização de Model Checking também se faz presente nos modelos formais de ver-<br>
ificação de hardware, onde apenas é utilizado o comportamento dos circuitos na verificação,<br>
de modo a verificar a se as propriedades presentes são satisfeitas. Para isso, são utilizados os<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 24<br>
conceitos da lógica proposicional, que por meio da utilização de fórmulas que representem as<br>
propriedades dos estados, é possível realizar as verificações necessárias (SEGER, 1992).<br>
Apresentar um exemplo com um circuito e como este pode ser verificando com model<br>
checking<br>
2.2.6 Verificação formal de software<br>
Observa-se que o uso de verificacão de software tem sido feito aplicado em muitas áreas,<br>
tais como, infraestruturas industriais de missão critica e de segurança. Logo, existe a necessidade<br>
de garantir a corretude destes sistemas. Devido a isso, a verificação formal tem sido utilizada em<br>
três principais abordagens, sendo elas (COUSOT; COUSOT, 2010; D’SILVA et al., 2008):<br>
Apresentar exemplos para os métodos apresentados abaixo<br>
• Métodos dedutivos: Produzem provas matemáticas formais de corretude usando provadores<br>
de teoremas ou assistentes de prova para execução da prova e necessitam da interação<br>
humana para prover os argumentos (COUSOT; COUSOT, 2010);<br>
• Verificação de modelos: Exploram exaustivamente modelos de execuções de programa,<br>
que podem ser sujeitos a explosão combinatória, necessário a intervenção humana para<br>
geração dos modelos (ROCHA et al., 2015b);<br>
• Analise estática: Engloba diversas técnicas para calcular automaticamente informações<br>
<span class='f1 c_82' id='c_82_1' href='#c_82_2' cs_f='.c_82' >sobre o comportamento</span> de um programa sem executá-lo, sendo utilizado em otimização<br>
de código e verificação em compiladres (D’SILVA et al., 2008).<br>
Segundo ROCHA et al., na verificação formal de software apresentam-se dificuldades,<br>
tais como: quais as propriedades são de interesse na verificação em tempo de execução; e<br>
impossibilidade matemática de provar a corretude de propriedades não triviais no comportamento<br>
de programas (COUSOT; COUSOT, 2010).<br>
2.2.7 Lógica proposicional<br>
A lógica proposicional é uma linguagem formal onde é definida um alfabeto e conectivos<br>
proposicionais, e <span class='f1 c_45' id='c_45_1' href='#c_45_2' cs_f='.c_45' >um conjunto de</span> regras gramaticais, as quais serão utilizadas para construção<br>
das proposições (SOUZA, 2017). Porém apesar de importante, ela é limitada, não podendo<br>
expressar sentenças elementares importantes, tais como a da aritmética elementar. Por exemplo:<br>
1. Todos são mortais.<br>
2. Alguém é bondoso.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 25<br>
Na lógica preposicional, não poderiam ser analisadas, pois não teria como decompor<br>
ambas em sentença e assim não teria como analisar as diferenças entre ambas(ABE, 2002).<br>
Contudo, no exemplo: Existem cavalos com patas verdes. A relação criada pela frase poderia a<br>
ser analisada pela lógica proposicional(ABE, 2002). Descrever<br>
como<br>
seria<br>
está<br>
analise<br>
Segundo SOUZA, alfabeto da lógica proposicional é formado por símbolo de pontuação,<br>
símbolos proposicionais e conectivos proposicionais, onde cada um apresenta uma função em<br>
específico, sendo:<br>
• Símbolos de pontuação: Apenas dois símbolos de pontuação são utilizados o "(" e o ")".<br>
• Símbolos proposicionais: São utilizados para representar as proposições, onde um sím-<br>
bolo P pode ser utilizado para representar uma proposição qualquer, por exemplo: P="Está<br>
chovendo". O conjunto de símbolos proposicionais é infinito e enumerável, sendo possível<br>
representar infinitos e enumerável conjunto de proposições.<br>
• Conectivos proposicionais: São os símbolos usando frequentemente na matemática. Os<br>
símbolos recebem a seguinte denominação:<br>
1. ¬: Representa a partícula de negação, ou seja, "Não".<br>
2. ?: Representa a partícula "Ou"<br>
3. ?: Representa a partícula "E"<br>
4. ?: Representa a partícula "Se então ou implica".<br>
5. ?: Representa a partícula "Se, e somente se".<br>
Ainda segundo SOUZA, existem as fórmulas que são constituídas de forma indutiva, a<br>
partir de símbolos do alfabeto conforme as regras apresentadas abaixo:<br>
• Todo o símbolo preposicional é uma fórmula<br>
• Se H é uma fórmula, então (¬H), a negação de H, é uma fórmula.<br>
• Se H e G são fórmulas, então a disjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a conjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o antecedente e G consequente da fórmula.<br>
• Se H e G são fórmulas, então a bi-implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o lado esquerdo e G o lado direito da fórmula.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 26<br>
2.2.8 Linguagem de especificação de propriedades<br>
Linguagem de especificação de propriedades, do inglês Property Specification Language<br>
- PSL, é uma notação formal para especificação de comportamento em sistemas eletrônicos,<br>
compatível com as linguagens VHDL, Verilog, SystemC e SystemVerilog. Destina-se a utilização Adicionar<br>
refer-<br>
ência<br>
a cada<br>
Ling<br>
citada<br>
para a especificação funcional, mas também para entrada <span class='f1 c_58' id='c_58_1' href='#c_58_2' cs_f='.c_58' >de ferramentas de</span> verificação. A<br>
especificação do PSL é a utilização de assertivas sobre propriedades de um sistema, sendo estas<br>
propriedades constituídas de três elementos: expressões boolenas, expressões sequenciais e<br>
operadores temporais (IEEE. . . , 2010).<br>
Corrigir a apresentação da citação IEEE... estranho<br>
Segundo (IEEE. . . , 2010), o PSL foi totalmente desenvolvida com o intuito fornecer<br>
leitura e escrita de fácil entendimento, sintaxe concisa, semântica formal e rigorosamente bem<br>
definida e ser matematicamente precisa, visto a utilização da mesma em processo de verificação.<br>
O PSL pode ser utilizado para capturar requisitos relativos ao comportamento total do projeto,<br>
bem como, sobre o modo que o mesmo deverá operar no ambiente, ms também para capturar<br>
requisitos comportamentais e os pressupostos que surgem durante <span class='f1 c_57' id='c_57_1' href='#c_57_2' cs_f='.c_57' >o processo de design</span>. Ambas<br>
podem ser utilizadas para verificação de sistemas.<br>
Apresentar exemplos de uso da PSL<br>
2.2.9 Verificação baseada em assertivas<br>
Verificação baseada em assertivas, do inglês Assertion-Based Verification - ABV, é um<br>
paradigma de verificação igualente adequado para verificação formal e <span class='f1 c_14' id='c_14_1' href='#c_14_2' cs_f='.c_14' >abordagens baseadas em</span><br>
simulação (BOULE; ZILIC, 2005) e em conjunto com a tecnica de PSL tem ganhado aceitação<br>
como um método essencial para verificação funcional do hardware (DAHAN et al., 2005).<br>
Na ABV as assertivas são declaração adicionadas ao projeto com o intuito de especificar<br>
o comportamento do projeto (BOULE; ZILIC, 2005), podendo escritos em PSL ou em SVA<br>
(System Verilog Assertions). No caso deste projeto será utilizado a PSL, devido a mesma ser<br>
utilizada juntamente com a linguagem VHDL.<br>
Com a utilização de ABV o circuito pode ser verificado usando técnicas de simulação<br>
e/ou verificação, por exemplo, model checking, para garantir que o mesmo esteja de acordo<br>
com o pretendido projeto (DAHAN et al., 2005). Na Figura 19 apresenta <span class='f1 c_54' id='c_54_1' href='#c_54_2' cs_f='.c_54' >o modelo de</span> assertiva<br>
utilizada no projeto, utilizando de um modelo próprio para assertivas, unindo as funcionalidades<br>
já existentes nas assertivas do VHDL, mas também novas (serão apresentadas nas próximas<br>
seções), fornecendo assim mais propriedades a serem analisadas.<br>
Descrever qual o objetivo da assert apresentado<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 27<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 e n t i t y AND_ent i s<br>
5 p o r t ( x , y : i n b i t ;<br>
6 F : o u t b i t<br>
7 ) ;<br>
8 end AND_ent ;<br>
9<br>
10 a r c h i t e c t u r e behav1 of AND_ent i s<br>
11 b e g i n<br>
12 ??@c2vhdl : ASSERT<br>
13 ??a s s e r t n o t ( x= ’ 0 ’ and y= ’ 1 ’ )<br>
14 ?? r e p o r t " Both v a l u e s o f s i g n a l s x and y a r e e q u a l t o 1 "<br>
15 ??s e v e r i t y ERROR;<br>
16 ??@c2vhdl :END<br>
17<br>
18 p r o c e s s ( x , y )<br>
19 b e g i n<br>
20 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
21 F &lt;= ’ 1 ’ ;<br>
22 e l s e<br>
23 F &lt;= ’ 0 ’ ;<br>
24 end i f ;<br>
25 end p r o c e s s ; 4<br>
26 end behav1 ;<br>
Fonte: Própria.<br>
2.2.10 Propriedades de segurança<br>
Propriedades de segurança é um meio de validação do comportamento de um determinado<br>
sistema, de modo que se uma dada propriedade de segurança for violada, então através de<br>
uma execução finita, é possível verificar tal erro. Algumas propriedades de segurança, no<br>
entanto, podem impor requisitos em fragmentos de caminho finito e não podem ser verificadas<br>
considerando apenas os estados alcançáveis. (BAIER et al., 2008).<br>
Segundo (CLARKE et al., 2003), podemos definir uma propriedade de segurança como:<br>
dado um sistema de transições ST = (S, S0, E), seja um conjunto B ? S que especifica <span class='f1 c_45' id='c_45_1' href='#c_45_2' cs_f='.c_45' >um<br>
conjunto de</span> maus estados tais que S0 ?B = ?, pode-se dizer que ST é seguro com relação a B,<br>
denotado por ST |= AG¬B se não existe um caminho no sistema de transição do estado inicial<br>
S0 até o estado B, de outro modo é dito que ST não é seguro.<br>
Adicionar exemplos de propriedades de segurança em hardware<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 28<br>
2.3 Técnicas de compiladores<br>
Compiladores são sistemas de software utilizados para tradução de <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >uma linguagem de</span><br>
programação para outra, ou seja, o programa da linguagem fonte é lido e traduzido para um<br>
código equivalente na outra linguagem, ou linguagem alvo. Geralmente utilizada para transformar<br>
trechos de código em uma linguagem a ser executada pelo computador (AHO et al., 2007).<br>
Diversas técnicas podem ser utilizadas nas diversas etapas, até que o código seja traduzido,<br>
tais como LL(1) e LR na análise sintática; eliminação de código morto; propagação de constante<br>
e Peephole na otimização de código(AHO et al., 2007). Neste projeto serão focados as áreas de<br>
transformações de código e otimização de código.<br>
2.3.1 Transformações de código<br>
Transformações de código correspondem a uma complexa função que envolve analise <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >de<br>
fluxo de dados</span> e modificação completa do programa que são parte integral da alta performance e<br>
sistemas computacionais. Podem ser classificados em transformações escalares que reduzem<br>
o número de instruções a serem executadas no programa ou transformações paralelas que<br>
maximizam o paralelismo (SRIKANT; SHANKAR, 2002).<br>
A Figura 11 representa o trecho de código apresentado na Figura 19. O trecho representa<br>
o comportamento das entradas, neste caso de um código da porta AND. E a figura Figura 12<br>
representa a tradução deste trecho em código na linguagem C. Esta tradução foi realizada pela<br>
ferramenta V2C, utilizada neste projeto. Adicionar<br>
refer-<br>
ência<br>
Figure 11 – Trecho de código em VHDL representando porta AND.<br>
1 p r o c e s s ( x , y )<br>
2 b e g i n<br>
3 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
4 F &lt;= ’ 1 ’ ;<br>
5 e l s e<br>
6 F &lt;= ’ 0 ’ ;<br>
7 end i f ;<br>
8 end p r o c e s s ;<br>
Fonte: Própria.<br>
Expandir esta seção. Apresentar propriedades de transformação e técnicas para avaliar a<br>
transformação<br>
2.3.2 Otimização de código<br>
A otimização de código consiste na melhoria do código intermediário gerado pelos<br>
algoritmos de compilação <span class='f1 c_70' id='c_70_1' href='#c_70_2' cs_f='.c_70' >com o objetivo</span> de obter um menor tempo de execução do programa,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 29<br>
Figure 12 – Trecho de código traduzido para linguagem C.<br>
1 /? S t a r t o f T r a n s l a t i o n ? /<br>
2 /? p0 : ? /<br>
3 i f ( chg [ x ] | | chg [ y ] ) {<br>
4 i f ( ( ( o l d [ x ]==1) && ( o l d [ y ]==1) ) ) {<br>
5 new [ f ] = 1 ;<br>
6 }<br>
7 e l s e {<br>
8 new [ f ] = 0 ;<br>
9 }<br>
10 }<br>
11 /? End o f T r a n s l a t i o n ? /<br>
Fonte: Própria.<br>
porém outros fatores podem ser introduzidos, como algoritmos menores. Este fato não implica<br>
em afirmar que o melhor código é gerado, visto que dada a complexidade, raramente pode ser<br>
obtido que o código gerado pode ser o melhor possível (AHO et al., 2007).<br>
Segundo AHO et al., otimização local de código consiste na otimização de um bloco<br>
básico de código, ou seja, a otimização ocorre em um trecho especifico de código. Os blocos<br>
básicos são trecho onde não ocorrem saltos ou loops, para nenhuma outra parte do código. A<br>
otimização global de código é baseado na analise do <span class='f1 c_74' id='c_74_1' href='#c_74_2' cs_f='.c_74' >fluxo de dados, de</span> modo que ocorra as<br>
elminação de instruções não necessárias ou substituição mais facil. A otimização global consite<br>
na analise completa do código. Neste sentido, nas próximas seções serão apresentadas algumas<br>
importantes técnicas de otimizações.<br>
2.3.2.1 Grafo Acliclico Direcional - GAD<br>
Grafo Aciclico Direcional é utilizado para diversos fins dentro da estrutura de compi-<br>
ladores, principalmente para geração da parse tree otimização de código. Pode ser usado na<br>
representação de instruções unicas blocos básicos de código(AHO et al., 2007). O uso de GAD<br>
permite a melhoria de de código, tais como:<br>
• Elminação de subexpressões locais comuns, ou seja, expressões que o valor já foi com-<br>
putado anteriomente;<br>
• Eliminação de código morto;<br>
• Reordernamento de declarações buscando reduzir o tempo que o valor temporário necessita<br>
ser preservado em um registro;<br>
A Figura 13 apresenta um bloco básico com algumas instruções, no caso apresentando<br>
são 4 operações entre somas e multiplicação e a partir deste bloco a Figura 14 apresenta o GDA<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 30<br>
Figure 13 – Exemplo de bloco basico de código.<br>
1 a = b + c<br>
2 b = a ? d<br>
3 c = b + c<br>
4 d = a ? d<br>
Fonte: (AHO et al., 2007)<br>
Figure 14 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
deste trecho de código. Nele apresenta cada nó como uma operação especifica e os terminais<br>
como as parcelas das operações.<br>
2.3.2.2 Grafo <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >de Fluxo de</span> Controle - GFC<br>
Grafo <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >de fluxo de</span> controle corresponde a um grafo direcionado, no qual cada nó rep-<br>
resenta blocos básicos e cada aresta representa os caminhos de fluxo entre os blocos basi-<br>
cos (ALLEN, 1970). É importante ressaltar que saltos determinam o final de um determinado<br>
bloco básico, ou seja, saltos indicam um caminho para uma nova região de código básico (AHO<br>
et al., 2007).<br>
Apresentar um exemplo de como e utilizado em código<br>
2.3.2.3 Eliminção de código morto<br>
A eliminacação de código morto é uma técnica que busca a eficiência de um programa<br>
evitando a execução de instruções não necessária em tempo de execução (KNOOP et al., 1994).<br>
O código morto consiste em instruções que não serão alcançáveis durante o fluxo do programa,<br>
sendo esta técnica basicamente a retirada de qualquer variável que não será utilizada em qualquer<br>
outro nó do grafo (AHO et al., 2007).<br>
A utilização de GAD corresponde na eliminação de qualquer nó raiz, ou seja, nó sem<br>
ancestrais, as quais não esteja ativa anexada a mesma. A execução repetida desta operação<br>
removerá todos os nós correspondentes a código morto (AHO et al., 2007).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 31<br>
Figure 15 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
Na Figura 15, supondo que os nós a, b e c estejam ativa, porém o nó énão esteja, o último Corrigir<br>
nó é?pode ser eliminado imediatamente. Os nós restantes continuam no GDA, a menos que não tenho<br>
variáveis ativas atreladas aos nós (AHO et al., 2007).<br>
2.3.2.4 Análise do <span class='f1 c_74' id='c_74_1' href='#c_74_2' cs_f='.c_74' >fluxo de dados</span><br>
Análise <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >de fluxo de dados</span> refere-se ao conjunto de técnicas que derivam informações<br>
sobre <span class='f1 c_9' id='c_9_1' href='#c_9_2' cs_f='.c_9' >o fluxo de dados</span> <span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >ao longo dos</span> caminhos de execução do programa. Para análise do<br>
programa, é necessário considerar todas as posiveis execuções através do grafo <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >de fluxo de</span><br>
controle (AHO et al., 2007).<br>
Apresentar exemplos<br>
2.3.2.5 Gerador de código<br>
O gerador de código é responsavél pela tradução final do programa-fonte para o programa-<br>
alvo, o mesmo recebe como entrada um código intermediário juntamente com a tabela de<br>
símbolos. Faz-se necessário que o programa-fonte tenha sido analisado sintatica e lexicamente,<br>
assim evitando que erros possam ser passados para o programa-alvo, <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >por outro lado</span> a existência<br>
de uma nível de otimização, faz-se opicional neste caso (AHO et al., 2007).<br>
O gerador de código possui três tarefas primarias, sendo as mesmas seleção de instrução,<br>
alocação de registros e atribuições. A seleção de instruções envolve a escolha das instruções<br>
apropriadas da máquina-alvo para implementar as declarações do código intermediario. A<br>
atribuição e atribuição de registros envolve a decisão sobre os valores a serem registrados nos<br>
registros(AHO et al., 2007).<br>
Apresentar exemplo<br>
32<br>
3 TRABALHOS CORRELATOS<br>
Sugiro apenas mencionar que foi feito a revisão sistemática; o que já foi feito e os resul-<br>
tados. As outras seções sobre RS e mover para apêndice.<br>
3.1 Revisão sistemática<br>
A revisão sistemática consiste é um método de identificação, análise e interpretação de<br>
pesquisas relevantes em determinada área ou questão de pesquisa. Para execução da revisão sis-<br>
temática se requer um esforço maior, em comparação as pesquisas tradicionais, sendo necessário<br>
seguir uma sequência de passos metodológicos sobre a área ou questão de pesquisa ao qual<br>
deseja ser feita a pesquisa (KITCHENHAM, 2004).<br>
Para a execução da revisão sistemática, é necessário um esforço considerável, se com-<br>
parado a uma revisão informal a literatura. Enquanto que a revisão de literatura informal é<br>
conduzida de forma ad-hoc, sem planejamento e critérios de seleção estabelecidos a priori,<br>
a revisão sistemática requer um protocolo formal bem definido, com uma sequência de pas-<br>
sos metodológicos, para conduzir uma pesquisa sobre o tema ao qual deseja-se realizar a<br>
pesquisa (MAFRA; TRAVASSOS, 2006).<br>
A aplicação da revisão sistemática requer que seja seguido um conjunto bem definido e<br>
sequêncial de passos, seguindo um protocolo de pesquisa desenvolvido previamente. Através<br>
deste método é possível realizar uma extensa pesquisa, contemplando uma grande quantidade<br>
de informações sobre o assunto pesquisado (MAFRA; TRAVASSOS, 2006). Este protocolo é<br>
construído considerando um tema específico que representa o elemento central da investigação,<br>
onde os passos da pesquisa, as estratégias definidas para coletar as evidências e o foco das<br>
questões de pesquisa são definidas explicitamente, de tal forma que outros pesquisadores sejam<br>
capazes de reproduzir o mesmo protocolo de pesquisa (BIOLCHINI et al., 2005).<br>
Segundo MAFRA; TRAVASSOS, o processo para a condução de revisões sistemáticas<br>
envolve três etapas:<br>
1. Planejamento da Revisão: os objetivos da pesquisa são listados e o protocolo da revisão<br>
é definido.<br>
2. Condução da Revisão:nesta atividade, as fontes para a revisão sistemática são sele-<br>
cionadas, os estudos primários são identificados, selecionados e avaliados de acordo com<br>
os critérios de inclusão, exclusão, e de qualidade estabelecidos durante o protocolo da<br>
revisão.<br>
Chapter 3. TRABALHOS CORRELATOS 33<br>
3. Análise dos Resultados: os dados dos estudos são extraídos e sintetizados para análise e<br>
apresentação dos resultados.<br>
Vale ressaltar que como o objetivo deste trabalho é realizar um estudo exploratório de<br>
caracterização de área podemos dizer que esta revisão sistemática se caracteriza como uma quasi-<br>
sistemática (TRAVASSOS et al., 2008), pois segue o mesmo processo da revisão sistemática e<br>
preserva o rigor e mesmo formalismo para as fases metodológicas de elaboração de protocolo e<br>
execução da revisão, mas sem a aplicação de uma meta-análise a princípio, que pode ser aplicada<br>
posteriormente.<br>
3.1.1 Planejamento da Revisão Sistemática<br>
Objetivo: Este estudo tem o objetivo esquematizado a partir da estrutura do paradigma<br>
GQM (do ingles Goal,Question and Metric)(BASILI et al., 1994).<br>
Analisar Publicações científicas através de um estudo baseado em revisão sis-<br>
temática<br>
Com propósito de Identifica-las<br>
Com relação as Vantagens e desvantagens da utilização de assertiva e transformações<br>
de código na verificação do código <span class='f1 c_56' id='c_56_1' href='#c_56_2' cs_f='.c_56' >na linguagem de</span> descrição VHDL<br>
Do ponto de vista do Pesquisador<br>
No contexto Acadêmico ou industrial para verificação de assertivas <span class='f1 c_56' id='c_56_1' href='#c_56_2' cs_f='.c_56' >na linguagem<br>
de</span> descrição VHDL<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM<br>
Formulação da Pergunta: Buscamos respostas para as seguintes perguntas:<br>
• Q1: Quais são os métodos para verificação de circuitos lógicos descritos <span class='f1 c_56' id='c_56_1' href='#c_56_2' cs_f='.c_56' >na linguagem de</span><br>
programação VHDL?<br>
– Q1.1: Foi desenvolvido e está disponível alguma ferramenta para aplicação do<br>
método?<br>
– Q1.2: Qual a técnica de exploração de estados para circuitos lógicos?<br>
– Q1.3: O método proposto é baseado em técnicas de verificação de software?<br>
– Q1.4: Como o método proposto valida pré e pós condições no programa?<br>
– Q1.3: Foi utilizado algum benchmark de programas em VHDL para experimentação<br>
e o mesmo encontra-se disponível?<br>
– Q1.4: Quais as perspectivas futuras para melhorar da aplicação do método proposto?<br>
Escopo da pesquisa:Na delimitação do escopo da pesquisa foram estabelecidos critérios,<br>
buscando garantir a viabilidade da execução, acessibilidade dos dados e abrangência do estudo re-<br>
alizado. A pesquisa dar-se-á a partir de bibliotecas digitais através das suas respectivas máquinas<br>
Chapter 3. TRABALHOS CORRELATOS 34<br>
de busca e, quando os dados não estiverem disponíveis eletronicamente, através de consultas<br>
manuais.<br>
Critérios de Seleção de Fontes. Para as bibliotecas digitais é desejado:<br>
• Possuir uma máquina de busca que permita o uso de expressões lógicas ou mecanismo<br>
equivalente.<br>
• Incluir em sua base, publicações de exatas ou correlatas que possuam relação direta com o<br>
tema a ser pesquisado<br>
• As máquinas de busca deverão permitir a busca no texto completo das publicações.<br>
Segundo ROCHA et al., os mecanismos de busca utilizados devem garantir resultados<br>
únicos através da busca de um mesmo conjunto de palavras-chaves (string de busca). Quando<br>
isto não for possível, deve-se estudar e documentar <span class='f1 c_1' id='c_1_1' href='#c_1_2' cs_f='.c_1' >uma forma de</span> minimizar os potenciais efeitos<br>
colaterais desta limitação.<br>
Métodos de Busca das Publicações. As fontes digitais foram acessadas via Web, através<br>
de expressões de busca pré-estabelecidas. A biblioteca digital consultada foi a Scopus, acessível<br>
em http://www.scopus.com. Segundo a editora ELSEVIER, a Scopus é uma das maiores bases<br>
<span class='f1 c_71' id='c_71_1' href='#c_71_2' cs_f='.c_71' >de dados de</span> resumos e citações da literatura de pesquisa peer-reviewed com mais de 22, 800<br>
títulos de mais de 5, 000 editoras internacionais abrangendo as áreas de tecnologia, medicina,<br>
artes, ciências sócias e com atualizações diárias. Entre as editoras podemos citar: Springer<br>
(SPRINGER, 2018); IEEE Xplore Digital Library (IEEE, 2018);ACM Digital Library (ACM,<br>
2018) ; ScienceDirect/Elsevier (B.V, 2018); Wiley Online Library (SONS, 2018); dentre outras.<br>
String de Busca. A string de busca foi definida segundo o padrão PICO (do inglês<br>
Population, Intervention, Comparison, Outcomes) (KITCHENHAM et al., 2009), conforme a<br>
estrutura abaixo:<br>
• População: Trabalhos publicados em conferências e periódicos que relacionam verificação<br>
de propriedades de circuitos lógicos em códigos para a descrição de hardware.<br>
• Intervenção: Verificação de propriedades relacionadas a verificação de circuitos para as<br>
diferentes estruturas das linguagens de descrição de hardware;<br>
• Comparação: análise de cobertura e suporte das abordagens identificadas para a verificação<br>
de propriedades das linguagens de descrição de hardware;<br>
• Resultados: a partir da descrição das abordagens pretende-se verificar a cobertura que cada<br>
abordagem apresenta na manipulação das diferentes estruturas da linguagem de descrição<br>
de hardware para a verificação de propriedades baseada em assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 35<br>
Segundo ROCHA et al., como este estudo representa um estudo de mapeamento/caracteri-<br>
zação, a string de busca foi definida de acordo com dois aspectos: População e Intervenção, como<br>
é apresentado na estrutura abaixo. Posteriormente esta mesma string de busca será executada<br>
na biblioteca Scopus para busca de artigos e publicações de modo a gerar uma interseção entre<br>
população e intervenção.<br>
• População: publicações que fazem referência a verificação de propriedades de circuitos<br>
lógicos e sinônimos:<br>
– Palavras-chaves: "circuit checker" OR "circuit verification" OR "contract based<br>
verification" OR "code analysis" OR "static analysis" OR "dynamic analysis" OR<br>
"safety verification" OR "RTL analysis" OR "program analysis" OR "property veri-<br>
fication" OR "formal verification" OR "model checking" OR "model checker" OR<br>
"hardware checker" OR "hardware verification" OR "validity checker" OR "hard-<br>
ware assertion" OR "assertion checker" OR "assert verification" OR "assertion-based<br>
verification" OR "assertion based verification" OR "assertion-based design" OR "bit<br>
level verification"<br>
• Intervenção: Verificação de circuitos e sinônimos:<br>
– Palavras-chaves:"hardware statement" OR "hardware code" OR "hardware source<br>
code" OR "hardware semantics" OR "hardware property" OR "logical gates" OR<br>
"sequential circuit" OR "parallel circuit" OR "real circuits" OR "complex circuits"<br>
OR "control circuitry" OR ”software netlist” OR “hardware emulation” OR “silicon<br>
debug”<br>
3.1.1.1 Procedimentos de Seleção e Critérios<br>
A estratégia de busca será aplicada por um pesquisador para identificar as publicações<br>
em potencial. A seleção das publicações dar-se-á em 2 etapas, conforme apresentado a seguir.<br>
1. Seleção e catalogação preliminar dos dados coletados: A seleção preliminar das publi-<br>
cações será feita a partir da aplicação da string de busca na biblioteca Scopus, o resultado<br>
desta busca corresponde a seleção preliminar. Todas as publicações serão armazenadas<br>
para análise posterior;<br>
2. Seleção dos dados relevantes - [1 filtro]: A seleção preliminar com o uso da expressão<br>
de busca não garante que todo o material coletado seja útil no contexto da pesquisa, pois a<br>
aplicação das expressões de busca é restrita ao aspecto sintático. Por isso, é necessário a<br>
criação de filtros de exclusão e inclusão, de modo a classificar os artigos e publicações que<br>
se enquadram no contexto da pesquisa realizada. Nesta epata apenas serão lidos o título,<br>
abstracts, e palavras-chaves e classificar de acordo com os filtros, ou seja, se será aceito ou<br>
excluído. Devem ser excluídas as publicações contidas no conjunto preliminar que:<br>
Chapter 3. TRABALHOS CORRELATOS 36<br>
• CE1-01: Não serão selecionadas publicações em que as palavras-chave da busca<br>
não apareçam no título, resumo e/ou texto da publicação (excluem-se os seguintes<br>
campos: as seções de agradecimentos, biografia dos autores, referências bibliográficas<br>
e anexas).<br>
• CE1-02: Não serão selecionadas publicações em que descrevam e/ou apresentam<br>
‘keynote speeches’, tutoriais, cursos e similares.<br>
• CE1-03: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação/validação de códigos para descrição de hardware.<br>
• CE1-04: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação de código de descrição de hardware baseado em assertivas ou propriedades<br>
de verificação de hardware.<br>
Podem ser incluídas apenas as publicações contidas no conjunto preliminar que:<br>
• CI1-01:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita uma abordagem para verificação<br>
de código de descrição de hardware baseado em assertivas ou propriedades de<br>
verificação de hardware.<br>
• CI1-02:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita recomendações de melhoria<br>
na utilização de abordagens para verificação de código de descrição de hardware<br>
baseado em assertivas ou propriedades de verificação de hardware.<br>
3. Seleção dos dados relevantes - [2 filtro]: Apesar do 1o filtro limitar o universo de busca,<br>
infelizmente não há garantias de que todo material selecionado no filtro anterior seja útil<br>
no contexto da pesquisa. Neste caso, novos filtros são gerados, buscando, da mesma forma<br>
que o primeiro filtro, classificar os artigos e publicações que se enquadram no contexto<br>
da pesquisa. Para este filtro é necessário a leitura na integras dos artigos selecionados<br>
anteriormente. O objetivo é identificar que relacionam assertivas e/ou propriedade de<br>
verificação de hardware.<br>
• CS2 -ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação <span class='f1 c_59' id='c_59_1' href='#c_59_2' cs_f='.c_59' >de hardware e</span> não citam assertivas<br>
• CS2 +ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware, mas citam assertivas<br>
• CS2 -ASS +VER_HARD: Não devem ser selecionadas publicações que contextual-<br>
izam verificação de hardware, mas citam assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 37<br>
Dessa forma, todas as publicações devem respeitar o critério abaixo:<br>
• CS3 +ASS +VER_HARD: Serão selecionadas publicações que contextualizam<br>
verificação <span class='f1 c_59' id='c_59_1' href='#c_59_2' cs_f='.c_59' >de hardware e</span> citam assertivas em seu contexto.<br>
Devido ao tempo necessário <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento</span> execução dos filtros da revisão<br>
sistemática serem extensos, apenas o primeiro filtro foi executado neste projeto, mesmo que<br>
os parâmetros para o segundo filtro já tenho sido desenvolvidos. Em contra partida foram<br>
selecionados 6 artigos que serviram como ferramentas de estudo <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento</span> da<br>
metodologia que será apesentada no Capítulo 4.<br>
3.2 Revisão da literatura<br>
Nesta sessão serão apresentados trabalho relevantes <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento</span> do método<br>
proposto que foram identificados utlizando a revisão sistemática mencionado anteriormente.<br>
Os artigos apresentam técnicas de transformações de código, utilização de Assertion-Based<br>
Verification e PSL para verificação de hardware.<br>
3.2.1 V2c-A verilog to C translator<br>
O artigo de MUKHERJEE et al. apresenta uma ferramenta implementada em C++<br>
chamada v2c para transformação de código da linguagem de descrição Verilog para linguagem<br>
de programação C. A ferramenta é executada a nível de palavra, visto que esta abordagem garante<br>
uma aumento na escalabilidade, mas também proporionando que técnicas, como interpolaçãoe adicionar<br>
refer-<br>
ência<br>
aceleração de looppossam ser utilizadas para verificação, algo inviavél, caso a tradução fosse<br>
adicionar<br>
refer-<br>
ência<br>
executada a nível de bit. O sistema recebe como entrada um código em Verilg, onde são aplicadas<br>
regras semânticas e mapeando os bit de operação, chamado software netlist. Após isso, o código<br>
intermediário é convertido para C.<br>
A contribuição deste trabalhoconsiste na utilização de transformações de código como<br>
Qual<br>
tra-<br>
balho?<br>
base principal e partindo deste pressuposto torna-se vantajoso devido a utilização de outras<br>
ferramentas que não apresente suporte a certas linguagens, tais com a ferramenta ESBMC,<br>
utilizada neste trabalho, não apresenta suporte a VHDL, porém apresenta suporte as linguagens<br>
C/C++. Em outras palavras, a contribuição deste trabalhofoi a utilização de traduções de códigos<br>
Qual<br>
tra-<br>
balho?<br>
e utilizado este conceito como modelo de entrada para analise de circuitos.<br>
3.2.2 Unbounded safety verification for hardware using software ana-<br>
lyzers<br>
No artigo de MUKHERJEE et al. foi apresentado uma metodologia que aborda a utiliza-<br>
ção de técnicas e analisadores de software, <span class='f1 c_70' id='c_70_1' href='#c_70_2' cs_f='.c_70' >com o objetivo</span> de de abordar a análise de circuitos e<br>
Chapter 3. TRABALHOS CORRELATOS 38<br>
com isso trançar um paralelo entre as abordagens. Para testes foram utilizadas três metodologias<br>
de análise, usando interpolação, k-inductione tecnologias hibrídas. Como resultante dos testes, foi adicionar<br>
refer-<br>
ência<br>
adicionar<br>
refer-<br>
ência<br>
observado as principais causas de erros, por exemplo, bits não preciso e no caso das operações<br>
a bit-level ocorria perda de informações. Também foi obeservado que apesar de não serem<br>
otimizadas para análises de hardware, alguns analisadores de softaware podem, dependendo da<br>
técnica utilizada no analisador, ser utilizada para analise de hardware.<br>
Descrever<br>
qual<br>
o mo-<br>
tivo.<br>
A utilização de técnicas de análise de software <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento de</span> análise de<br>
hardware é o foco a ser abordado neste neste trabalho de maneira prática, utilizando os princípio<br>
analisados por (MUKHERJEE et al., 2016a). Neste contexto, o objetivo deste trabalho é a<br>
utilização de técnicas de software para análise de circuitos, diferente do artigo apresentado acima<br>
que busca utilização uma abordagem mais complexa provando a possibilidade da utilização de<br>
técnicas de analise de software no contexto da verificação <span class='f1 c_64' id='c_64_1' href='#c_64_2' cs_f='.c_64' >de hardware.<br>
A</span> última frase está confusa, no meu entedimento é o mesmo sentido.<br>
3.2.3 Formal verification of timed VHDL programs<br>
No trabalho apresentado por BARA et al. é proposto uma abordagem para a análise<br>
de tempo relacionado a cada porta lógica dentro de um dado circuito analisado. A abordagem<br>
apresenta a tradução de um circuito lógico codificado em VHDL para um formalismo baseado<br>
em automato de tempo. Tal formalismo é representado por uma automato de estados finitos referência<br>
com relogios simbólicos que evoluem em taxa uniforme. A tradução é executada de modo<br>
automatico, baseado na emulação da propagação de cada transação ao longo de cada sinal, o<br>
seja, são automatos programados e cronometrados do circuito. Após a tradução para automato, a<br>
analise é feita pela ferramenta UPPALque é um model checking de verificação de propriedades referência<br>
de tempo. Seguindo esta metodologia a análise pode ser extraida de modo independente de cada<br>
bloco, desta forma a análise é feita de forma mais precisa, podendo ser analisado inumeros<br>
fatores, tais como limites de intervalo e sinal de correlação.<br>
O artigo apresenta uma abordagem de tempo, que torna-se interessante adição ao método.<br>
Porém até o momento a função não foi implementada ficando a trabalho futuros.<br>
Expandir o texto acima, exemplo, descrever como o método poderia ser incluindo no seu<br>
TCC.<br>
3.2.4 On the use of assertions for embedded-software dynamic verifica-<br>
tion<br>
Em GUGLIELMO et al. é apresentado uma metodologia para a integração dinamica de<br>
Assertion-Based Verification para várias fases da análise da verificação de fluxo em sistemas<br>
embarcados, por exemplo, emulação, diagnosticos e Debug, mas também um ferramenta chamada<br>
Chapter 3. TRABALHOS CORRELATOS 39<br>
RadCheck. O metodo de aplicação, chamado V-model é dividido em fases de verificação em<br>
paralelo com as fases de <span class='f1 c_42' id='c_42_1' href='#c_42_2' cs_f='.c_42' >design do circuito</span>. Com base no V-model, o método é aplicado, iniciando<br>
com o nível de sistema e as especificação do sistema, neste caso especificado usando PSL.<br>
Neste nível é especificado todas as funcionalidades gerais da aplicação. No nível de integração<br>
visa investigar problemas de interação que possam ocorrer, definindo propriedades que cobrem<br>
incrementalmente as unidades estruturais interativas de aplicação. No nível de unidade descrevem<br>
comportamentos internos e são definidas através de parâmetros de entrada/saída das unidade e<br>
estruturas de dados internas.<br>
A contribuição deste projeto está relacionado a utilização de assertivas no contexto da<br>
verificação de software. As assertivas são o principal meio de análise proposto neste projeto,<br>
visto que estas mesma assertivas serão analisadas pelo ESBMC. Aliado a isso em GUGLIELMO<br>
et al. é apresentado modelos de utilização de assertivas no processo de verificação <span class='f1 c_59' id='c_59_1' href='#c_59_2' cs_f='.c_59' >de hardware,<br>
e</span> tais assertivas foram adaptadas para um modelo proposto neste trabalho.<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation<br>
No trabalho de BOULE; ZILIC é apresentado uma ferramenta de geração de assertivas<br>
no contexto da emulação de circuitos, de modo que estas assertivas descrita em PSL possam<br>
transformadas <span class='f1 c_2' id='c_2_1' href='#c_2_2' cs_f='.c_2' >para o modelo de linguagem de</span> descrição de hardware. Inicialmente é realizada<br>
toda análise de cada assertiva e a mesma é traduzida em partes, levando em consideração os<br>
operadores e cada estrutura, por exemplo if-else, utilizado na declaração da assertiva.<br>
Apresentar um exemplo para explicar o texto acima<br>
trabalho de BOULE; ZILIC consolida e apresenta aspectos importantes, tais como a<br>
utilização de uma ferramenta para geração de assertivas, o que torna-se no contexto deste projeto,<br>
extremamente importante, visto que o modelo adotado atualmente consiste tanto na geração<br>
automática das assertivas, bem como a inserção manual <span class='f1 c_73' id='c_73_1' href='#c_73_2' cs_f='.c_73' >por parte do</span> usuário.<br>
40<br>
4 MÉTODO PROPOSTO<br>
Este Capítulo descreve o método proposto neste trabalho, baseado transformações de<br>
código para análise de circuitos lógicos descritos em VHDL utilizando Bounded Model Checking,<br>
neste caso o model checker ESBMC.<br>
4.1 Visão geral do método<br>
O método proposto consiste inicialmente em receber como entrada um circuito lógico<br>
descrito em VHDL, onde uma dada propriedade representada em uma assertiva será analisada,<br>
as assertivas serão inseridas de automaticamente pelo método ou pelo próprio usuário do método.<br>
O código VHDL analisado posteriomente é traduzido para linguagem C e recebe uma instrumen-<br>
tação de código (com funções especificas suportadas pelo método) para a posterior validação do<br>
mesmo. O Código em C automaticamente gerado, já instrumentado, será processado e analisado<br>
pelo ESBMC de acordo com as assertivas inseridas e ao final é apresentado o resultado. Caso<br>
alguma das assertivas seja violada, um contra-exemplo é apresentado ao usuário. Uma visão<br>
geral do método proposto é apresentado na Figura 16 e nas sessões a seguir serão apresentados<br>
cada etapa do método proposto neste trabalho.<br>
Figure 16 – Ciclo da ferramenta<br>
Fonte: Própria<br>
Com o intuito de auxiliar nas explicações apresentadas nas próximas sessões, o código<br>
na Figura 17 será utilizado nas explanações, bem como será apresentado todas as alterações do<br>
mesmo, conforme cada etapa do método.<br>
Chapter 4. MÉTODO PROPOSTO 41<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 ENTITY U l a _ t c c IS<br>
5 PORT(A, B , B i n v e r t i d o , Op1 , Op2 : IN BIT ;<br>
6 R e s u l t a d o :OUT BIT ) ;<br>
7 END U l a _ t c c ;<br>
8<br>
9 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
10 SIGNAL a n d _ p o r t : b i t ;<br>
11 SIGNAL o r _ p o r t : b i t ;<br>
12 SIGNAL x o r _ p o r t : b i t ;<br>
13 SIGNAL mux2x1 : b i t ;<br>
14 BEGIN<br>
15 PROCESS(A, B , B i n v e r t i d o , Op1 )<br>
16 BEGIN<br>
17 ??PORTA AND<br>
18 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
19 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
20 ELSE<br>
21 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
22 END IF ;<br>
23 ??PORTA OR<br>
24 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
25 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
26 ELSE<br>
27 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
28 END IF ;<br>
29 ??PORTA XOR<br>
30 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
31 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
32 ELSIF (A = ’ 1 ’ and mux2x1 = ’ 1 ’ ) THEN<br>
33 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
34 ELSE<br>
35 x o r _ p o r t &lt;= ’ 1 ’ ;<br>
36 END IF ;<br>
37 ??INVERSOR<br>
38 IF ( B i n v e r t i d o = ’ 0 ’ ) THEN<br>
39 mux2x1 &lt;= B ;<br>
40 ELSE<br>
41 mux2x1 &lt;= NOT B ;<br>
42 END IF ;<br>
43 ??MUX4X1<br>
44 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
45 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
46 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
47 R e s u l t a d o &lt;= o r _ p o r t ;<br>
48 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
49 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
50 END IF ;<br>
51 END PROCESS ;<br>
52 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 42<br>
4.2 Preprocessamento do VHDL e inserção de assertivas<br>
<span class='f1 c_52' id='c_52_1' href='#c_52_2' cs_f='.c_52' >A fase inicial do</span> método consiste no preprocessamento do código VHDL com as an-<br>
otações de código pelo usuário ou pelo método proposto de forma automática, incluindo as<br>
assertivas, conforme a Figura 16, na etapa A. O método não realiza qualquer tipo de verificação<br>
sobre o código VHDL, apenas utiliza o mesmo como entrada juntamente com as assertivas<br>
inseridas. Toda verificação é realizada sobre o código em linguagem C, que será traduzido a<br>
partir do código VHDL analisado, nas próximas etapas do método proposto. Vale ressaltar que<br>
mesmo a linguagem VHDL tendo <span class='f1 c_62' id='c_62_1' href='#c_62_2' cs_f='.c_62' >um modelo de</span> assertivas padrão, para o método tornou-se<br>
necessário a criação de um modelo (baseado em comentários) para que as funções do model<br>
checker adotado fossem suportadas, como a geração de valores não deterministicos.<br>
As assertivas manuais são adicionadas entre as tags @c2vhdl:ASSERT e @c2vhdl:END<br>
e todo trecho de código entre estas tags deve estar comentado, desta forma não apresentará<br>
erro na tradução do código em linguagem C, bem como na sintetização do código VHDL. Nas<br>
assertivas são incluidas as funções necessárias para a análise utilizando a ferramenta ESBMC. A<br>
assertiva apresenta três informações principais, sendo elas: condição, mensagem e gravidade.<br>
Ajustar está assertiva. Para quem não vê o código todo, ela não faz sentido<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR.<br>
1 ??@c2vhdl : ASSERT<br>
2 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ )<br>
3 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 "<br>
4 ??s e v e r i t y ERROR;<br>
5 ??@c2vhdl :END<br>
Fonte: Própria.<br>
A condição (na linha 2 da Figura 19) representa a assertiva propriamente dita e que será<br>
analisado pela aplicação. A condição será precedida de??assert e seguido ou não da palavra<br>
not, com isso a assertiva pode assumir valor negativo, conforme necessidade do usuário. Na<br>
Figura 19 a assertiva busca verificar se a variavél Resultado terá valor igual a 1. Qual a<br>
razão<br>
para<br>
isso,<br>
ex-<br>
plique!<br>
A mensagem (??report na linha 3 da Figura 19) é definida pelo usuário e será<br>
apresentado caso a assertiva apresente falha, assim a mensagem pode ser utilizada como um meio<br>
de depuração das propriedades validadas. A severidade (severity na linha 4 da Figura 19)<br>
pode ser definida como error, que representa um erro fatal e parada da verificação. A severidade<br>
do tipo warning que representa um erro não fatal, contabiliza as falhas das assertivas, porém<br>
não causa a parada da verificação. As mensagens futuramente pode ser integradas um framework<br>
para teste de unidade, contudo está é uma etapa ainda em planejamento neste trabalho.<br>
Juntamente com as assertivas outra função que pode ser utilizada é a função __ESBMC<br>
Chapter 4. MÉTODO PROPOSTO 43<br>
_assume() suportada pelo model checker ESBMC. Esta função utilizada em conjuto com a<br>
ferramenta ESBMC permite que durante a verificação uma variavél possa ter uma valor setado<br>
durante o tempo de execução da verificação. A importância desta função é fazer verificações onde<br>
se conhece os valores de entrada <span class='f1 c_79' id='c_79_1' href='#c_79_2' cs_f='.c_79' >juntamente com o</span> valor resultante, por exemplo, na verificação<br>
de portas lógicas.<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume().<br>
1 ??__ESBMC_assume (A = ’ 1 ’ )<br>
2 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
Fonte: Própria.<br>
A assertivas que serão verificadas são automáticas traduzidas <span class='f1 c_81' id='c_81_1' href='#c_81_2' cs_f='.c_81' >a partir das</span> entradas do<br>
código VHDL. Seja no modelo manual (assertivas escritas pelo usuário) ou automático (inferidas<br>
pelo método proposto <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >por meio de</span> análise estática), as entradas são mapeadas para serem<br>
utilizados na etapa de instrumentação. Desta forma, tais entradas podem ser utilizadas para gerar<br>
essas assertivas e então serem adicionadas diretamente ao código em linguagem C durante <span class='f1 c_44' id='c_44_1' href='#c_44_2' cs_f='.c_44' >a fase<br>
de</span> instrumentação.<br>
A Figura 20 apresenta o código juntamente com as assertivas conforme o padrão salien-<br>
tado na section 4.2. Neste exemplo foi implementado utilizado a inserção manual das assertivas<br>
e também da função __ESBMC_assume(), entretanto o objetivo é automatizar estas funções<br>
durante a execução da ferramenta.<br>
4.3 Tradução de código VHDL para a linguagem C<br>
Nesta etapa a tradução do código VHDL para linguagem C é executada, conforme<br>
apresentado na Figura 16, etapa B. A partir deste ponto, a ferramenta é executada de maneira<br>
propriamente dita, tendo todo o processo automatizado até a apresentação do resultado. Para<br>
esta etapa do método foi selecionado a ferramenta V2Cque realiza a tradução de VHDL para Adicionar<br>
refer-<br>
ência<br>
Linguagem C.<br>
A ferramenta V2C apresenta diversas vantagens em relação a equivalência de tradução<br>
de linguagens, contudo V2C apresenta certas limitação na tradução do código VHDL, em outras<br>
palavras, a mesma não reconhece algumas estruturas especificas do VHDL. A ferramenta aceita<br>
apenas entradas e saídas do tipo: bit, std_ulogic, qsim_state, std_ulogic_vector<br>
e interger. Na parte de arquitetura, a ferramenta aceita uma gama maior de estruturas, tra-<br>
balhando com expressoões do tipo: signal, variable, integers, strings e caracteres.<br>
Em expreções condicionais os operandos são AND, OR, NOT &lt;=, =&gt;,=,&lt;,&gt; e &lt;&gt;. Aceita<br>
também a estrutura de process, além da estutura block. A estrutura process é limitada<br>
Chapter 4. MÉTODO PROPOSTO 44<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 . . .<br>
4 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
5 SIGNAL a n d _ p o r t : b i t ;<br>
6 SIGNAL o r _ p o r t : b i t ;<br>
7 SIGNAL x o r _ p o r t : b i t ;<br>
8 SIGNAL mux2x1 : b i t ;<br>
9 BEGIN<br>
10 PROCESS(A, B , B i n v e r t i d o , Op1 ) IS<br>
11 BEGIN<br>
12 ??PORTA AND<br>
13 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
14 ??__ESBMC_assume (A = ’ 1 ’ )<br>
15 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
16 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
17 ELSE<br>
18 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
19 END IF ;<br>
20 . . .<br>
21 ??MUX4X1<br>
22 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
23 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
24 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
25 R e s u l t a d o &lt;= o r _ p o r t ;<br>
26 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
27 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
28 ??@c2vhdl : ASSERT<br>
29 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
30 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
31 ??s e v e r i t y ERROR;<br>
32 ??@c2vhdl :END<br>
33 END IF ;<br>
34 END PROCESS ;<br>
35 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
apenas a: if-else, case e loops. Como trabalho futuro, neste trabalho tem-se buscado<br>
novas abordagens para ampliar o suporte a estruturas não suportadas pelo V2C.<br>
Na tradução é necessário substituir os operadores originais por seus equivalentes em<br>
linguagem C. A excessão são os operadore específicos que gerenciam os valores de bit, tais<br>
como concatenação ou manipulação de partes vertoriais, para os quais são necessários construir<br>
procedimentos especificos em C.<br>
Conforme mostrado na Figura 21, na tradução são gerados vários vetores para suporte<br>
a tradução dos sinais representados no VHDL, sendo eles chg[], old[] e new[]. O vetor<br>
old[] contém o valor do sinais do passo anteriore a partir deste vetor o valor a ser usado nos Confuso<br>
issocálculo é obtido. O vetor new[] representa os novos valores a serem calculados pelos antigose<br>
Qual?<br>
Chapter 4. MÉTODO PROPOSTO 45<br>
o vetor chg[] contém um or exclusivo entre o valor novo e antigo e em caso de alteração entre<br>
os valores é copiado o valor de new[] para old[].<br>
O texto acima está muito confuso, corrigi rapidamente<br>
No código C gerado, os vetores in_data[] e out_data[] contêm os sinais de<br>
entrada e saída, respectivamente. No caso de circuitos sequênciais, o valor do status é inserido<br>
no primeiro (índice 0). A funçãoentão lerá os valores in_data[] e escreverá os resultados do qual?<br>
processamento em out_data[]. Ao final da operações os valores de estado são passado para<br>
out_data[].<br>
Conforme especificado e seguindo os parametros da ferramenta, a mesma realiza a<br>
tradução, mantendo inalterado qualquer fragmento de código que esteja comentado, neste caso,<br>
as assertivas presentes no código VHDL permanecem inalteradas, sendo utilizadas na próxima<br>
etapa do método proposto.<br>
4.4 Instrumentação de código<br>
As assertivas após a tradução permanecem comentadas, sendo necessário prepara-lás, ou<br>
seja traduzi-las, para verificação posterior do código na linguagem em C. Com isso é necessário<br>
uma instrumentação do código para prover suporte as assertivas traduzidas para análise, conforme<br>
apresentado na Figura 16, etapa C.<br>
Todas as etapas da instrumentação são realizados sobre o código C já traduzido. O passo<br>
inicial da instrumentação é a adição da macros no inicio do código C com as definição das<br>
assertivas a serem utilizadas. Na Figura 22 são apresentados os macros utilizadas no código C. A<br>
Linha 1 da figura corresponde a mensagem de erro a ser apresentada e a Linha 2 corresponde<br>
ao modelo da assertiva e a chamanda da macro definida na Linha 1 em caso de falha. Estas<br>
definições para as assertivas também podem ser utilizadas no código C traduzidos sem o uso do<br>
ESBMC.<br>
Figure 22 – Macros das assertivas implementadas em linguagem C<br>
1 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r ,M, __FILE__ , __LINE__ , # # __VA_ARGS__ )<br>
2 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
Fonte: Própria.<br>
O passo seguinte é a identificação das assertivas comentadas ao longo do corpo do<br>
código traduzido, utilizando o exemplo da Figura 23. As assertivas são identificadas através<br>
das tags @c2vhdl:ASSERT e @c2vhdl:END e a busca é realizado através destas tags. Ao<br>
ser encontrado a tag @c2vhdl:ASSERT, é realizado um loop até que seja encontrada a tag<br>
Chapter 4. MÉTODO PROPOSTO 46<br>
@c2vhdl:END e com isso toda a assertiva inserida possa ser passada a função de busca das<br>
informações da assertiva contidas entre as tags apresentadas.<br>
Com os dados das assertivas obtidos é realizado a busca da condição, mensagem e<br>
severidade através dos comandos ??assert, ??report e ??severity respectivamente.<br>
Estas informações são encontradas através do uso e uma Regex no código e que são adicionadas<br>
ao código C seguindo o modelo definido na macro. Este processo é repetido até outra assertiva<br>
ser encontrada ou caso chegue ao fina do código C.<br>
Com a função __ESBMC_assume() ocorre processo semelhante ao das assertivas.<br>
Utilizando novamente uma regex que realiza a busca por esta função no código e é retirado o<br>
comentário da mesma, desta forma a mesma passa a esta acessivél para o ESBMC, visto que a<br>
declaração da mesma já segue o modelo padrão a ser utilizado pelo ESBMC.<br>
Durante a instrumentação de código também é realizado a entrada de sinais não de-<br>
terministicos para variaveis não inicializadas ou argumentos de funções do código C gerado<br>
da tradução, utilizando a função __VERIFIER_nondet_int(). Esta função é utilizada em<br>
todas as variaveis de entrada e também nos sinais criados ao longo da arquitetura. Desta forma,<br>
todas as variavéis necessárias são inicializadas para verificação.<br>
Explicar <span class='f1 c_69' id='c_69_1' href='#c_69_2' cs_f='.c_69' >o funcionamento do</span> nondet com o ESBMC<br>
Em outras palavras, na instrumentação de código é realizado a traduçao das assertivas do<br>
modelo utilizado no código VHDL para <span class='f1 c_2' id='c_2_1' href='#c_2_2' cs_f='.c_2' >para o modelo</span> utilizado em linguagem C, além como de<br>
outras funções que possam ser utilizados pelo VHDL. Ao final da instrumentação o código C<br>
fica disponivel para que possa ser dado como entrada para outras ferramentas de verificação de<br>
código e não apenas o ESBMC.<br>
4.5 Verificação de assertivas usando Model Checker<br>
O model checker adotado no desenvolvimento de método é o ESBMCna versão 3.0.0 referência<br>
e conforme explicado na subsection 2.2.3, esta ferramenta recebe como entrada um código <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >C<br>
ou C</span>++ e devido a isso foi escolhida neste projeto. Nesta seção será apresentado a etapa D do apresentar<br>
outras<br>
vanta-<br>
gens<br>
métod proposto na Figura 16.<br>
Para a verificação, a primeira etapa é a identificação das assertivas no código C analisado,<br>
para isso é utilizado uma opção do ESBMC (??show-claims), mais especificamente as<br>
assertivas instrumentadas no código C analisado. Cada assertiva é identificada através de uma<br>
numeração de acordo com a ordem de busca do código analisado. Cada assertiva encontrada é<br>
armazenada para que seja realizada uma análise individual de cada claim, ou seja, assertiva.<br>
Chapter 4. MÉTODO PROPOSTO 47<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas.<br>
1 VAR<br>
2 c o n t a d o r : i n t e i r o<br>
3 c l a i m : l i s t a<br>
4 c l a i m _ s t r i n g : s t r i n g<br>
5<br>
6 FUNCAO c a l l _ e s b m c : a r q u i v o<br>
7 c o n t a d o r &lt;?0<br>
8 INICIO<br>
9 s a i d a &lt;?f un ca o de g e r a c a o das c l a i m s p e l o ESBMC<br>
10 ENQUANTO c o n t a d o r &lt; s a i d a FACA<br>
11 c o n t a d o r +=2<br>
12 r e g e x p a r a p r o c u r a r c l a i m e numeracao da c l a i m<br>
13 SE e n c o n t r a r c l a i m ENTAO<br>
14 r e g e x p a r a p r o c u r a r a p a l a v r a " a s s e r t i o n "<br>
15 SE e n c o n t r a r a p a l a v r a " a s s e r t i o n " ENTAO<br>
16 c o n t a d o r +=1<br>
17 A d i c i o n a a numeracao da c l a i m na l i s t a<br>
18 FIM?SE<br>
19 FIM?SE<br>
20 FIM?ENQUANTO<br>
21 FIM?FUNCAO<br>
Fonte: Própria.<br>
Na Linha 9 da Figura 24 é apresentado a chamada da ferramenta ESBMC que ocorre e<br>
através da opção ??show-claims lista todas as claims presentes no texto, como apresentado<br>
na Figura 25. Como o ESBMC infere de forma automatica assertivas a serem verificadas no<br>
código. Visando isolar somente as assertivas instrumentadas pelo método proposto, juntamente<br>
com a opção –show-claims é utilizado as opções:<br>
• ??no-pointer-check: para não realizar a checagem de ponteiros no código;<br>
• ??no-div-by-zero-check: para não realizar a checagem de divisões por zero no<br>
código; e<br>
• ??no-bounds-check: para não realizar a checagem de array bounds no código.<br>
Chapter 4. MÉTODO PROPOSTO 48<br>
Figure 25 – Imagem de claims contendo assertivas.<br>
Fonte:Própria<br>
Após a listagem das claims com assertivas ser gerada, outra função, indicada na Figura 26,<br>
é chamada para verificação de cada claim individualmente. Para cada claim, ocorre a chamada do<br>
ESBMC, utilizando as opções ??no-pointer-check, ??no-div-by-zero-check e<br>
??no-bounds-check, juntamente com a opção ??unwind em que realiza o número de<br>
desdobramentos dos laços no código analisado.<br>
Contudo, dependendo da complexidade da assertiva, faz-se necessário aumentar o número<br>
de desdobramentos que, por padrão são dez, conforme análise experimentais. A função é chamada<br>
na Linha 11 da Figura 26 e após a analise da claim é realizado a busca do resultado e exibição<br>
caso seja uma propriedade violada.<br>
Desta forma o ESBMC realiza apenas a checagem necessária dentro da assertiva, evitando<br>
que outros parâmetros sejam verificados, sem a devida necessidade do mesmo. Ao final de todos<br>
os desdobramentos é apresentado o resultado, apresentado na Figura 27, sendo positiva (sem<br>
erros) ou negativa (com violação de propriedades), dependendo da assertiva e do código analisado.<br>
Este processo se repete até a lista de assertivas ser finalizada.<br>
Chapter 4. MÉTODO PROPOSTO 49<br>
Figure 26 – Pseudocódigo da função de análise das claims.<br>
1 VAR<br>
2 c o n t a d o r 1 : i n t e i r o<br>
3 c o n t a d o r 2 : i n t e i r o<br>
4 r e s u l t a d o : l i s t a<br>
5<br>
6 FUNCAO esbmc_c la ims : l i s t a , a r q u i v o<br>
7 c o n t a d o r 1 &lt;?0<br>
8 c o n t a d o r 2 &lt;?0<br>
9 busca p e l o nome da fu nc a o no a r q u i v o<br>
10 ENQUANTO c o n t a d o r &lt; l i s t a FACA<br>
11 s a i d a &lt;?Execu ta comando de a n a l i s e da c l a i m<br>
numerada na l i s t a<br>
12 ENQUANTO c o n t a d o r 2 &lt; s a i d a<br>
13 Regex busca se a p r o p r i e d a d e f o i v i o l a d a<br>
14 SE p r o p r i e d a d e f o i v i o l a d a ENTAO<br>
15 Pu la p a r a l i n h a da v i o l a ç ã o<br>
16 A d i c i o n a o e r r o ao r e s u l t a d o<br>
17 FIM?SE<br>
18 FIM?ENQUANTO<br>
19 FIM?ENQUANTO<br>
20 FIM?FUNCAO<br>
Fonte: Própria.<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta.<br>
Fonte:Própria<br>
Ajustar os códigos, alguns estao muito grandes e com trechos desnecessário, não foi<br>
citado o link do repo da ferramenta<br>
Chapter 4. MÉTODO PROPOSTO 50<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C.<br>
1 void u l a _ t c c ( i n t i n _ d a t a [ ] , i n t o u t _ d a t a [ ] )<br>
2 {<br>
3 i n t _ i _ =0;<br>
4 i n t _c on t_ ;<br>
5 enum s e g n a l e {A, B , B i n v e r t i d o , Op1 , Op2 , R e s u l t a d o , and_po r t , o r _ p o r t ,<br>
6 x o r _ p o r t , mux2x1 , _MAX_} ;<br>
7 i n t o l d [_MAX_ ] ;<br>
8 i n t new [_MAX_ ] ;<br>
9 i n t chg [_MAX_ ] ;<br>
10 new [A] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
11 new [B] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
12 new [ B i n v e r t i d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
13 new [ Op1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
14 new [ Op2 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
15 new [ R e s u l t a d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
16 new [ a n d _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
17 new [ o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
18 new [ x o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
19 new [ mux2x1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
20<br>
21 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
22 {<br>
23 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
24 }<br>
25 new [A] = i n _ d a t a [ 1 ] ;<br>
26 new [B] = i n _ d a t a [ 2 ] ;<br>
27 new [ B i n v e r t i d o ] = i n _ d a t a [ 3 ] ;<br>
28 new [ Op1 ] = i n _ d a t a [ 4 ] ;<br>
29 new [ Op2 ] = i n _ d a t a [ 5 ] ;<br>
30<br>
31 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
32 {<br>
33 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
34 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
35 }<br>
36<br>
37 do {<br>
38 _ co n t _ =0;<br>
39 /? S t a r t o f T r a n s l a t i o n ? /<br>
40<br>
41 /? p0 : ? /<br>
42 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
43 /?PORTA AND ? /<br>
44 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
45 \ \ __ESBMC_assume ( o l d [A] = 1) ;<br>
46 \ \ __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
47 new [ a n d _ p o r t ] = 1 ;<br>
48 }<br>
49 e l s e {<br>
50 new [ a n d _ p o r t ] = 0 ;<br>
51 }<br>
52 /?PORTA OR ? /<br>
53 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
54 new [ a n d _ p o r t ] = 0 ;<br>
55 }<br>
56 e l s e {<br>
57 new [ a n d _ p o r t ] = 1 ;<br>
58 }<br>
59 /?PORTA XOR ? /<br>
60 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
61 new [ x o r _ p o r t ] = 0 ;<br>
62 }<br>
63 e l s e i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==1) ) {<br>
64 new [ x o r _ p o r t ] = 0 ;<br>
65 }<br>
66 e l s e {<br>
67 new [ x o r _ p o r t ] = 1 ;<br>
68 }<br>
69 /? INVERSOR ? /<br>
70 i f ( ( o l d [ B i n v e r t i d o ]==0) ) {<br>
71 i f ( chg [B ] ) {<br>
72 new [ mux2x1 ]= o l d [B ] ;<br>
73 }<br>
74 }<br>
75 e l s e {<br>
76 i f ( chg [B ] ) {<br>
77 new [ mux2x1 ]=~ o l d [B ] ;<br>
78 }<br>
79 }<br>
80 /?MUX4X1 ? /<br>
81 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
82 i f ( chg [ a n d _ p o r t ] ) {<br>
83 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
84 \ \ @c2vhdl : ASSERT<br>
85 \ \ a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
86 \ \ r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
87 \ \ s e v e r i t y ERROR;<br>
88 \ \ @c2vhdl :END<br>
89 }<br>
90 }<br>
91 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
92 i f ( chg [ o r _ p o r t ] ) {<br>
93 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
94 }<br>
95 }<br>
96 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
97 i f ( chg [ x o r _ p o r t ] ) {<br>
98 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
99 }<br>
100 }<br>
101 }<br>
102<br>
103 /? End o f T r a n s l a t i o n ? /<br>
104 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
105 {<br>
106 i f ( new [ _ i _ ] ! = o l d [ _ i _ ] ) _ con t_ =1;<br>
107 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
108 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
109 }<br>
110 } whi le ( _c on t_ ) ;<br>
111<br>
112 new [A] &= 0X01 ;<br>
113 new [B] &= 0X01 ;<br>
114 new [ B i n v e r t i d o ] &= 0X01 ;<br>
115 new [ Op1 ] &= 0X01 ;<br>
116 new [ Op2 ] &= 0X01 ;<br>
117 new [ R e s u l t a d o ] &= 0X01 ;<br>
118 new [ a n d _ p o r t ] &= 0X01 ;<br>
119 new [ o r _ p o r t ] &= 0X01 ;<br>
120 new [ x o r _ p o r t ] &= 0X01 ;<br>
121 new [ mux2x1 ] &= 0X01 ;<br>
122<br>
123 o u t _ d a t a [ 0 ] = 0 ; _ i _ =0;<br>
124 o u t _ d a t a [ 0 ] | = new [A] &lt;&lt; _ i _ ; _ i _ +=1;<br>
125 o u t _ d a t a [ 0 ] | = new [B] &lt;&lt; _ i _ ; _ i _ +=1;<br>
126 o u t _ d a t a [ 0 ] | = new [ B i n v e r t i d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
127 o u t _ d a t a [ 0 ] | = new [ Op1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
128 o u t _ d a t a [ 0 ] | = new [ Op2 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
129 o u t _ d a t a [ 0 ] | = new [ R e s u l t a d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
130 o u t _ d a t a [ 0 ] | = new [ a n d _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
131 o u t _ d a t a [ 0 ] | = new [ o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
132 o u t _ d a t a [ 0 ] | = new [ x o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
133 o u t _ d a t a [ 0 ] | = new [ mux2x1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
134<br>
135 o u t _ d a t a [ 1 ] = new [ R e s u l t a d o ] ;<br>
136 }<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 51<br>
Figure 23 – Código com assertivas traduzida para linguagem C<br>
1 # inc lude &lt; s t d i o . h&gt;<br>
2 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r , M , __FILE__ , __LINE__ , ##<br>
__VA_ARGS__ ) / / Update t o p r i n t t h e t r a c e<br>
3 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
4<br>
5 . . .<br>
6<br>
7 do {<br>
8 _co n t _ =0;<br>
9 /? S t a r t o f T r a n s l a t i o n ? /<br>
10 chg [A] = __VERIFIER_nondet_int ( ) ;<br>
11 chg [B] = __VERIFIER_nondet_int ( ) ;<br>
12 chg [ B i n v e r t i d o ] = __VERIFIER_nondet_int ( ) ;<br>
13 chg [ Op1 ] = __VERIFIER_nondet_int ( ) ;<br>
14 chg [ a n d _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
15 chg [ R e s u l t a d o ] = __VERIFIER_nondet_int ( ) ;<br>
16 chg [ o r _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
17 chg [ mux2x1 ] = __VERIFIER_nondet_int ( ) ;<br>
18<br>
19 /? p0 : ? /<br>
20 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
21 /?PORTA AND ? /<br>
22 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
23 __ESBMC_assume ( o l d [A] = 1) ;<br>
24 __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
25 new [ a n d _ p o r t ] = 1 ;<br>
26 }<br>
27 e l s e {<br>
28 new [ a n d _ p o r t ] = 0 ;<br>
29 }<br>
30<br>
31 . . .<br>
32<br>
33 /?MUX4X1 ? /<br>
34 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
35 i f ( chg [ a n d _ p o r t ] ) {<br>
36 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
37 __MY_asser t ( new [ R e s u l t a d o ] == 1 , "O r e s u l t a d o é d i f e r e n t e de 0 " ) ;<br>
38 }<br>
39 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
40 i f ( chg [ o r _ p o r t ] ) {<br>
41 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
42 }<br>
43 }<br>
44 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
45 i f ( chg [ x o r _ p o r t ] ) {<br>
46 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
47 }<br>
48 }<br>
49 }<br>
50<br>
51 /? End o f T r a n s l a t i o n ? /<br>
52 . . .<br>
Fonte: Própria.<br>
52<br>
5 CRONOGRAMA<br>
53<br>
6 CONSIDERAÇÕES PARCIAIS E<br>
TRABALHOS FUTUROS<br>
O trabalho aborda <span class='f1 c_33' id='c_33_1' href='#c_33_2' cs_f='.c_33' >o desenvolvimento de</span> um método para análise de circuitos lógicos de-<br>
scrito em VHDL através da aplicação de técnica de transformação de código e a técnica Bounded<br>
Model Cheking. Este método tem como objetivo de explorar os estados alcanç alcançáveis no<br>
circuito, e dessa forma identificar erros que possam resutar em mal funcionamento do sistema.<br>
Entre as dificuldade encontradas, a principal esta ligada a etapa de tradução de código.<br>
Devido a ferramenta utilizada inicialmente conter diversas limitações, a mesma diminui a eficácia<br>
da ferramenta, pois a quantidade de estruturas que podem ser utilizadas é limitada e com isso<br>
limitando também <span class='f1 c_57' id='c_57_1' href='#c_57_2' cs_f='.c_57' >o processo de</span> criação de protótipos.<br>
Os trabalhos futuros é necessário buscar uma nova ferramenta ou método de tradução<br>
que tenha uma gama maior de tradução, seja em estruturas ou palavras reservadas,deste forma<br>
o método desenvlvido torna-se mais eficiente e gerando uma menor intervenção do usuário no<br>
código VHDL. A melhoria na tradução de código também beneficia ageração das assertivas<br>
automáticamente, pois com uma gama maior de estruturas suportadas, mais assertivas podem ser<br>
geradas.<br>
Além disso a geração automática das assertivas é Outro ponto abordado, já sitado anterior-<br>
mente, é a geração automática das assertivas, visto que na estapa atual ainda nõ foi implementado.<br>
Este recuros visa da liberdade ao desenvolvedor promovendo de maneira automática os teste<br>
sobre o código, não necessitando que uma intervenção, tornando a inserção manual apenas em<br>
casos especificos de testes.<br>
54<br>
BIBLIOGRAPHY<br>
ABE, J. Introducao a Logica Para a Ciencia Da Computacao. Arte & Ciência, 2002. ISBN<br>
9788574730455. Disponível em: &lt;https://books.google.com.br/books?id=AgBJdjoNPwUC&gt;.<br>
ACM. 2018. Acessado em: 01 de março de 2018. Disponível em: &lt;http://dl.acm.org/&gt;.<br>
AHO, A. V.; SETHI, R.; ULLMAN, J. D. Compilers: principles, techniques, and tools. [S.l.]:<br>
Addison-wesley Reading, 2007. v. 2.<br>
ALLEN, F. E. Control flow analysis. In: ACM. ACM Sigplan Notices. [S.l.], 1970. v. 5, n. 7, p.<br>
1–19.<br>
BAIER, C.; KATOEN, J.-P.; LARSEN, K. G. Principles of model checking. [S.l.]: MIT press,<br>
2008.<br>
BARA, A. et al. Formal verification of timed vhdl programs. In: IET. FDL. [S.l.], 2010. p.<br>
80–85.<br>
BASILI, V. R.; CALDIERA, G.; ROMBACH, H. D. Experience factory. Encyclopedia of<br>
software engineering, Wiley Online Library, 1994.<br>
BENSALEM, S.; LAKHNECH, Y. Automatic generation of invariants. Formal Methods in<br>
System Design, Springer, v. 15, n. 1, p. 75–92, 1999.<br>
BIERE, A. The aiger and-inverter graph (aig) format. Available at http://fmv.jku.at/aiger, 2016.<br>
BIOLCHINI, J. et al. Systematic review in software engineering. System Engineering and<br>
Computer Science Department COPPE/UFRJ, Technical Report ES, v. 679, n. 05, p. 45, 2005.<br>
BOULE, M.; ZILIC, Z. Incorporating efficient assertion checkers into hardware emulation. In:<br>
IEEE. Computer Design: VLSI in Computers and Processors, 2005. ICCD 2005. Proceedings.<br>
2005 IEEE International Conference on. [S.l.], 2005. p. 221–228.<br>
BOULE, M.; ZILIC, Z. Efficient automata-based assertion-checker synthesis of seres for<br>
hardware emulation. In: IEEE COMPUTER SOCIETY. Proceedings of the 2007 Asia and South<br>
Pacific Design Automation Conference. [S.l.], 2007. p. 324–329.<br>
BRAYTON, R.; MISHCHENKO, A. Abc: An academic industrial-strength verification tool. In:<br>
SPRINGER. Computer Aided Verification. [S.l.], 2010. p. 24–40.<br>
B.V. 2018. Acessado em 1 de março de 2018. Disponível em: &lt;http://www.sciencedirect.com/&gt;.<br>
CABODI, G. et al. Hardware model checking competition 2014: an analysis and comparison of<br>
solvers and benchmarks. Journal on Satisfiability, Boolean Modeling and Computation, v. 9, p.<br>
135–172, 2016.<br>
CAPPELATTI, D. Praticando VHDL. Editora Feevale, 2010. ISBN 9788577171200. Disponível<br>
em: &lt;https://books.google.com.br/books?id=z4\_CYog\_UskC&gt;.<br>
Bibliography 55<br>
CHRISTEN, E.; BAKALAR, K. Vhdl-ams-a <span class='f1 c_48' id='c_48_1' href='#c_48_2' cs_f='.c_48' >hardware description language</span> for analog and<br>
mixed-signal applications. IEEE Transactions on Circuits and Systems II: Analog and Digital<br>
Signal Processing, IEEE, v. 46, n. 10, p. 1263–1272, 1999.<br>
CHU, P. P. RTL hardware design using VHDL: coding for efficiency, portability, and scalability.<br>
[S.l.]: John Wiley & Sons, 2006.<br>
CLARKE, E. et al. Verification of hybrid systems based on counterexample-guided abstraction<br>
refinement. In: SPRINGER. TACAS. [S.l.], 2003. v. 3, p. 192–207.<br>
CLARKE, E. M. The birth of model checking. In: 25 Years of Model Checking. [S.l.]: Springer,<br>
2008. p. 1–26.<br>
CLARKE, E. M.; GRUMBERG, O.; LONG, D. E. Model checking and abstraction. ACM<br>
transactions on Programming Languages and Systems (TOPLAS), ACM, v. 16, n. 5, p.<br>
1512–1542, 1994.<br>
CORDEIRO, L.; FISCHER, B.; MARQUES-SILVA, J. Smt-based bounded model checking for<br>
embedded ansi-c software. IEEE Transactions on Software Engineering, IEEE, v. 38, n. 4, p.<br>
957–974, 2012.<br>
COUSOT, P.; COUSOT, R. A gentle introduction to formal verification of computer systems by<br>
abstract interpretation. [S.l.]: IOS Press, 2010.<br>
DAHAN, A. et al. Combining system level modeling with assertion based verification. In: Sixth<br>
international symposium on quality electronic design (isqed’05). [S.l.: s.n.], 2005. p. 310–315.<br>
ISSN 1948-3287.<br>
D’SILVA, V.; KROENING, D.; WEISSENBACHER, G. A survey of automated techniques<br>
for formal software verification. IEEE Transactions on <span class='f1 c_38' id='c_38_1' href='#c_38_2' cs_f='.c_38' >Computer-Aided Design</span> of Integrated<br>
Circuits and Systems, IEEE, v. 27, n. 7, p. 1165–1178, 2008.<br>
ELSEVIER. 2017. Acessado em: 01 março 2018. Disponível<br>
em: &lt;https://www.elsevier.com/__data/assets/pdf_file/0007/69451/<br>
0597-Scopus-Content-Coverage-Guide-US-LETTER-v4-HI-singles-no-ticks.pdf&gt;.<br>
G1. Acidente foi provocado por falha em circuito eletrônico, diz se-<br>
cretário. 2012. Disponível em: &lt;http://g1.globo.com/sao-paulo/noticia/2012/05/<br>
acidente-foi-provocado-por-falha-em-circuito-eletronico-diz-secretario.html&gt;.<br>
GUGLIELMO, G. D. et al. On the use of assertions for embedded-software dynamic verification.<br>
In: IEEE. Design and Diagnostics of Electronic Circuits & Systems (DDECS), 2012 IEEE 15th<br>
International Symposium on. [S.l.], 2012. p. 330–335.<br>
GUPTA, A. Formal hardware verification methods: A survey. In: SPRINGER. Computer-Aided<br>
Verification. [S.l.], 1992. p. 5–92.<br>
HALDER, A.; VENKATESWARLU, A. A study of petri nets modeling analysis and simulation.<br>
Department of Aerospace Engineering Indian Institute of Technology Kharagpur, India, 2006.<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Interpolation and symbol elimination in vampire.<br>
Automated Reasoning, Springer, p. 188–195, 2010.<br>
Bibliography 56<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Case studies on invariant generation using a<br>
saturation theorem prover. Advances in Artificial Intelligence, Springer, p. 1–15, 2011.<br>
IDOETA, I. V.; CAPUANO, F. G. Elementos de eletrônica digital. [S.l.]: Livros Erica, 1982.<br>
IEC/IEEE International Standard - Behavioural languages - Part 1-1: VHDL Language<br>
Reference Manual. IEC 61691-1-1:2011(E) IEEE Std 1076-2008, p. 1–648, May 2011.<br>
IEEE. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http://ieeexplore.ieee.org/<br>
Xplore/home.jsp&gt;.<br>
IEEE Standard for Property Specification Language (PSL). IEEE Std 1850-2010 (Revision of<br>
IEEE Std 1850-2005), p. 1–182, April 2010.<br>
IEEE Standard for Verilog <span class='f1 c_48' id='c_48_1' href='#c_48_2' cs_f='.c_48' >Hardware Description Language</span>. IEEE Std 1364-2005 (Revision of<br>
IEEE Std 1364-2001), p. 1–560, 2006.<br>
KITCHENHAM, B. Procedures for performing systematic reviews. Keele, UK, Keele University,<br>
v. 33, n. 2004, p. 1–26, 2004.<br>
KITCHENHAM, B. et al. Systematic literature reviews in software engineering–a systematic<br>
literature review. Information and software technology, Elsevier, v. 51, n. 1, p. 7–15, 2009.<br>
KNOOP, J.; RÜTHING, O.; STEFFEN, B. Partial dead code elimination. [S.l.]: ACM, 1994.<br>
v. 29.<br>
KOSCIANSKI, A.; SOARES, M. dos S. Qualidade de Software - 2a Edição: Aprenda as<br>
metodologias e técnicas mais modernas <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento de</span> software. Novatec,<br>
2007. ISBN 9788575221129. Disponível em: &lt;https://books.google.com.br/books?id=<br>
O9aWoUq6L88C&gt;.<br>
KROPF, T. Introduction to Formal Hardware Verification. Springer Berlin Heidelberg,<br>
2013. ISBN 9783662038093. Disponível em: &lt;https://books.google.com.br/books?id=<br>
7ImrCAAAQBAJ&gt;.<br>
MAFRA, S. N.; TRAVASSOS, G. H. Estudos primarios e secundarios apoiando a busca por<br>
evidencia em engenharia de software. Relatorio Tecnico, RT-ES, v. 687, n. 06, 2006.<br>
MUKHERJEE, R. et al. Unbounded safety verification for hardware using software analyzers.<br>
In: EDA CONSORTIUM. Proceedings of the 2016 Conference on Design, Automation & Test in<br>
Europe. [S.l.], 2016. p. 1152–1155.<br>
MUKHERJEE, R.; TAUTSCHNIG, M.; KROENING, D. v2c–a verilog to c translator. In:<br>
SPRINGER. International Conference on Tools and Algorithms for the Construction and<br>
Analysis of Systems. [S.l.], 2016. p. 580–586.<br>
MURATA, T. Petri nets: Properties, analysis and applications. Proceedings of the IEEE, IEEE,<br>
v. 77, n. 4, p. 541–580, 1989.<br>
RAMESH, U. B. K.; SENTILLES, S.; CRNKOVIC, I. Energy management in embedded<br>
systems: Towards a taxonomy. In: IEEE PRESS. Proceedings of the First International<br>
Workshop on Green and Sustainable Software. [S.l.], 2012. p. 41–44.<br>
ROCHA, H. et al. Exploiting safety properties in bounded model checking for test cases<br>
generation of c programs. 2010.<br>
Bibliography 57<br>
ROCHA, H. et al. Model checking embedded c software using k-induction and invariants<br>
(extended version). arXiv preprint arXiv:1509.02471, 2015.<br>
ROCHA, H. O. et al. Verificacao de sistemas de software baseada em transformacoes de codigo<br>
usando bounded model checking. Universidade Federal do Amazonas, 2015.<br>
SARGENT, R. G. Verification and validation of simulation models. In: WINTER SIMULATION<br>
CONFERENCE. Proceedings of the 37th conference on Winter simulation. [S.l.], 2005. p.<br>
130–143.<br>
SEGER, C.-J. An introduction to formal hardware verification. [S.l.]: University of British<br>
Columbia, Department of Computer Science, 1992.<br>
SOMMERVILLE, I. Engenharia de software. PEARSON BRASIL, 2011. ISBN 9788579361081.<br>
Disponível em: &lt;https://books.google.com.br/books?id=H4u5ygAACAAJ&gt;.<br>
SONS, J. W. . 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http:<br>
//onlinelibrary.wiley.com/&gt;.<br>
SOUZA, J. Lógica para Ciência da Computação. Elsevier Brasil, 2017. ISBN 9788535278255.<br>
Disponível em: &lt;https://books.google.com.br/books?id=Ds2sCQAAQBAJ&gt;.<br>
SPRINGER. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;https:<br>
//link.springer.com/&gt;.<br>
SRIKANT, Y.; SHANKAR, P. The Compiler Design Handbook: Optimizations and<br>
Machine Code Generation. CRC Press, 2002. ISBN 9781420040579. Disponível em:<br>
&lt;https://books.google.com.br/books?id=0K\_jIsgyNpoC&gt;.<br>
THOMAS, D.; MOORBY, P. The Verilog R© <span class='f1 c_48' id='c_48_1' href='#c_48_2' cs_f='.c_48' >Hardware Description Language</span>. Springer<br>
US, 2008. ISBN 9780387853444. Disponível em: &lt;https://books.google.com.br/books?id=<br>
DxQGrz7q-SwC&gt;.<br>
TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L. Sistemas digitais: princípios e aplicações. [S.l.]:<br>
Prentice Hall, 2003. v. 8.<br>
TRAVASSOS, G. H. et al. An environment to support large scale experimentation in software<br>
engineering. In: IEEE. Engineering of Complex Computer Systems, 2008. ICECCS 2008. 13th<br>
IEEE International Conference on. [S.l.], 2008. p</div>
<!-- DIVISOR_DIV_CANDIDATE -->

<div class='divisor divisor-texto' id="cand__file2"><hr class='text-separator'><br>Input file: <a href='#'>main.pdf</a> (12773 chunks)<br>File found: <a href='http://docplayer.com.br/77844321-Coordenacao-do-programa-de-iniciacao-cientifica.html' target='_blank'>http://docplayer.com.br/77844321-Coordenacao-do-programa-de-iniciacao-cientifica.html</a> (5885 chunks)<br><br>Chunks in common: 47<br>Similarity: 0.25%<br><br><div class='textInfo'>The following is the content of the document <br>&nbsp;"<b>main.pdf</b>". <br>The terms in red were found in the document <br>&nbsp;"<b>http://docplayer.com.br/77844321-Coordenacao-do-programa-de-iniciacao-cientifica.html</b>".<br><hr class='text-separator'></div>  <span class='f1 c_46' id='c_46_1' href='#c_46_2' cs_f='.c_46' >UNIVERSIDADE FEDERAL DE RORAIMA</span><br>
PRÓ-<span class='f1 c_32' id='c_32_1' href='#c_32_2' cs_f='.c_32' >REITORIA DE ENSINO E</span> EXTENSÃO<br>
DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação <span class='f1 c_13' id='c_13_1' href='#c_13_2' cs_f='.c_13' >formal de circuitos</span> lógicos baseado em transformação de código <span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >com<br>
Bounded Model Checking</span><br>
<span class='f1 c_41' id='c_41_1' href='#c_41_2' cs_f='.c_41' >Boa Vista - RR</span><br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação <span class='f1 c_13' id='c_13_1' href='#c_13_2' cs_f='.c_13' >formal de circuitos</span> lógicos baseado em transformação de código<br>
<span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >com Bounded Model Checking</span><br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
<span class='f1 c_8' id='c_8_1' href='#c_8_2' cs_f='.c_8' >da Universidade Federal de Roraima</span> como<br>
requisito parcial para a obtenção do grau<br>
de Bacharel em Ciência da Computação.<br>
Orientador: Dr. <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >Herbert Oliveira Rocha</span><br>
<span class='f1 c_41' id='c_41_1' href='#c_41_2' cs_f='.c_41' >Boa Vista - RR</span><br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação <span class='f1 c_13' id='c_13_1' href='#c_13_2' cs_f='.c_13' >formal de circuitos</span> lógicos baseado em transformação de código <span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >com<br>
Bounded Model Checking</span><br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
<span class='f1 c_8' id='c_8_1' href='#c_8_2' cs_f='.c_8' >da Universidade Federal de Roraima</span> como<br>
requisito parcial para a obtenção do grau de<br>
Bacharel em Ciência da Computação.<br>
Defendido em 06 de março de 2017 e<br>
aprovado pela seguinte banca examinadora:<br>
Prof. Dr. <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >Herbert Oliveira Rocha</span><br>
Orientador / Curso de Ciência da Computação -<br>
UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Fazer dedicatória<br>
ACKNOWLEDGEMENTS<br>
Fazer agradecimentos!!<br>
Procurar frase massa!!<br>
ABSTRACT<br>
Fazer resumo!!<br>
Palavras-chaves: ??<br>
ABSTRACT<br>
Fazer Abstract!!<br>
Key-words: ??<br>
LISTA DE FIGURAS<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog. . . . . . . . . . . . . . . . 15<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL. . . . . . . . . . . . . . . . . 16<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade. . . . . . . . . . . . . . . 17<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL. . . . . . . . . . . . . . . . 17<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, <span class='f1 c_18' id='c_18_1' href='#c_18_2' cs_f='.c_18' >C=1 e D</span>=1. . . . . . . . . . 18<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas. . . . . . . . . 18<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas. . . . . . . . . . 19<br>
Figure 8 – Arvore de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
Figure 9 – Rede de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL. . . . . . . . . . . . . . . . . 27<br>
Figure 11 – Trecho de código em VHDL representando porta AND. . . . . . . . . . . . 28<br>
Figure 12 – Trecho de código traduzido para linguagem C. . . . . . . . . . . . . . . . . 29<br>
Figure 13 – Exemplo de bloco basico de código. . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 14 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 15 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 31<br>
Figure 16 – Ciclo da ferramenta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR. . . . . . . 41<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR. . . . . . . . . . . . . . 42<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume(). . . . . . . . . . . 43<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19. . . . . . . . . . . . . . . 44<br>
Figure 22 – Macros das assertivas implementadas em linguagem C . . . . . . . . . . . . 45<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas. . . . . . . 47<br>
Figure 25 – Imagem de claims contendo assertivas. . . . . . . . . . . . . . . . . . . . . 48<br>
Figure 26 – Pseudocódigo da função de análise das claims. . . . . . . . . . . . . . . . . 49<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta. . . . . . . . . . . . . . 49<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C. . . . . . . . . . . . . 50<br>
Figure 23 – Código com assertivas traduzida para linguagem C . . . . . . . . . . . . . . 51<br>
LISTA DE TABELAS<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM . . . . . . . . . . . . . . . 33<br>
SUMÁRIO<br>
1 INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11<br>
1.1 Definição do problema . . . . . . . . . . . . . . . . . . . . . . . . . . . 12<br>
1.2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13<br>
1.3 Organização do trabalho . . . . . . . . . . . . . . . . . . . . . . . . . 14<br>
2 CONCEITOS E DEFINIÇÕES . . . . . . . . . . . . . . . . . . . . . . 15<br>
2.1 Linguagens de descrição de hardware . . . . . . . . . . . . . . . . . 15<br>
2.1.1 VHSIC Hardware Description Language - VHDL . . . . . . . . . . . . . 16<br>
2.1.2 Portas lógicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18<br>
2.2 Verificação de sistemas . . . . . . . . . . . . . . . . . . . . . . . . . . 19<br>
2.2.1 Diagrama de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.2 Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.3 <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >Bounded Model Checking</span> . . . . . . . . . . . . . . . . . . . . . . . . . . 21<br>
2.2.4 Redes de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22<br>
2.2.5 Verificação de hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
2.2.6 Verificação formal de software . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.7 Lógica proposicional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.8 Linguagem de especificação de propriedades . . . . . . . . . . . . . . 26<br>
2.2.9 Verificação baseada em assertivas . . . . . . . . . . . . . . . . . . . . 26<br>
2.2.10 Propriedades de segurança . . . . . . . . . . . . . . . . . . . . . . . . 27<br>
2.3 Técnicas de compiladores . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.1 Transformações de código . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2 Otimização de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2.1 Grafo Acliclico Direcional - GAD . . . . . . . . . . . . . . . . . . . . . . . . 29<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.3 Eliminção de código morto . . . . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.4 Análise do fluxo de dados . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
2.3.2.5 Gerador de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
3 TRABALHOS CORRELATOS . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1 Revisão sistemática . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1.1 Planejamento da Revisão Sistemática . . . . . . . . . . . . . . . . . . 33<br>
3.1.1.1 Procedimentos de Seleção e Critérios . . . . . . . . . . . . . . . . . . . . 35<br>
3.2 Revisão da literatura . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.1 V2c-A verilog to C translator . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.2 Unbounded safety verification for hardware using software analyzers . 37<br>
3.2.3 Formal verification of timed VHDL programs . . . . . . . . . . . . . . . 38<br>
3.2.4 On the use of assertions for embedded-software dynamic verification 38<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation . . 39<br>
4 MÉTODO PROPOSTO . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.1 Visão geral do método . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.2 Preprocessamento do VHDL e inserção de assertivas . . . . . . . 42<br>
4.3 Tradução de código VHDL para a linguagem C . . . . . . . . . . . . 43<br>
4.4 Instrumentação de código . . . . . . . . . . . . . . . . . . . . . . . . 45<br>
4.5 Verificação de assertivas usando Model Checker . . . . . . . . . . 46<br>
5 CRONOGRAMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52<br>
6 CONSIDERAÇÕES PARCIAIS E TRABALHOS FUTUROS . . . . . 53<br>
BIBLIOGRAPHY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54<br>
11<br>
1 INTRODUÇÃO<br>
A complexidade de sistemas computacionais cresce exponencialmente. Muitas compan- Exemplificar<br>
este<br>
cresci-<br>
mento.<br>
hias e organizações estão rotineiramente lidando com software que contém milhares de linhas<br>
de código, escritos por diferentes pessoas, que usam linguagens distintas, ferramentas, estilos e<br>
hardware projetados de diversas formas e combinações (HODER et al., 2011).<br>
No contexto de sistemas compostos de hardware e software, tem-se os sistemas embarca-<br>
dos (SE) que são dispositivos semicondutores com software integrados, os quais se conectam<br>
a outros dispositivos. Usualmente, o principal propósito dos SE é o controle e provimento de<br>
informações para uma função específica (RAMESH et al., 2012).<br>
Os SE são extremamente interativos com seu ambiente, operam geralmente em tempo real<br>
e estão disponíveis continuamente. No entanto, estes sistemas, por possuírem um curto espaço<br>
de tempo para a liberação do produto ao mercado, precisam ser desenvolvidos rapidamente e<br>
atingir um alto nível de qualidade, mas, devido a esta necessidade, os programadores podem<br>
cometer enganos durante a fase de desenvolvimento destes sistemas.<br>
Os SE têm se proliferado em partes consideráveis das atividades do nosso cotidiano,<br>
com a característica de possuir grande quantidade de complexidade e diversidade. Devido a esta<br>
complexidade, erros podem passar despercebidos, causando não apenas penalidades econômicas<br>
e/ou fracassos do produto no mercado, mas principalmente o risco de perda de vidas humanas<br>
(CABODI et al., 2016). Como, por exemplo, o acidente noticiado no (G1, 2012), no qual, <span class='f1 c_30' id='c_30_1' href='#c_30_2' cs_f='.c_30' >de<br>
acordo com o</span> secretário de transportes, uma falha na placa do circuito eletrônico responsável<br>
pelo controle de velocidade dos trens ocasionou a colisão entre duas composições na estação de<br>
metrô de São Paulo.<br>
Segundo ROCHA et al.2015b, para se obter um alto nível de qualidade no desenvolvi-<br>
mento dos sistemas de hardware e software, a execução desses sistemas deve ser controlada e da<br>
mesma forma deve-se buscar meios de garantir que as propriedades definidas sejam atingidas. Por<br>
exemplo, a partir do conhecimento prévio do modo de implementação de determinado hardware,<br>
é possível utilizá-lo de forma mais eficiente. Neste sentido, diversas estratégias de verificação e<br>
de teste estão sendo pesquisadas e aplicadas para garantir a qualidade do software e hardware<br>
(HODER et al., 2010; ROCHA et al., 2010; BRAYTON; MISHCHENKO, 2010; CORDEIRO et<br>
al., 2012; CABODI et al., 2016).<br>
Por este motivo, com o intuito de analisar e otimizar a descrição dos circuitos digitais,<br>
tem-se utilizado as linguagens de descrição de hardware (HDL). Estas se diferem das linguagens<br>
de programação por conseguirem gerar execuções não apenas sequenciais, como também con-<br>
correntes ou paralelas (CHU, 2006). Neste contexto, a VHSIC Hardware Description Language<br>
Chapter 1. INTRODUÇÃO 12<br>
(VHDL) é uma das linguagens de descrição de hardware mais utilizadas atualmente. A descrição<br>
em VHDL pode ser em vários níveis de abstração, sendo o mais alto o nível comportamen-<br>
tal que permite a descrição do circuito através de loops e processos, definido-o <span class='f1 c_33' id='c_33_1' href='#c_33_2' cs_f='.c_33' >na forma de</span><br>
algoritmo. Como características das linguagens de descrição, o VHDL permite declarações se-<br>
quenciais ou concorrentes onde as declarações continuam ativas e sua ordem torna-se irrelevante<br>
(CAPPELATTI, 2010).<br>
Aliada à linguagem de descrição de hardware, a verificação formal de sistemas computa-<br>
cionais tem desempenhado um papel importante para assegurar a previsibilidade e a confiabili-<br>
dade na concepção de aplicações críticas. E, para isso, tem-se utilizado a técnica denominada<br>
model checking, que é baseada em formalismos matemáticos para provar propriedades de pro-<br>
gramas reativos (BENSALEM; LAKHNECH, 1999). Esta técnica gera uma busca exaustiva no<br>
espaço de estados do modelo para determinar se uma dada propriedade é válida ou não (BAIER<br>
et al., 2008), tendo como principal razão para o seu sucesso o funcionamento completamente<br>
automático, ou seja, sem qualquer intervenção do usuário.<br>
Visando contribuir com a verificação de sistemas embarcados no âmbito de sistemas<br>
computacionais, o contexto deste trabalho está situado <span class='f1 c_37' id='c_37_1' href='#c_37_2' cs_f='.c_37' >no uso de</span> metodologias e técnicas de<br>
verificação formal para programas escritos em VHDL (BIERE, 2016), focando principalmente<br>
no <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >Bounded Model Checking</span> (CORDEIRO et al., 2012; ROCHA et al., 2015a). Este trabalho está<br>
interessado especificamente na parte de: verificação de modelos de hardware descritos em níveis<br>
de circuitos de bits na linguagem VHDL, via transformações de código para gerar modelos (com<br>
assertivas) já suportados por model checkers, como o ESBMC (CORDEIRO et al., 2012).<br>
Dessa forma, o trabalho almeja analisar as propriedades de alcançabilidade para a<br>
identificação de localizações de erro, bem como, assertivas contendo propriedades de segurança.<br>
A propriedade de alcançabilidade ou propriedade <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >do estado de</span> erro é satisfatória (SAT), se um<br>
estado de erro é alcançável. Caso contrário, a propriedade é considerada insatisfatória (UNSAT).<br>
No caso SAT, o model checking também gera um rastreio da validação da propriedade (contra-<br>
exemplo), ou seja, uma sequência de estados que mostra como chegar ao erro <span class='f1 c_40' id='c_40_1' href='#c_40_2' cs_f='.c_40' >a partir de</span> um<br>
ponto inicial.<br>
1.1 Definição do problema<br>
O avanço da tecnologia, principalmente nas áreas de design e fabricação de eletrônicos,<br>
aumentou a importância do hardware nos dias atuais. Cada vez com mais funcionalidades<br>
integradas, aliada a velocidade e circuitos menores, faz com que a complexidade dos sistemas<br>
de hardware aumente. Entretanto, devido à complexidade cada vez maior, a detecção tardia<br>
de erros no sistema pode resultar em perda de produção, mas também custos <span class='f1 c_1' id='c_1_1' href='#c_1_2' cs_f='.c_1' >associados ao<br>
desenvolvimento</span> do sistema(GUPTA, 1992). Devido a isso, a verificação de hardware visa<br>
assegurar que o circuito atinja as especificações para o qual foi projetado, através de técnicas<br>
Chapter 1. INTRODUÇÃO 13<br>
formais ou dinâmicas (BOULE; ZILIC, 2007).<br>
Por esta razão, a utilização de métodos formais tornou-se uma abordagem atraente<br>
para superar as limitações inerentes à validação baseada em simulação. Portanto, a maioria<br>
das empresas de semicondutores têm investigado a sua aplicabilidade. Escolhas individuais de<br>
métodos, ferramentas e áreas de aplicação das empresas têm variado, assim como o seu nível<br>
de sucesso (CABODI et al., 2016). Com os recentes avanços na escalabilidade de automação<br>
dos model checkers e nas equivalências sequenciais de verificação, a maioria das empresas têm<br>
crescido ao contar com essas técnicas(CLARKE, 2008).<br>
O problema considerado neste trabalho é expresso na seguinte questão: Como comple-<br>
mentar e aprimorar a verificação de propriedades de segurança em circuitos lógicos, de tal<br>
forma que uma propriedade possa ser mapeada em um problema de alcançabilidade sim-<br>
bólica, ou seja, se é possível alcançar um estado específico (para uma dada propriedade) a<br>
partir do estado inicial?<br>
1.2 Objetivos<br>
O objetivo principal deste trabalho é projetar e avaliar um método para efetuar verificação<br>
de circuitos, de forma automática, descritos em VHDL com portas lógicas em nível de bit<br>
pela utilização de técnicas de transformação de códigos combinado com a técnica <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >Bounded<br>
Model Checking</span> para exploração de estados alcançáveis no circuito, visando identificar erros ou<br>
comportamentos indevidos ou inesperados que podem resultar no funcionamento incorreto de<br>
um dado sistema.<br>
Os objetivos específicos são:<br>
1. Propor um método para especificar pré e pós-condições de circuitos digitais em nível de<br>
portas lógicas descritos em VHDL;<br>
2. Analisar ferramentas de verificação de modelos que utilizam a técnica <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >Bounded Model<br>
Checking</span>;<br>
3. Especificar uma técnica de conversão de circuitos em linguagem de descrição de hardware<br>
VHDL para um modelo a ser verificado usando a técnica <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >Bounded Model Checking</span>;<br>
4. Desenvolver um método para identificação de estados de erros ou ocorrências indevidas,<br>
de um dado circuito analisado, em modelos de hardware descritos em nível de bit na<br>
linguagem de descrição VHDL.<br>
5. Validar a aplicação do método proposto sobre benchmarks públicos de programas em<br>
VHDL, a fim de examinar a sua eficácia e aplicabilidade.<br>
Chapter 1. INTRODUÇÃO 14<br>
1.3 Organização do trabalho<br>
A introdução deste trabalho apresentou: o contexto, definição do problema, e objetivos<br>
deste trabalho. Os próximos capítulos estão organizados da seguinte forma:<br>
No Capítulo 2 Conceitos e Definições, são apresentados os conceitos abordados neste<br>
trabalho, especificamente: Linguagens de descrição de hardware; Verificação e validação de<br>
sistemas; e Técnicas de compiladores.<br>
No Capítulo 3 Trabalhos Correlatos, serão apresentados o método de pesquisa bibli-<br>
ográfica utilizado, sendo ele a revisão sistemática, seguido do resultado encontrado com esta<br>
pesquisa e, por fim, a contribuição dos artigos utilizados no desenvolvimento do projeto.<br>
No Capítulo 4 Método Proposto, são descritas as etapas de execução do novo método<br>
proposto que consiste na transformação do código, instrumentação de assertivas e verificação de<br>
código utilizando um model checker.<br>
No Capítulo 5, será apresentado o cronograma de atividades a ser realizado na elaboração<br>
do método durante o desenvolvimento do projeto.<br>
E, por fim, no Capítulo 6 Considerações parciais e trabalhos futuros, serão apresentas<br>
as considerações parciais e as sugestões de trabalhos futuros que podem ser desenvolvidos.<br>
15<br>
2 CONCEITOS E DEFINIÇÕES<br>
Este capítulo tem apresenta os principais conceitos e definições abordados neste tra-<br>
balho, tais como: Linguagens de descrição de hardware, Verificação de sistemas e Técnicas de<br>
Compiladores.<br>
2.1 Linguagens de descrição de hardware<br>
As linguagens de descrição de hardware (HDL) foram desenvolvidas com o intuito de<br>
auxiliar a criação de circuitos lógicos com grande número de elementos e com uma gama de<br>
abstrações lógicas e eletrônicas (THOMAS; MOORBY, 2008). Entre os exemplos, podemos<br>
citar: VDHL (IEC/IEEE. . . , 2011), Verilog (IEEE. . . , 2006) e SystemC (??).<br>
Segundo CHRISTEN; BAKALAR,1999, linguagens de descrição de hardware são lingua-<br>
gens de programação utilizadas com o intuito de descrever o comportamento de um determinado<br>
circuito, técnica conhecida como modelagem. Os modelos descritos em HDL são utilizados<br>
como entrada para um simulador, onde o mesmo pode ter seu comportamento analisado.<br>
As HDL’s trazem consigo diversas vantagens, entre elas códigos independentes de tec-<br>
nologia e fabricante, podendo ser portáteis e reutilizáveis (CAPPELATTI, 2010). As linguagens<br>
mais modernas, tais como VHDL e Verilog, possuem suporte tanto a descrição do circuito pro-<br>
priamente dito, quanto ao comportamento que o mesmo deve exercer (CHRISTEN; BAKALAR,<br>
1999).<br>
A Verilog, como já citado, é uma linguagem de descrição de hardware que fornece<br>
diversos níveis de abstração para desenvolvimento de sistemas digitais(THOMAS; MOORBY,<br>
2008). A linguagem foi desenvolvida para ser simples e efetiva nos diversos níveis de abstração<br>
incluindo o <span class='f1 c_5' id='c_5_1' href='#c_5_2' cs_f='.c_5' >suporte ao desenvolvimento</span>, verificação, síntese e testes de software (IEEE. . . , 2006).<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog.<br>
1 p r i m i t i v e m u l t i p l e x e r ( mux , c o n t r o l , dataA , da taB ) ;<br>
2 o u t p u t mux ;<br>
3 i n p u t c o n t r o l , dataA , da taB ;<br>
4 e n d p r i m i t i v e<br>
Fonte: Adaptado de (IEEE. . . , 2006).<br>
Na Figura 1 apresenta um exemplo de multiplexador descrito em Verilog utilizando a<br>
estrutura de modelagem, chamada UDP que permite a criação de novos primitivas para serem<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 16<br>
utilizada. Apresenta uma saída apenas(mux) e três entradas sendo uma de controle(control) e<br>
duas de dados(dataA e dataB).<br>
A VHDL é uma linguagem de descrição de hardware amplamente utilizada, concebida<br>
na década de 80, devido uma necessidade do Departamento de Defesa dos Estados Unidos<br>
da América (CAPPELATTI, 2010). Assim como a Verilog, esta linguagem também suporta o<br>
desenvolvimento, a verificação, a síntese, e os testes de hardware (IEC/IEEE. . . , 2011).<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL.<br>
1 l i b r a r y IEEE ;<br>
2 use IEEE . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 use IEEE . s t d _ l o g i c _ u n s i g n e d . a l l ;<br>
4 e n t i t y mux2x1 i s<br>
5 p o r t ( s e l : i n STD_LOGIC ;<br>
6 a , b : i n STD_LOGIC ;<br>
7 y : o u t STD_LOGIC ) ;<br>
8 end mux2x1 ;<br>
9<br>
10 a r c h i t e c t u r e d a t a f l o w of mux2x1 i s b e g i n<br>
11 y &lt;= ( a AND NOT s e l ) OR ( b AND s e l ) ;<br>
12 end d a t a f l o w .<br>
Fonte: (CAPPELATTI, 2010).<br>
Na Figura 2 está descrito um multiplexador de duas entradas descrito em VHDL, apre-<br>
sentando na parte inicial as bibliotecas e na entidade(entity) a declaração das variáveis utilizadas.<br>
Na arquitetura(architecture) apresenta o funcionamento do multiplexador, relacionando en-<br>
tradas e saídas conforme tenham sido declarados. Este conceitos serão melhor apresentados na<br>
subsection 2.1.1.<br>
Conforme apresentado nas Figura 1 e Figura 2, ambas as linguagens apresentam difer-<br>
enças no modelos de declaração e utilização para descrição de hardware. Para este trabalho foi<br>
escolhido a VHDL devido a linguagem apresentar um melhor escopo para análise, facilitando o<br>
trabalho de análise proposto para este projeto.<br>
2.1.1 VHSIC Hardware Description Language - VHDL<br>
Revisar textos e verificar a necessidade de mais exemplo<br>
VHDL é uma linguagem de descrição de hardware destinada a ser utilizada em todas<br>
as etapas da criação de sistemas eletrônicos, sendo elas: desenvolvimento; verificação; síntese;<br>
e, teste de circuitos (IEC/IEEE. . . , 2011). Segundo (CAPPELATTI, 2010), a VHDL apresenta<br>
três principais pilares: abstração, que consiste na descrição com diferentes níveis de detalhes;<br>
modularidade, que permite a divisão do projeto em vários blocos ou módulos para posterior<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 17<br>
interconexão; e hierarquia, permite que módulos possam ser compostos por submódulos e, os<br>
mesmos tenham níveis de abstração diferentes, dependendo da necessidade do projeto. Devido a<br>
esta versatilidade que a linguagem VHDL foi selecionada para o trabalho proposto.<br>
Segundo IEC/IEEE. . . ,2011, é necessário um padrão para formatação da descrição em<br>
VHDL: Entity (Pinos de entrada/saída) e Architecture (Arquitetura). A Entity ou entidade repre-<br>
senta o bloco onde são declaradas as entradas e as saídas do circuito utilizadas em todo o sistema,<br>
conforme apresentado na Figura 3. A Architecture ou arquitetura, apresentado na Figura 4, define<br>
a relação entre entradas e saídas declaradas na entidade, podendo tais especificações serem<br>
completas ou parciais. Assim como em outras linguagens, bibliotecas podem ser adicionadas,<br>
para que novas funções e atributos possam ser utilizados no projeto.<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade.<br>
1 l i b r a r y i e e e ;<br>
2 use IEEE . STD_LOGIC_1164 . ALL<br>
3<br>
4 ENTITY f u l l _ a d d e r IS PORT(<br>
5 x1 , x2 , c i n : i n s t d _ l o g i c ;<br>
6 S , c o u n t : o u t s t d _ l o g i c ) ;<br>
7 END f u l l _ a d d e r ;<br>
Fonte: Própria.<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL.<br>
1 ARCHITECTURE b e h a v i o r a l OF f u l l _ a d d e r IS<br>
2 BEGIN<br>
3 s &lt;=x1 XOR x2 XOR c i n ;<br>
4 cout &lt;=( x1 AND x2 ) OR ( x1 AND c i n ) OR ( b<br>
AND c i n ) ;<br>
5 END b e h a v i o r a l ;<br>
Fonte: Própria.<br>
Segundo CAPPELATTI,2010 uma descrição em VHDL pode conter diferentes níveis de<br>
abstração:<br>
• Comportamental: Permite descrever o circuito através de laços e processos. O circuito<br>
é definido em forma de um algoritmo, utilizando construção similares as utilizadas em<br>
linguagem de programação.<br>
• Transferência de registradores: Englobando a representação do dispositivo em nível de<br>
transferência entre registradores, que consiste na utilização de funções lógicas combina-<br>
cionais e de registradores.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 18<br>
• Estrutural: O circuito é descrito mais próximo da implementação real, podendo ser<br>
definidas portas lógicas com atrasos unitários ou com atrasos detalhados.<br>
2.1.2 Portas lógicas<br>
Segundo (IDOETA; CAPUANO, 1982), o conceito de portas lógicas é baseado na<br>
conhecida álgebra de Boole ou álgebra booleana, desenvolvida pelo matemático inglês George<br>
Boole em 1854. A álgebra booleana é representada por apenas dois valores, sendo eles o 0 e 1 e,<br>
através disso, expressa a relação entre entrada e saída dentro de um circuito. As portas lógicas<br>
podem ser construídas <span class='f1 c_40' id='c_40_1' href='#c_40_2' cs_f='.c_40' >a partir de</span> diodos, transistores e resistores interconectados de modo que a<br>
saída seja o resultante de uma operação lógica básica realizada sobre as entradas (TOCCI et al.,<br>
2003). A Figura 5 apresenta um exemplo de álgebra booleana sem a utilização de diagramas.<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, <span class='f1 c_18' id='c_18_1' href='#c_18_2' cs_f='.c_18' >C=1 e D</span>=1.<br>
Fonte: (TOCCI et al., 2003)<br>
Ainda segundo TOCCI et al.,2003, devido a esta característica, a álgebra booleana possui<br>
três operações básicas, OR (ou), AND (e) e NOT (não). Tal conjunto de operações também é<br>
denominado de operações booleanas e, <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >por meio da</span> utilização de tabelas verdade é possível<br>
descrever as saídas baseando-se nas entradas e na operação aplicada. Cada operação booleana<br>
possui sua tabela verdade ( Figura 6), bem como sua representação em forma de diagrama.<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas.<br>
Fonte: (TOCCI et al., 2003)<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 19<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas.<br>
Fonte: (TOCCI et al., 2003)<br>
A Figura 7 apresenta um circuito lógico formado pelas portas básicas da álgebra booleana.<br>
O circuito apresenta três entradas representadas pelas letras A, B e C, mas também formada<br>
por duas portas AND, uma porta NOT e uma porta OR. Cada uma destas portas representando<br>
operações a serem realizadas, podendo receber como entrada um valor inicial ou resultante de<br>
outra porta, como no exemplo ocorre com a última porta AND.<br>
Entetanto, segundo (KROPF, 2013), a análise de circuitos é extremamente complexa,<br>
resultando em um problema NP-Completo, algoritmos possuem tempo de execução exponencial.<br>
Contudo, este tempo de execução exponencial é uma complexidade exponencial para o pior caso,<br>
resultando crescimento exponencial da execução a medida que o tamanho do problema aumenta.<br>
Ainda, segundo (KROPF, 2013) a avaliação das funções booleanas podem ser ver-<br>
dadeiras(True) ou falso(False), com isso, para um função com n variáveis, apresenta 2n possibili-<br>
dades de avaliação. Utilizando o exemplo da Figura 7 que apresenta 3 entradas, logo apresenta 8<br>
possibilidade de avaliação ao final e este número aumenta à medida que o número de variáveis<br>
tambe aumenta<br>
2.2 Verificação de sistemas<br>
No contexto de verificação de sistemas, faz-se necessário a diferenciação entre verificação<br>
e validação. Verificação e validação possuem o intuíto de mostrar que determinado sistema fun-<br>
cione conforme o especificado, além de satisfazer as especificações do cliente (SOMMERVILLE,<br>
2011).<br>
Segundo (SARGENT, 2005), verificação é <span class='f1 c_27' id='c_27_1' href='#c_27_2' cs_f='.c_27' >o processo de</span> determinar se um modelo<br>
computacional obtido por discretização de um modelo matemático de um evento físico e o<br>
código que implementa o modelo computacional pode ser usado para representar o modelo<br>
matemático do evento com precisão suficiente e validação é <span class='f1 c_27' id='c_27_1' href='#c_27_2' cs_f='.c_27' >o processo de</span> determinar se um<br>
modelo matemático de um evento físico representa o evento físico real com precisão suficiente.<br>
A verificação consite identificação de erros e provavéis problemas que um componente<br>
pronto possa apresentar, enquanto a validação busca analisar se tal componete esta seguindo<br>
os requisitos pré-definidos para sua construção (KOSCIANSKI; SOARES, 2007). O teste de<br>
programa, na qual o software é executado com dados de teste é a principal forma de validação,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 20<br>
porém, tecnicas de verificação, tais como, inspeção e revisões também podem integrar a etapa de<br>
validação (SOMMERVILLE, 2011).<br>
2.2.1 Diagrama de decisão binária<br>
Um diagrama de decisão binária(DDB) pode ser definido como um grafo aciclico para<br>
representação de funcões boolenas. Existe uma ordem rigorosa na ocorrência de variáveis à me-<br>
dida que se percorre o grafo da raiz para a folha. Dado como exemplo a formula f=(a?b)?(c?d)<br>
e utilizando a ordenação de variavél a &lt; b &lt; c &lt; d, na Figura 8. Dada a atribuição de valores<br>
booleanos as variaveis a, b, <span class='f1 c_18' id='c_18_1' href='#c_18_2' cs_f='.c_18' >c e d</span>, pode-se decidir se a atribuição torna a fórmula verdadeira<br>
atravessando o início do gráfico na raiz e ramificação em cada nó. Definindo a, <span class='f1 c_18' id='c_18_1' href='#c_18_2' cs_f='.c_18' >c e d</span> = 1 e c = 0<br>
leva a folha de rótulo 1, portanto, a fórmula é verdadeira para essa tarefa (CLARKE et al., 1994).<br>
Figure 8 – Arvore de decisão binária<br>
Fonte: (CLARKE et al., 1994)<br>
Adicionar mais detalhes e descrever onde DDB é utilizado.<br>
O DDB permite o teste eficiente de satisfabilidade, validade e eficiência (KROPF, 2013).<br>
O uso e DDB em conjunto com Model Checking e técnicas de abstração permitiu o aumento na<br>
capacidade de verificação, de modo que sistemas mais realistas podessem ser verificados(??)<br>
2.2.2 Model Checking<br>
Model checking é uma técnica de verificação formal que explora todos os possíveis<br>
estados do sistema, de modo a provar se um modelo satisfaz determinada propriedade. Pode ser<br>
aplicada em uma ampla gama de aplicações, tais como sistema embarcados, design de hardware<br>
e engenharia de software (BAIER et al., 2008).<br>
Entre as vantagens da utilização de Model Checking estão:<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 21<br>
• Possuem suporte a verificação parcial, em outras palavras, a verificação individual de<br>
propriedades, permitido foco primeiro as propriedades essenciais(BAIER et al., 2008).<br>
• Não requer qualquer interação do usuário, nem um alto grau de especialização para <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >o uso<br>
de</span> model checking(BAIER et al., 2008).<br>
• Possui como base a teoria de grafos, estruturas de dados e lógica no desenvolvimento da<br>
solução(BAIER et al., 2008).<br>
• Útil para fins de depuração, pois formece informações em caso de uma propriedade seja<br>
invalidada(BAIER et al., 2008).<br>
Por outro lado, apresenta também algumas desvantagens:<br>
• Sofre do problema de explosão de espaço de estados, ou seja, a quantidade de estados<br>
necessários pode ser maior que a memória disponivel pelo sistema(BAIER et al., 2008).<br>
• Faz a verificação apenas dos requisios declarados, logo, não a garantia de integridade.<br>
Baseado nisso, a validade de propriedades não verificadas não pode ser julgada(BAIER et<br>
al., 2008).<br>
• A verificação de modelos geralmente não é computável, isso deve-se a questões de decidi-<br>
bilidade utilizada (BAIER et al., 2008).<br>
Outras técnicas foram implementadas em conjuntos com Model checkings com o intuito<br>
de aumentas a capacidade de verificação, como a técnica SAT na qual não sofre do problema de<br>
explosão de estados existente usando DDB. A técnica SAT em conjuto com Model Checking é<br>
conhecida como <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >Bounded Model Checking</span> (??).<br>
2.2.3 <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >Bounded Model Checking</span><br>
Segundo ROCHA et al., <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >Bounded Model Checking</span> (BMC) é um tipo especial de Model<br>
Checking que usualmente adota o método de satisfabilidade booleana, o qual tem sido introduzido<br>
como uma técnica complementar para diagrama de decisão binaria para aliviar o problema da<br>
explosão de estados, visto que a técnica de Model Checking busca todos os estados possíveis<br>
para verificação.<br>
<span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >Bounded Model Checking</span> é uma técnica para a verificação de uma dada propriedade<br>
em uma determinada profundidade do sistema analisado. Logo, dado <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >um sistema de</span> transições<br>
M, uma propriedade ?, e um limite (bound) k, o BMC desenrola o sistema k vezes e traduz o<br>
sistema em uma condição de verificação(CV) ? tal que ? é satisfeito se e somente se ? tem um<br>
contra-exemplo de profundidade menor ou igual a k (ROCHA et al., 2015b).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 22<br>
O Extended SMT-Based Bounded Model Checker (ESBMC) é um <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >Bounded Model<br>
Checking</span> baseado em satisfabilidade booleana (SAT) que permite verificação aritmética de Já tem<br>
su-<br>
porte<br>
a<br>
SMT<br>
adi-<br>
cionar<br>
ao<br>
texto<br>
overflow e undeflow, segurança de ponteiros, limite de array, de gerar propriedades de segurança<br>
em programas em C/C++. ESBMC utiliza uma versão modificada do CBMC no front-end para<br>
analisar o código ANSI-C e para gerar as condições de verificação através de execução simbólica<br>
(CORDEIRO et al., 2012; ROCHA et al., 2015b).<br>
No ESBMC, o programa analisado é modelado em <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >um sistema de</span> transição de estados,<br>
conforme a trupla: M = (S,R, S0), o qual é gerado um grafo <span class='f1 c_19' id='c_19_1' href='#c_19_2' cs_f='.c_19' >de controle de</span> fluxo (GFC), onde<br>
S representa o conjunto de estados, R ? SxS representa as transições e S ? S representa<br>
o conjuto de estados iniciais. Um estado s ? S consiste no valor do contador de programa<br>
(PC) e os valores de todas as variáveis dos programas. O estado inicial S0 atribui o inicio do<br>
programa GFC ao PC, desta forma o ESBMC identifica as transições, conforme a formula lógica,<br>
?=(Si,Si+1) que captura as retrições sobre os valores correspondntes do PC e das variáveis do<br>
programa (CORDEIRO et al., 2012).<br>
Segundo o site do ESBMC(??), a ferramenta permite ao usuário indicar propriedades<br>
adicionaisusando assertivas que também são verificadas. O ESBMC converte as condições Descrever<br>
quais<br>
pro-<br>
priedades<br>
o<br>
esbmc<br>
su-<br>
porta<br>
usando diferentes técnicas de backgroundpara posteriormente passar para verificador SMT. Outra<br>
apresentar<br>
exem-<br>
plo<br>
vantagem é a ferramenta permitir verificação de software single-thread e multi-thread.<br>
Descrever qual a razão da escolha para o trabalho, apresentar resultados do SV-COMP<br>
dos últimos 3 anos<br>
2.2.4 Redes de petri<br>
Apresentar definição formal para RP<br>
corrigir o texto abaixo RP não é uma ferramenta e sim um método de modelagem<br>
Redes de petri são utilizadas como ferramentas de modelagem gráfica com propriedades<br>
matemática. Como ferramenta gráfica são utilizadas como comunicação visual, como fluxogra-<br>
mas, por exemplo, e como ferramenta matemática podem configurar modelos matemáticos que<br>
regem o comportamento dos sistemas. A grade premissa desta ferramenta é descrever sistemas<br>
de processamento de informações caracterizados como concorrentes, assíncronos, distribuídos,<br>
paralelos, não deterministas e/ou estocásticos (MURATA, 1989).<br>
As redes de petri são representados como grafos direcionais compostos por nós e arcos,<br>
conforme apresentado na Figura 9. Os nós representam as transições e eventos e os arcos<br>
representam os pesos. Dentro desta representação, os arcos e eventos são componentes passivos<br>
enquanto as transições são ativos. A principal vantagem da utilização das redes de petri esta<br>
relacionado ao chamado "Token game" que consiste no comportamento da rede de petri, em<br>
outras palavras, representa o funcionamento do sistema representado pela rede(HALDER;<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 23<br>
VENKATESWARLU, 2006).<br>
Figure 9 – Rede de petri<br>
Fonte: (HALDER; VENKATESWARLU, 2006)<br>
Descrever o funcionamento da RP apresentado na IMG<br>
Descrever quais propriedades podem ser verificadas com RP e onde será utilizado no seu<br>
trabalho.<br>
2.2.5 Verificação de hardware<br>
Para a verificação de hardware diversas técnicas têm sido propostas (). <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >Por meio da</span> Apresentar<br>
exem-<br>
plos<br>
com<br>
refer-<br>
ências<br>
simulação, visa assegurar que uma implemetação, descrição do hardware em qualquer qualquer<br>
nível de abstração da hierarquia de hardware, atinja suas especificações, propriedades que devem<br>
ser respeitadas para que a corretude do mesmo seja comprovada (GUPTA, 1992). A Verificação<br>
formal de hardware consiste na utilização de técnicas para corretude de circuitos lógicos, ou<br>
seja, consiste na utilização de modelos matemáticos para descrição de propriedade e/ou de<br>
comportamento de um dado sistema (KROPF, 2013).<br>
Entre as abordagens utilizadas na verificação formal de hardware consiste tanto na imple-<br>
mentação quanto a especificação estarem descritas em lógica formal, neste caso a corretude será<br>
obtida através da comprovada relação entre a implementação e a especificação (SEGER, 1992).<br>
A especificação formal consiste na descrição do comportamento, bem como, das propriedades<br>
do sistema em linguagem matemática, tornando-se crucial para <span class='f1 c_27' id='c_27_1' href='#c_27_2' cs_f='.c_27' >o processo de</span> verificação. Na<br>
implementação formal, o nível de abstração, tais como, Gate level e RTL são importantes infor-<br>
mações <span class='f1 c_34' id='c_34_1' href='#c_34_2' cs_f='.c_34' >para o desenvolvimento</span> do formalismo, bem como as classes, por exemplo se o circuito<br>
é sequencial ou combinacional, se utiliza pipeline, etc (KROPF, 2013).<br>
Apresentar um exemplo de RTL<br>
A utilização de Model Checking também se faz presente nos modelos formais de ver-<br>
ificação de hardware, onde apenas é utilizado o comportamento dos circuitos na verificação,<br>
de modo a verificar a se as propriedades presentes são satisfeitas. Para isso, são utilizados os<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 24<br>
conceitos da lógica proposicional, que <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >por meio da</span> utilização de fórmulas que representem as<br>
propriedades dos estados, é possível realizar as verificações necessárias (SEGER, 1992).<br>
Apresentar um exemplo com um circuito e como este pode ser verificando com model<br>
checking<br>
2.2.6 Verificação formal de software<br>
Observa-se que <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >o uso de</span> verificacão de software tem sido feito aplicado em muitas áreas,<br>
tais como, infraestruturas industriais de missão critica e de segurança. Logo, existe a necessidade<br>
de garantir a corretude destes sistemas. Devido a isso, a verificação formal tem sido utilizada em<br>
três principais abordagens, sendo elas (COUSOT; COUSOT, 2010; D’SILVA et al., 2008):<br>
Apresentar exemplos para os métodos apresentados abaixo<br>
• Métodos dedutivos: Produzem provas matemáticas formais de corretude usando provadores<br>
de teoremas ou assistentes de prova para execução da prova e necessitam da interação<br>
humana para prover os argumentos (COUSOT; COUSOT, 2010);<br>
• Verificação de modelos: Exploram exaustivamente modelos de execuções de programa,<br>
que podem ser sujeitos a explosão combinatória, necessário a intervenção humana para<br>
geração dos modelos (ROCHA et al., 2015b);<br>
• Analise estática: Engloba diversas técnicas para calcular automaticamente informações<br>
sobre o comportamento de um programa sem executá-lo, sendo utilizado em otimização<br>
de código e verificação em compiladres (D’SILVA et al., 2008).<br>
Segundo ROCHA et al., na verificação formal de software apresentam-se dificuldades,<br>
tais como: quais as propriedades são de interesse na verificação em tempo de execução; e<br>
impossibilidade matemática de provar a corretude de propriedades não triviais no comportamento<br>
de programas (COUSOT; COUSOT, 2010).<br>
2.2.7 Lógica proposicional<br>
A lógica proposicional é uma linguagem formal onde é definida um alfabeto e conectivos<br>
proposicionais, e um conjunto de regras gramaticais, as quais serão utilizadas para construção<br>
das proposições (SOUZA, 2017). Porém apesar de importante, ela é limitada, não podendo<br>
expressar sentenças elementares importantes, tais como a da aritmética elementar. Por exemplo:<br>
1. Todos são mortais.<br>
2. Alguém é bondoso.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 25<br>
Na lógica preposicional, não poderiam ser analisadas, pois não teria como decompor<br>
ambas em sentença e assim não teria como analisar as diferenças entre ambas(ABE, 2002).<br>
Contudo, no exemplo: Existem cavalos com patas verdes. A relação criada pela frase poderia a<br>
ser analisada pela lógica proposicional(ABE, 2002). Descrever<br>
como<br>
seria<br>
está<br>
analise<br>
Segundo SOUZA, alfabeto da lógica proposicional é formado por símbolo de pontuação,<br>
símbolos proposicionais e conectivos proposicionais, onde cada um apresenta uma função em<br>
específico, sendo:<br>
• Símbolos de pontuação: Apenas dois símbolos de pontuação são utilizados o "(" e o ")".<br>
• Símbolos proposicionais: São utilizados para representar as proposições, onde um sím-<br>
bolo P pode ser utilizado para representar uma proposição qualquer, por exemplo: P="Está<br>
chovendo". O conjunto de símbolos proposicionais é infinito e enumerável, sendo possível<br>
representar infinitos e enumerável conjunto de proposições.<br>
• Conectivos proposicionais: São os símbolos usando frequentemente na matemática. Os<br>
símbolos recebem a seguinte denominação:<br>
1. ¬: Representa a partícula de negação, ou seja, "Não".<br>
2. ?: Representa a partícula "Ou"<br>
3. ?: Representa a partícula "E"<br>
4. ?: Representa a partícula "Se então ou implica".<br>
5. ?: Representa a partícula "Se, e somente se".<br>
Ainda segundo SOUZA, existem as fórmulas que são constituídas de forma indutiva, <span class='f1 c_40' id='c_40_1' href='#c_40_2' cs_f='.c_40' >a<br>
partir de</span> símbolos do alfabeto conforme as regras apresentadas abaixo:<br>
• Todo o símbolo preposicional é uma fórmula<br>
• Se H é uma fórmula, então (¬H), a negação de H, é uma fórmula.<br>
• Se H e G são fórmulas, então a disjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a conjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o antecedente e G consequente da fórmula.<br>
• Se H e G são fórmulas, então a bi-implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o lado esquerdo e G o lado direito da fórmula.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 26<br>
2.2.8 Linguagem de especificação de propriedades<br>
Linguagem de especificação de propriedades, do inglês Property Specification Language<br>
- PSL, é uma notação formal para especificação de comportamento em sistemas eletrônicos,<br>
compatível com as linguagens VHDL, Verilog, SystemC e SystemVerilog. Destina-se a utilização Adicionar<br>
refer-<br>
ência<br>
a cada<br>
Ling<br>
citada<br>
para a especificação funcional, mas também para entrada de ferramentas de verificação. A<br>
especificação do PSL é a utilização de assertivas sobre propriedades <span class='f1 c_31' id='c_31_1' href='#c_31_2' cs_f='.c_31' >de um sistema</span>, sendo estas<br>
propriedades constituídas de três elementos: expressões boolenas, expressões sequenciais e<br>
operadores temporais (IEEE. . . , 2010).<br>
Corrigir a apresentação da citação IEEE... estranho<br>
Segundo (IEEE. . . , 2010), o PSL foi totalmente desenvolvida com o intuito fornecer<br>
leitura e escrita de fácil entendimento, sintaxe concisa, semântica formal e rigorosamente bem<br>
definida e ser matematicamente precisa, visto a utilização da mesma em processo de verificação.<br>
O PSL pode ser utilizado para capturar requisitos relativos ao comportamento total do projeto,<br>
bem como, sobre o modo que o mesmo deverá operar no ambiente, ms também para capturar<br>
requisitos comportamentais e os pressupostos que surgem <span class='f1 c_45' id='c_45_1' href='#c_45_2' cs_f='.c_45' >durante o processo de</span> design. Ambas<br>
podem ser utilizadas para verificação de sistemas.<br>
Apresentar exemplos de uso da PSL<br>
2.2.9 Verificação baseada em assertivas<br>
Verificação baseada em assertivas, do inglês Assertion-Based Verification - ABV, é um<br>
paradigma de verificação igualente adequado para verificação formal e abordagens baseadas em<br>
simulação (BOULE; ZILIC, 2005) e em conjunto com a tecnica de PSL tem ganhado aceitação<br>
como um método essencial para verificação funcional do hardware (DAHAN et al., 2005).<br>
Na ABV as assertivas são declaração adicionadas ao projeto com o intuito de especificar<br>
o comportamento do projeto (BOULE; ZILIC, 2005), podendo escritos em PSL ou em SVA<br>
(System Verilog Assertions). No caso deste projeto será utilizado a PSL, devido a mesma ser<br>
utilizada juntamente com a linguagem VHDL.<br>
Com a utilização de ABV o circuito pode ser verificado usando técnicas de simulação<br>
e/ou verificação, por exemplo, model checking, para garantir que o mesmo esteja <span class='f1 c_30' id='c_30_1' href='#c_30_2' cs_f='.c_30' >de acordo<br>
com o</span> pretendido projeto (DAHAN et al., 2005). Na Figura 19 apresenta o modelo de assertiva<br>
utilizada no projeto, utilizando de um modelo próprio para assertivas, unindo as funcionalidades<br>
já existentes nas assertivas do VHDL, mas também novas (serão apresentadas nas próximas<br>
seções), fornecendo assim mais propriedades a serem analisadas.<br>
Descrever qual o objetivo da assert apresentado<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 27<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 e n t i t y AND_ent i s<br>
5 p o r t ( x , y : i n b i t ;<br>
6 F : o u t b i t<br>
7 ) ;<br>
8 end AND_ent ;<br>
9<br>
10 a r c h i t e c t u r e behav1 of AND_ent i s<br>
11 b e g i n<br>
12 ??@c2vhdl : ASSERT<br>
13 ??a s s e r t n o t ( x= ’ 0 ’ and y= ’ 1 ’ )<br>
14 ?? r e p o r t " Both v a l u e s o f s i g n a l s x and y a r e e q u a l t o 1 "<br>
15 ??s e v e r i t y ERROR;<br>
16 ??@c2vhdl :END<br>
17<br>
18 p r o c e s s ( x , y )<br>
19 b e g i n<br>
20 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
21 F &lt;= ’ 1 ’ ;<br>
22 e l s e<br>
23 F &lt;= ’ 0 ’ ;<br>
24 end i f ;<br>
25 end p r o c e s s ; 4<br>
26 end behav1 ;<br>
Fonte: Própria.<br>
2.2.10 Propriedades de segurança<br>
Propriedades de segurança é um meio de validação do comportamento de um determinado<br>
sistema, de modo que se uma dada propriedade de segurança for violada, então através de<br>
uma execução finita, é possível verificar tal erro. Algumas propriedades de segurança, no<br>
entanto, podem impor requisitos em fragmentos de caminho finito e não podem ser verificadas<br>
considerando apenas os estados alcançáveis. (BAIER et al., 2008).<br>
Segundo (CLARKE et al., 2003), podemos definir uma propriedade de segurança como:<br>
dado <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >um sistema de</span> transições ST = (S, S0, E), seja um conjunto B ? S que especifica um<br>
conjunto de maus estados tais que S0 ?B = ?, pode-se dizer que ST é seguro com relação a B,<br>
denotado por ST |= AG¬B se não existe um caminho no sistema de transição do estado inicial<br>
S0 até o estado B, de outro modo é dito que ST não é seguro.<br>
Adicionar exemplos de propriedades de segurança em hardware<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 28<br>
2.3 Técnicas de compiladores<br>
Compiladores são sistemas de software utilizados para tradução de uma linguagem de<br>
programação para outra, ou seja, o programa da linguagem fonte é lido e traduzido para um<br>
código equivalente na outra linguagem, ou linguagem alvo. Geralmente utilizada para transformar<br>
trechos de código em uma linguagem a ser executada pelo computador (AHO et al., 2007).<br>
Diversas técnicas podem ser utilizadas nas diversas etapas, até que o código seja traduzido,<br>
tais como LL(1) e LR na análise sintática; eliminação de código morto; propagação de constante<br>
e Peephole na otimização de código(AHO et al., 2007). Neste projeto serão focados as áreas de<br>
transformações de código e otimização de código.<br>
2.3.1 Transformações de código<br>
Transformações de código correspondem a uma complexa função que envolve analise de<br>
fluxo de dados e modificação completa do programa que são parte integral da alta performance e<br>
sistemas computacionais. Podem ser classificados em transformações escalares que reduzem<br>
o número de instruções a serem executadas no programa ou transformações paralelas que<br>
maximizam o paralelismo (SRIKANT; SHANKAR, 2002).<br>
A Figura 11 representa o trecho de código apresentado na Figura 19. O trecho representa<br>
o comportamento das entradas, neste caso de um código da porta AND. E a figura Figura 12<br>
representa a tradução deste trecho em código na linguagem C. Esta tradução foi realizada pela<br>
ferramenta V2C, utilizada neste projeto. Adicionar<br>
refer-<br>
ência<br>
Figure 11 – Trecho de código em VHDL representando porta AND.<br>
1 p r o c e s s ( x , y )<br>
2 b e g i n<br>
3 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
4 F &lt;= ’ 1 ’ ;<br>
5 e l s e<br>
6 F &lt;= ’ 0 ’ ;<br>
7 end i f ;<br>
8 end p r o c e s s ;<br>
Fonte: Própria.<br>
Expandir esta seção. Apresentar propriedades de transformação e técnicas para avaliar a<br>
transformação<br>
2.3.2 Otimização de código<br>
A otimização de código consiste na melhoria do código intermediário gerado pelos<br>
algoritmos de compilação com o objetivo de obter um menor tempo de execução do programa,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 29<br>
Figure 12 – Trecho de código traduzido para linguagem C.<br>
1 /? S t a r t o f T r a n s l a t i o n ? /<br>
2 /? p0 : ? /<br>
3 i f ( chg [ x ] | | chg [ y ] ) {<br>
4 i f ( ( ( o l d [ x ]==1) && ( o l d [ y ]==1) ) ) {<br>
5 new [ f ] = 1 ;<br>
6 }<br>
7 e l s e {<br>
8 new [ f ] = 0 ;<br>
9 }<br>
10 }<br>
11 /? End o f T r a n s l a t i o n ? /<br>
Fonte: Própria.<br>
porém outros fatores podem ser introduzidos, como algoritmos menores. Este fato não implica<br>
em afirmar que o melhor código é gerado, visto que dada a complexidade, raramente pode ser<br>
obtido que o código gerado pode ser o melhor possível (AHO et al., 2007).<br>
Segundo AHO et al., otimização local de código consiste na otimização de um bloco<br>
básico de código, ou seja, a otimização ocorre em um trecho especifico de código. Os blocos<br>
básicos são trecho onde não ocorrem saltos ou loops, para nenhuma outra parte do código. A<br>
otimização global de código é baseado na analise do fluxo de dados, de modo que ocorra as<br>
elminação de instruções não necessárias ou substituição mais facil. A otimização global consite<br>
na analise completa do código. Neste sentido, nas próximas seções serão apresentadas algumas<br>
importantes técnicas de otimizações.<br>
2.3.2.1 Grafo Acliclico Direcional - GAD<br>
Grafo Aciclico Direcional é utilizado para diversos fins dentro da estrutura de compi-<br>
ladores, principalmente para geração da parse tree otimização de código. Pode ser usado na<br>
representação de instruções unicas blocos básicos de código(AHO et al., 2007). <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >O uso de</span> GAD<br>
permite a melhoria de de código, tais como:<br>
• Elminação de subexpressões locais comuns, ou seja, expressões que o valor já foi com-<br>
putado anteriomente;<br>
• Eliminação de código morto;<br>
• Reordernamento de declarações buscando reduzir o tempo que o valor temporário necessita<br>
ser preservado em um registro;<br>
A Figura 13 apresenta um bloco básico com algumas instruções, no caso apresentando<br>
são 4 operações entre somas e multiplicação e a partir deste bloco a Figura 14 apresenta o GDA<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 30<br>
Figure 13 – Exemplo de bloco basico de código.<br>
1 a = b + c<br>
2 b = a ? d<br>
3 c = b + c<br>
4 d = a ? d<br>
Fonte: (AHO et al., 2007)<br>
Figure 14 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
deste trecho de código. Nele apresenta cada nó como uma operação especifica e os terminais<br>
como as parcelas das operações.<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC<br>
Grafo de fluxo de controle corresponde a um grafo direcionado, no qual cada nó rep-<br>
resenta blocos básicos e cada aresta representa os caminhos de fluxo entre os blocos basi-<br>
cos (ALLEN, 1970). É importante ressaltar que saltos determinam o final de um determinado<br>
bloco básico, ou seja, saltos indicam um caminho para uma nova região de código básico (AHO<br>
et al., 2007).<br>
Apresentar um exemplo de como e utilizado em código<br>
2.3.2.3 Eliminção de código morto<br>
A eliminacação de código morto é uma técnica que busca a eficiência de um programa<br>
evitando a execução de instruções não necessária em tempo de execução (KNOOP et al., 1994).<br>
O código morto consiste em instruções que não serão alcançáveis durante o fluxo do programa,<br>
sendo esta técnica basicamente a retirada de qualquer variável que não será utilizada em qualquer<br>
outro nó do grafo (AHO et al., 2007).<br>
A utilização de GAD corresponde na eliminação de qualquer nó raiz, ou seja, nó sem<br>
ancestrais, as quais não esteja ativa anexada a mesma. A execução repetida desta operação<br>
removerá todos os nós correspondentes a código morto (AHO et al., 2007).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 31<br>
Figure 15 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
Na Figura 15, supondo que os nós a, b e c estejam ativa, porém o nó énão esteja, o último Corrigir<br>
nó é?pode ser eliminado imediatamente. Os nós restantes continuam no GDA, a menos que não tenho<br>
variáveis ativas atreladas aos nós (AHO et al., 2007).<br>
2.3.2.4 Análise do fluxo de dados<br>
Análise de fluxo de dados refere-se ao conjunto de técnicas que derivam informações<br>
sobre o fluxo de dados ao longo dos caminhos de execução do programa. Para análise do<br>
programa, é necessário considerar todas as posiveis execuções através do grafo de fluxo de<br>
controle (AHO et al., 2007).<br>
Apresentar exemplos<br>
2.3.2.5 Gerador de código<br>
O gerador de código é responsavél pela tradução final do programa-fonte <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >para o programa</span>-<br>
alvo, o mesmo recebe como entrada um código intermediário juntamente com a tabela de<br>
símbolos. Faz-se necessário que o programa-fonte tenha sido analisado sintatica e lexicamente,<br>
assim evitando que erros possam ser passados <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >para o programa</span>-alvo, por outro lado a existência<br>
de uma nível de otimização, faz-se opicional neste caso (AHO et al., 2007).<br>
O gerador de código possui três tarefas primarias, sendo as mesmas seleção de instrução,<br>
alocação de registros e atribuições. A seleção de instruções envolve a escolha das instruções<br>
apropriadas da máquina-alvo para implementar as declarações do código intermediario. A<br>
atribuição e atribuição de registros envolve a decisão sobre os valores a serem registrados nos<br>
registros(AHO et al., 2007).<br>
Apresentar exemplo<br>
32<br>
3 TRABALHOS CORRELATOS<br>
Sugiro apenas mencionar que foi feito a revisão sistemática; o que já foi feito e os resul-<br>
tados. As outras seções sobre RS e mover para apêndice.<br>
3.1 Revisão sistemática<br>
A revisão sistemática consiste é um método de identificação, análise e interpretação de<br>
pesquisas relevantes em determinada área ou questão de pesquisa. Para execução da revisão sis-<br>
temática se requer um esforço maior, em comparação as pesquisas tradicionais, sendo necessário<br>
seguir uma sequência de passos metodológicos sobre a área ou questão de pesquisa ao qual<br>
deseja ser feita a pesquisa (KITCHENHAM, 2004).<br>
Para a execução da revisão sistemática, é necessário um esforço considerável, se com-<br>
parado a uma revisão informal a literatura. Enquanto que a revisão de literatura informal é<br>
conduzida de forma ad-hoc, sem planejamento e critérios de seleção estabelecidos a priori,<br>
a revisão sistemática requer um protocolo formal bem definido, com uma sequência de pas-<br>
sos metodológicos, para conduzir uma pesquisa sobre o tema ao qual deseja-se realizar a<br>
pesquisa (MAFRA; TRAVASSOS, 2006).<br>
A aplicação da revisão sistemática requer que seja seguido um conjunto bem definido e<br>
sequêncial de passos, seguindo um protocolo de pesquisa desenvolvido previamente. Através<br>
deste método é possível realizar uma extensa pesquisa, contemplando uma grande quantidade<br>
de informações sobre o assunto pesquisado (MAFRA; TRAVASSOS, 2006). Este protocolo é<br>
construído considerando um tema específico que representa o elemento central da investigação,<br>
onde os passos da pesquisa, as estratégias definidas para coletar as evidências e o foco das<br>
questões de pesquisa são definidas explicitamente, de tal forma que outros pesquisadores sejam<br>
capazes de reproduzir o mesmo protocolo de pesquisa (BIOLCHINI et al., 2005).<br>
Segundo MAFRA; TRAVASSOS, o processo para a condução de revisões sistemáticas<br>
envolve três etapas:<br>
1. Planejamento da Revisão: os objetivos da pesquisa são listados e o protocolo da revisão<br>
é definido.<br>
2. Condução da Revisão:nesta atividade, as fontes para a revisão sistemática são sele-<br>
cionadas, os estudos primários são identificados, selecionados e avaliados <span class='f1 c_30' id='c_30_1' href='#c_30_2' cs_f='.c_30' >de acordo com</span><br>
os critérios de inclusão, exclusão, e de qualidade estabelecidos durante o protocolo da<br>
revisão.<br>
Chapter 3. TRABALHOS CORRELATOS 33<br>
3. Análise dos Resultados: os dados dos estudos são extraídos e sintetizados para análise e<br>
apresentação dos resultados.<br>
Vale ressaltar que como o objetivo deste trabalho é realizar um estudo exploratório de<br>
caracterização de área podemos dizer que esta revisão sistemática se caracteriza como uma quasi-<br>
sistemática (TRAVASSOS et al., 2008), pois segue o mesmo processo da revisão sistemática e<br>
preserva o rigor e mesmo formalismo para as fases metodológicas de elaboração de protocolo e<br>
execução da revisão, mas sem a aplicação de uma meta-análise a princípio, que pode ser aplicada<br>
posteriormente.<br>
3.1.1 Planejamento da Revisão Sistemática<br>
Objetivo: Este estudo tem o objetivo esquematizado <span class='f1 c_42' id='c_42_1' href='#c_42_2' cs_f='.c_42' >a partir da</span> estrutura do paradigma<br>
GQM (do ingles Goal,Question and Metric)(BASILI et al., 1994).<br>
Analisar Publicações científicas através de um estudo baseado em revisão sis-<br>
temática<br>
Com propósito de Identifica-las<br>
Com relação as Vantagens e desvantagens da utilização de assertiva e transformações<br>
de código na verificação do código na linguagem de descrição VHDL<br>
Do ponto de vista do Pesquisador<br>
No contexto Acadêmico ou industrial para verificação de assertivas na linguagem<br>
de descrição VHDL<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM<br>
Formulação da Pergunta: Buscamos respostas para as seguintes perguntas:<br>
• Q1: Quais são os métodos para verificação de circuitos lógicos descritos na linguagem de<br>
programação VHDL?<br>
– Q1.1: Foi desenvolvido e está disponível alguma ferramenta para aplicação do<br>
método?<br>
– Q1.2: Qual a técnica de exploração de estados para circuitos lógicos?<br>
– Q1.3: O método proposto é baseado em técnicas de verificação de software?<br>
– Q1.4: Como o método proposto valida pré e pós condições no programa?<br>
– Q1.3: Foi utilizado algum benchmark de programas em VHDL para experimentação<br>
e o mesmo encontra-se disponível?<br>
– Q1.4: Quais as perspectivas futuras para melhorar da aplicação do método proposto?<br>
Escopo da pesquisa:Na delimitação do escopo da pesquisa foram estabelecidos critérios,<br>
buscando garantir a viabilidade da execução, acessibilidade dos dados e abrangência do estudo re-<br>
alizado. A pesquisa dar-se-á <span class='f1 c_40' id='c_40_1' href='#c_40_2' cs_f='.c_40' >a partir de</span> bibliotecas digitais através das suas respectivas máquinas<br>
Chapter 3. TRABALHOS CORRELATOS 34<br>
de busca e, quando os dados não estiverem disponíveis eletronicamente, através de consultas<br>
manuais.<br>
Critérios de Seleção de Fontes. Para as bibliotecas digitais é desejado:<br>
• Possuir uma máquina de busca que permita <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >o uso de</span> expressões lógicas ou mecanismo<br>
equivalente.<br>
• Incluir em sua base, publicações de exatas ou correlatas que possuam relação direta com o<br>
tema a ser pesquisado<br>
• As máquinas de busca deverão permitir a busca no texto completo das publicações.<br>
Segundo ROCHA et al., os mecanismos de busca utilizados devem garantir resultados<br>
únicos através da busca de um mesmo conjunto de palavras-chaves (string de busca). Quando<br>
isto não for possível, deve-se estudar e documentar uma forma de minimizar os potenciais efeitos<br>
colaterais desta limitação.<br>
Métodos de Busca das Publicações. As fontes digitais foram acessadas via Web, através<br>
de expressões de busca pré-estabelecidas. A biblioteca digital consultada foi a Scopus, acessível<br>
em http://www.scopus.com. Segundo a editora ELSEVIER, a Scopus é uma das maiores bases<br>
de dados de resumos e citações da literatura de pesquisa peer-reviewed com mais de 22, 800<br>
títulos de mais de 5, 000 editoras internacionais abrangendo as áreas de tecnologia, medicina,<br>
artes, ciências sócias e com atualizações diárias. Entre as editoras podemos citar: Springer<br>
(SPRINGER, 2018); IEEE Xplore Digital Library (IEEE, 2018);ACM Digital Library (ACM,<br>
2018) ; ScienceDirect/Elsevier (B.V, 2018); Wiley Online Library (SONS, 2018); dentre outras.<br>
String de Busca. A string de busca foi definida segundo o padrão PICO (do inglês<br>
Population, Intervention, Comparison, Outcomes) (KITCHENHAM et al., 2009), conforme a<br>
estrutura abaixo:<br>
• População: Trabalhos publicados em conferências e periódicos que relacionam verificação<br>
de propriedades de circuitos lógicos em códigos para a descrição de hardware.<br>
• Intervenção: Verificação de propriedades relacionadas a verificação de circuitos para as<br>
diferentes estruturas das linguagens de descrição de hardware;<br>
• Comparação: análise de cobertura e suporte das abordagens identificadas para a verificação<br>
de propriedades das linguagens de descrição de hardware;<br>
• Resultados: <span class='f1 c_42' id='c_42_1' href='#c_42_2' cs_f='.c_42' >a partir da</span> descrição das abordagens pretende-se verificar a cobertura que cada<br>
abordagem apresenta na manipulação das diferentes estruturas da linguagem de descrição<br>
de hardware para a verificação de propriedades baseada em assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 35<br>
Segundo ROCHA et al., como este estudo representa <span class='f1 c_6' id='c_6_1' href='#c_6_2' cs_f='.c_6' >um estudo de</span> mapeamento/caracteri-<br>
zação, a string de busca foi definida <span class='f1 c_30' id='c_30_1' href='#c_30_2' cs_f='.c_30' >de acordo com</span> dois aspectos: População e Intervenção, como<br>
é apresentado na estrutura abaixo. Posteriormente esta mesma string de busca será executada<br>
na biblioteca Scopus para busca de artigos e publicações de modo a gerar uma interseção entre<br>
população e intervenção.<br>
• População: publicações que fazem referência a verificação de propriedades de circuitos<br>
lógicos e sinônimos:<br>
– Palavras-chaves: "circuit checker" OR "circuit verification" OR "contract based<br>
verification" OR "code analysis" OR "static analysis" OR "dynamic analysis" OR<br>
"safety verification" OR "RTL analysis" OR "program analysis" OR "property veri-<br>
fication" OR "formal verification" OR "model checking" OR "model checker" OR<br>
"hardware checker" OR "hardware verification" OR "validity checker" OR "hard-<br>
ware assertion" OR "assertion checker" OR "assert verification" OR "assertion-based<br>
verification" OR "assertion based verification" OR "assertion-based design" OR "bit<br>
level verification"<br>
• Intervenção: Verificação de circuitos e sinônimos:<br>
– Palavras-chaves:"hardware statement" OR "hardware code" OR "hardware source<br>
code" OR "hardware semantics" OR "hardware property" OR "logical gates" OR<br>
"sequential circuit" OR "parallel circuit" OR "real circuits" OR "complex circuits"<br>
OR "control circuitry" OR ”software netlist” OR “hardware emulation” OR “silicon<br>
debug”<br>
3.1.1.1 Procedimentos de Seleção e Critérios<br>
A estratégia de busca será aplicada por um pesquisador para identificar as publicações<br>
em potencial. A seleção das publicações dar-se-á em 2 etapas, conforme apresentado a seguir.<br>
1. Seleção e catalogação preliminar dos dados coletados: A seleção preliminar das publi-<br>
cações será feita <span class='f1 c_42' id='c_42_1' href='#c_42_2' cs_f='.c_42' >a partir da</span> aplicação da string de busca na biblioteca Scopus, o resultado<br>
desta busca corresponde a seleção preliminar. Todas as publicações serão armazenadas<br>
para análise posterior;<br>
2. Seleção dos dados relevantes - [1 filtro]: A seleção preliminar com <span class='f1 c_24' id='c_24_1' href='#c_24_2' cs_f='.c_24' >o uso da</span> expressão<br>
de busca não garante que todo o material coletado seja útil no contexto da pesquisa, pois a<br>
aplicação das expressões de busca é restrita ao aspecto sintático. Por isso, é necessário a<br>
criação de filtros de exclusão e inclusão, de modo a classificar os artigos e publicações que<br>
se enquadram no contexto da pesquisa realizada. Nesta epata apenas serão lidos o título,<br>
abstracts, e palavras-chaves e classificar <span class='f1 c_30' id='c_30_1' href='#c_30_2' cs_f='.c_30' >de acordo com</span> os filtros, ou seja, se será aceito ou<br>
excluído. Devem ser excluídas as publicações contidas no conjunto preliminar que:<br>
Chapter 3. TRABALHOS CORRELATOS 36<br>
• CE1-01: Não serão selecionadas publicações em que as palavras-chave da busca<br>
não apareçam no título, resumo e/ou texto da publicação (excluem-se os seguintes<br>
campos: as seções de agradecimentos, biografia dos autores, referências bibliográficas<br>
e anexas).<br>
• CE1-02: Não serão selecionadas publicações em que descrevam e/ou apresentam<br>
‘keynote speeches’, tutoriais, cursos e similares.<br>
• CE1-03: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação/validação de códigos para descrição de hardware.<br>
• CE1-04: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação de código de descrição de hardware baseado em assertivas ou propriedades<br>
de verificação de hardware.<br>
Podem ser incluídas apenas as publicações contidas no conjunto preliminar que:<br>
• CI1-01:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita uma abordagem para verificação<br>
de código de descrição de hardware baseado em assertivas ou propriedades de<br>
verificação de hardware.<br>
• CI1-02:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita recomendações de melhoria<br>
na utilização de abordagens para verificação de código de descrição de hardware<br>
baseado em assertivas ou propriedades de verificação de hardware.<br>
3. Seleção dos dados relevantes - [2 filtro]: Apesar do 1o filtro limitar o universo de busca,<br>
infelizmente não há garantias de que todo material selecionado no filtro anterior seja útil<br>
no contexto da pesquisa. Neste caso, novos filtros são gerados, buscando, da mesma forma<br>
que o primeiro filtro, classificar os artigos e publicações que se enquadram no contexto<br>
da pesquisa. Para este filtro é necessário a leitura na integras dos artigos selecionados<br>
anteriormente. O objetivo é identificar que relacionam assertivas e/ou propriedade de<br>
verificação de hardware.<br>
• CS2 -ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware e não citam assertivas<br>
• CS2 +ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware, mas citam assertivas<br>
• CS2 -ASS +VER_HARD: Não devem ser selecionadas publicações que contextual-<br>
izam verificação de hardware, mas citam assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 37<br>
Dessa forma, todas as publicações devem respeitar o critério abaixo:<br>
• CS3 +ASS +VER_HARD: Serão selecionadas publicações que contextualizam<br>
verificação de hardware e citam assertivas em seu contexto.<br>
Devido ao tempo necessário <span class='f1 c_34' id='c_34_1' href='#c_34_2' cs_f='.c_34' >para o desenvolvimento</span> execução dos filtros da revisão<br>
sistemática serem extensos, apenas o primeiro filtro foi executado neste projeto, mesmo que<br>
os parâmetros para o segundo filtro já tenho sido desenvolvidos. Em contra partida foram<br>
selecionados 6 artigos que serviram como ferramentas de estudo <span class='f1 c_34' id='c_34_1' href='#c_34_2' cs_f='.c_34' >para o desenvolvimento</span> da<br>
metodologia que será apesentada no Capítulo 4.<br>
3.2 Revisão da literatura<br>
Nesta sessão serão apresentados trabalho relevantes <span class='f1 c_34' id='c_34_1' href='#c_34_2' cs_f='.c_34' >para o desenvolvimento</span> do método<br>
proposto que foram identificados utlizando a revisão sistemática mencionado anteriormente.<br>
Os artigos apresentam técnicas de transformações de código, utilização de Assertion-Based<br>
Verification e PSL para verificação de hardware.<br>
3.2.1 V2c-A verilog to C translator<br>
O artigo de MUKHERJEE et al. apresenta uma ferramenta implementada em C++<br>
chamada v2c para transformação de código da linguagem de descrição Verilog para linguagem<br>
de programação C. A ferramenta é executada a nível de palavra, visto que esta abordagem garante<br>
uma aumento na escalabilidade, mas também proporionando que técnicas, como interpolaçãoe adicionar<br>
refer-<br>
ência<br>
aceleração de looppossam ser utilizadas para verificação, algo inviavél, caso a tradução fosse<br>
adicionar<br>
refer-<br>
ência<br>
executada a nível de bit. O sistema recebe como entrada um código em Verilg, onde são aplicadas<br>
regras semânticas e mapeando os bit de operação, chamado software netlist. Após isso, o código<br>
intermediário é convertido para C.<br>
A contribuição deste trabalhoconsiste na utilização de transformações de código como<br>
Qual<br>
tra-<br>
balho?<br>
base principal e partindo deste pressuposto torna-se vantajoso devido a utilização de outras<br>
ferramentas que não apresente suporte a certas linguagens, tais com a ferramenta ESBMC,<br>
utilizada neste trabalho, não apresenta suporte a VHDL, porém apresenta suporte as linguagens<br>
C/C++. Em outras palavras, a contribuição deste trabalhofoi a utilização de traduções de códigos<br>
Qual<br>
tra-<br>
balho?<br>
e utilizado este conceito como modelo de entrada para analise de circuitos.<br>
3.2.2 Unbounded safety verification for hardware using software ana-<br>
lyzers<br>
No artigo de MUKHERJEE et al. foi apresentado uma metodologia que aborda a utiliza-<br>
ção de técnicas e analisadores de software, com o objetivo de de abordar a análise de circuitos e<br>
Chapter 3. TRABALHOS CORRELATOS 38<br>
com isso trançar um paralelo entre as abordagens. Para testes foram utilizadas três metodologias<br>
de análise, usando interpolação, k-inductione tecnologias hibrídas. Como resultante dos testes, foi adicionar<br>
refer-<br>
ência<br>
adicionar<br>
refer-<br>
ência<br>
observado as principais causas de erros, por exemplo, bits não preciso e no caso das operações<br>
a bit-level ocorria perda de informações. Também foi obeservado que apesar de não serem<br>
otimizadas para análises de hardware, alguns analisadores de softaware podem, dependendo da<br>
técnica utilizada no analisador, ser utilizada para analise de hardware.<br>
Descrever<br>
qual<br>
o mo-<br>
tivo.<br>
A utilização de técnicas de análise de software <span class='f1 c_34' id='c_34_1' href='#c_34_2' cs_f='.c_34' >para o desenvolvimento de</span> análise de<br>
hardware é o foco a ser abordado neste neste trabalho de maneira prática, utilizando os princípio<br>
analisados por (MUKHERJEE et al., 2016a). Neste contexto, o objetivo deste trabalho é a<br>
utilização de técnicas de software para análise de circuitos, diferente do artigo apresentado acima<br>
que busca utilização uma abordagem mais complexa provando a possibilidade da utilização de<br>
técnicas de analise de software no contexto da verificação de hardware.<br>
A última frase está confusa, no meu entedimento é o mesmo sentido.<br>
3.2.3 Formal verification of timed VHDL programs<br>
No trabalho apresentado por BARA et al. é proposto uma abordagem para a análise<br>
de tempo relacionado a cada porta lógica dentro de um dado circuito analisado. A abordagem<br>
apresenta a tradução de um circuito lógico codificado em VHDL para um formalismo baseado<br>
em automato de tempo. Tal formalismo é representado por uma automato de estados finitos referência<br>
com relogios simbólicos que evoluem em taxa uniforme. A tradução é executada de modo<br>
automatico, baseado na emulação da propagação de cada transação ao longo de cada sinal, o<br>
seja, são automatos programados e cronometrados do circuito. Após a tradução para automato, a<br>
analise é feita pela ferramenta UPPALque é um model checking de verificação de propriedades referência<br>
de tempo. Seguindo esta metodologia a análise pode ser extraida de modo independente de cada<br>
bloco, desta forma a análise é feita de forma mais precisa, podendo ser analisado inumeros<br>
fatores, tais como limites de intervalo e sinal de correlação.<br>
O artigo apresenta uma abordagem de tempo, que torna-se interessante adição ao método.<br>
Porém até o momento a função não foi implementada ficando a trabalho futuros.<br>
Expandir o texto acima, exemplo, descrever como o método poderia ser incluindo no seu<br>
TCC.<br>
3.2.4 On the use of assertions for embedded-software dynamic verifica-<br>
tion<br>
Em GUGLIELMO et al. é apresentado uma metodologia para a integração dinamica de<br>
Assertion-Based Verification para várias fases da análise da verificação de fluxo em sistemas<br>
embarcados, por exemplo, emulação, diagnosticos e Debug, mas também um ferramenta chamada<br>
Chapter 3. TRABALHOS CORRELATOS 39<br>
RadCheck. O metodo de aplicação, chamado V-model é dividido em fases de verificação em<br>
paralelo com as fases de design do circuito. Com base no V-model, o método é aplicado, iniciando<br>
com o nível de sistema e as especificação do sistema, neste caso especificado usando PSL.<br>
Neste nível é especificado todas as funcionalidades gerais da aplicação. No nível de integração<br>
visa investigar problemas de interação que possam ocorrer, definindo propriedades que cobrem<br>
incrementalmente as unidades estruturais interativas de aplicação. No nível de unidade descrevem<br>
comportamentos internos e são definidas através de parâmetros de entrada/saída das unidade e<br>
estruturas de dados internas.<br>
A contribuição deste projeto está relacionado a utilização de assertivas no contexto da<br>
verificação de software. As assertivas são o principal meio de análise proposto neste projeto,<br>
visto que estas mesma assertivas serão analisadas pelo ESBMC. Aliado a isso em GUGLIELMO<br>
et al. é apresentado modelos de utilização de assertivas no processo de verificação de hardware,<br>
e tais assertivas foram adaptadas para um modelo proposto neste trabalho.<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation<br>
No trabalho de BOULE; ZILIC é apresentado uma ferramenta de geração de assertivas<br>
no contexto da emulação de circuitos, de modo que estas assertivas descrita em PSL possam<br>
transformadas para o modelo de linguagem de descrição de hardware. Inicialmente é realizada<br>
toda análise de cada assertiva e a mesma é traduzida em partes, levando em consideração os<br>
operadores e cada estrutura, por exemplo if-else, utilizado na declaração da assertiva.<br>
Apresentar um exemplo para explicar o texto acima<br>
trabalho de BOULE; ZILIC consolida e apresenta aspectos importantes, tais como a<br>
utilização de uma ferramenta para geração de assertivas, o que torna-se no contexto deste projeto,<br>
extremamente importante, visto que o modelo adotado atualmente consiste tanto na geração<br>
automática das assertivas, bem como a inserção manual por parte do usuário.<br>
40<br>
4 MÉTODO PROPOSTO<br>
Este Capítulo descreve o método proposto neste trabalho, baseado transformações de<br>
código para análise de circuitos lógicos descritos em VHDL utilizando <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >Bounded Model Checking</span>,<br>
neste caso o model checker ESBMC.<br>
4.1 Visão geral do método<br>
O método proposto consiste inicialmente em receber como entrada um circuito lógico<br>
descrito em VHDL, onde uma dada propriedade representada em uma assertiva será analisada,<br>
as assertivas serão inseridas de automaticamente pelo método ou pelo próprio usuário do método.<br>
O código VHDL analisado posteriomente é traduzido para linguagem C e recebe uma instrumen-<br>
tação de código (com funções especificas suportadas pelo método) para a posterior validação do<br>
mesmo. O Código em C automaticamente gerado, já instrumentado, será processado e analisado<br>
pelo ESBMC <span class='f1 c_30' id='c_30_1' href='#c_30_2' cs_f='.c_30' >de acordo com</span> as assertivas inseridas e ao final é apresentado o resultado. Caso<br>
alguma das assertivas seja violada, um contra-exemplo é apresentado ao usuário. Uma visão<br>
geral do método proposto é apresentado na Figura 16 e nas sessões a seguir serão apresentados<br>
cada etapa do método proposto neste trabalho.<br>
Figure 16 – Ciclo da ferramenta<br>
Fonte: Própria<br>
Com o intuito de auxiliar nas explicações apresentadas nas próximas sessões, o código<br>
na Figura 17 será utilizado nas explanações, bem como será apresentado todas as alterações do<br>
mesmo, conforme cada etapa do método.<br>
Chapter 4. MÉTODO PROPOSTO 41<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 ENTITY U l a _ t c c IS<br>
5 PORT(A, B , B i n v e r t i d o , Op1 , Op2 : IN BIT ;<br>
6 R e s u l t a d o :OUT BIT ) ;<br>
7 END U l a _ t c c ;<br>
8<br>
9 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
10 SIGNAL a n d _ p o r t : b i t ;<br>
11 SIGNAL o r _ p o r t : b i t ;<br>
12 SIGNAL x o r _ p o r t : b i t ;<br>
13 SIGNAL mux2x1 : b i t ;<br>
14 BEGIN<br>
15 PROCESS(A, B , B i n v e r t i d o , Op1 )<br>
16 BEGIN<br>
17 ??PORTA AND<br>
18 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
19 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
20 ELSE<br>
21 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
22 END IF ;<br>
23 ??PORTA OR<br>
24 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
25 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
26 ELSE<br>
27 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
28 END IF ;<br>
29 ??PORTA XOR<br>
30 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
31 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
32 ELSIF (A = ’ 1 ’ and mux2x1 = ’ 1 ’ ) THEN<br>
33 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
34 ELSE<br>
35 x o r _ p o r t &lt;= ’ 1 ’ ;<br>
36 END IF ;<br>
37 ??INVERSOR<br>
38 IF ( B i n v e r t i d o = ’ 0 ’ ) THEN<br>
39 mux2x1 &lt;= B ;<br>
40 ELSE<br>
41 mux2x1 &lt;= NOT B ;<br>
42 END IF ;<br>
43 ??MUX4X1<br>
44 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
45 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
46 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
47 R e s u l t a d o &lt;= o r _ p o r t ;<br>
48 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
49 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
50 END IF ;<br>
51 END PROCESS ;<br>
52 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 42<br>
4.2 Preprocessamento do VHDL e inserção de assertivas<br>
A fase inicial do método consiste no preprocessamento do código VHDL com as an-<br>
otações de código pelo usuário ou pelo método proposto de forma automática, incluindo as<br>
assertivas, conforme a Figura 16, na etapa A. O método não realiza qualquer tipo de verificação<br>
sobre o código VHDL, apenas utiliza o mesmo como entrada juntamente com as assertivas<br>
inseridas. Toda verificação é realizada sobre o código em linguagem C, que será traduzido a<br>
partir do código VHDL analisado, nas próximas etapas do método proposto. Vale ressaltar que<br>
mesmo a linguagem VHDL tendo um modelo de assertivas padrão, para o método tornou-se<br>
necessário a criação de um modelo (baseado em comentários) para que as funções do model<br>
checker adotado fossem suportadas, como a geração de valores não deterministicos.<br>
As assertivas manuais são adicionadas entre as tags @c2vhdl:ASSERT e @c2vhdl:END<br>
e todo trecho de código entre estas tags deve estar comentado, desta forma não apresentará<br>
erro na tradução do código em linguagem C, bem como na sintetização do código VHDL. Nas<br>
assertivas são incluidas as funções necessárias para a análise utilizando a ferramenta ESBMC. A<br>
assertiva apresenta três informações principais, sendo elas: condição, mensagem e gravidade.<br>
Ajustar está assertiva. Para quem não vê o código todo, ela não faz sentido<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR.<br>
1 ??@c2vhdl : ASSERT<br>
2 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ )<br>
3 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 "<br>
4 ??s e v e r i t y ERROR;<br>
5 ??@c2vhdl :END<br>
Fonte: Própria.<br>
A condição (na linha 2 da Figura 19) representa a assertiva propriamente dita e que será<br>
analisado pela aplicação. A condição será precedida de??assert e seguido ou não da palavra<br>
not, com isso a assertiva pode assumir valor negativo, conforme necessidade do usuário. Na<br>
Figura 19 a assertiva busca verificar se a variavél Resultado terá valor igual a 1. Qual a<br>
razão<br>
para<br>
isso,<br>
ex-<br>
plique!<br>
A mensagem (??report na linha 3 da Figura 19) é definida pelo usuário e será<br>
apresentado caso a assertiva apresente falha, assim a mensagem pode ser utilizada como um meio<br>
de depuração das propriedades validadas. A severidade (severity na linha 4 da Figura 19)<br>
pode ser definida como error, que representa um erro fatal e parada da verificação. A severidade<br>
do tipo warning que representa um erro não fatal, contabiliza as falhas das assertivas, porém<br>
não causa a parada da verificação. As mensagens futuramente pode ser integradas um framework<br>
para teste de unidade, contudo está é uma etapa ainda em planejamento neste trabalho.<br>
Juntamente com as assertivas outra função que pode ser utilizada é a função __ESBMC<br>
Chapter 4. MÉTODO PROPOSTO 43<br>
_assume() suportada pelo model checker ESBMC. Esta função utilizada em conjuto com a<br>
ferramenta ESBMC permite que durante a verificação uma variavél possa ter uma valor setado<br>
durante o tempo de execução da verificação. A importância desta função é fazer verificações onde<br>
se conhece os valores de entrada juntamente com o valor resultante, por exemplo, na verificação<br>
de portas lógicas.<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume().<br>
1 ??__ESBMC_assume (A = ’ 1 ’ )<br>
2 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
Fonte: Própria.<br>
A assertivas que serão verificadas são automáticas traduzidas a partir das entradas do<br>
código VHDL. Seja no modelo manual (assertivas escritas pelo usuário) ou automático (inferidas<br>
pelo método proposto por meio de análise estática), as entradas são mapeadas para serem<br>
utilizados na etapa de instrumentação. Desta forma, tais entradas podem ser utilizadas para gerar<br>
essas assertivas e então serem adicionadas diretamente ao código em linguagem C durante a fase<br>
de instrumentação.<br>
A Figura 20 apresenta o código juntamente com as assertivas conforme o padrão salien-<br>
tado na section 4.2. Neste exemplo foi implementado utilizado a inserção manual das assertivas<br>
e também da função __ESBMC_assume(), entretanto o objetivo é automatizar estas funções<br>
durante a execução da ferramenta.<br>
4.3 Tradução de código VHDL para a linguagem C<br>
Nesta etapa a tradução do código VHDL para linguagem C é executada, conforme<br>
apresentado na Figura 16, etapa B. A partir deste ponto, a ferramenta é executada de maneira<br>
propriamente dita, tendo todo o processo automatizado até a apresentação do resultado. Para<br>
esta etapa do método foi selecionado a ferramenta V2Cque realiza a tradução de VHDL para Adicionar<br>
refer-<br>
ência<br>
Linguagem C.<br>
A ferramenta V2C apresenta diversas vantagens em relação a equivalência de tradução<br>
de linguagens, contudo V2C apresenta certas limitação na tradução do código VHDL, em outras<br>
palavras, a mesma não reconhece algumas estruturas especificas do VHDL. A ferramenta aceita<br>
apenas entradas e saídas do tipo: bit, std_ulogic, qsim_state, std_ulogic_vector<br>
e interger. Na parte de arquitetura, a ferramenta aceita uma gama maior de estruturas, tra-<br>
balhando com expressoões do tipo: signal, variable, integers, strings e caracteres.<br>
Em expreções condicionais os operandos são AND, OR, NOT &lt;=, =&gt;,=,&lt;,&gt; e &lt;&gt;. Aceita<br>
também a estrutura de process, além da estutura block. A estrutura process é limitada<br>
Chapter 4. MÉTODO PROPOSTO 44<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 . . .<br>
4 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
5 SIGNAL a n d _ p o r t : b i t ;<br>
6 SIGNAL o r _ p o r t : b i t ;<br>
7 SIGNAL x o r _ p o r t : b i t ;<br>
8 SIGNAL mux2x1 : b i t ;<br>
9 BEGIN<br>
10 PROCESS(A, B , B i n v e r t i d o , Op1 ) IS<br>
11 BEGIN<br>
12 ??PORTA AND<br>
13 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
14 ??__ESBMC_assume (A = ’ 1 ’ )<br>
15 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
16 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
17 ELSE<br>
18 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
19 END IF ;<br>
20 . . .<br>
21 ??MUX4X1<br>
22 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
23 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
24 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
25 R e s u l t a d o &lt;= o r _ p o r t ;<br>
26 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
27 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
28 ??@c2vhdl : ASSERT<br>
29 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
30 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
31 ??s e v e r i t y ERROR;<br>
32 ??@c2vhdl :END<br>
33 END IF ;<br>
34 END PROCESS ;<br>
35 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
apenas a: if-else, case e loops. Como trabalho futuro, neste trabalho tem-se buscado<br>
novas abordagens para ampliar o suporte a estruturas não suportadas pelo V2C.<br>
Na tradução é necessário substituir os operadores originais por seus equivalentes em<br>
linguagem C. A excessão são os operadore específicos que gerenciam os valores de bit, tais<br>
como concatenação ou manipulação de partes vertoriais, para os quais são necessários construir<br>
procedimentos especificos em C.<br>
Conforme mostrado na Figura 21, na tradução são gerados vários vetores para suporte<br>
a tradução dos sinais representados no VHDL, sendo eles chg[], old[] e new[]. O vetor<br>
old[] contém o valor do sinais do passo anteriore a partir deste vetor o valor a ser usado nos Confuso<br>
issocálculo é obtido. O vetor new[] representa os novos valores a serem calculados pelos antigose<br>
Qual?<br>
Chapter 4. MÉTODO PROPOSTO 45<br>
o vetor chg[] contém um or exclusivo entre o valor novo e antigo e em caso de alteração entre<br>
os valores é copiado o valor de new[] para old[].<br>
O texto acima está muito confuso, corrigi rapidamente<br>
No código C gerado, os vetores in_data[] e out_data[] contêm os sinais de<br>
entrada e saída, respectivamente. No caso de circuitos sequênciais, o valor do status é inserido<br>
no primeiro (índice 0). A funçãoentão lerá os valores in_data[] e escreverá os resultados do qual?<br>
processamento em out_data[]. Ao final da operações os valores de estado são passado para<br>
out_data[].<br>
Conforme especificado e seguindo os parametros da ferramenta, a mesma realiza a<br>
tradução, mantendo inalterado qualquer fragmento de código que esteja comentado, neste caso,<br>
as assertivas presentes no código VHDL permanecem inalteradas, sendo utilizadas na próxima<br>
etapa do método proposto.<br>
4.4 Instrumentação de código<br>
As assertivas após a tradução permanecem comentadas, sendo necessário prepara-lás, ou<br>
seja traduzi-las, para verificação posterior do código na linguagem em C. Com isso é necessário<br>
uma instrumentação do código para prover suporte as assertivas traduzidas para análise, conforme<br>
apresentado na Figura 16, etapa C.<br>
Todas as etapas da instrumentação são realizados sobre o código C já traduzido. O passo<br>
inicial da instrumentação é a adição da macros no inicio do código C com as definição das<br>
assertivas a serem utilizadas. Na Figura 22 são apresentados os macros utilizadas no código C. A<br>
Linha 1 da figura corresponde a mensagem de erro a ser apresentada e a Linha 2 corresponde<br>
ao modelo da assertiva e a chamanda da macro definida na Linha 1 em caso de falha. Estas<br>
definições para as assertivas também podem ser utilizadas no código C traduzidos sem o uso do<br>
ESBMC.<br>
Figure 22 – Macros das assertivas implementadas em linguagem C<br>
1 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r ,M, __FILE__ , __LINE__ , # # __VA_ARGS__ )<br>
2 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
Fonte: Própria.<br>
O passo seguinte é a identificação das assertivas comentadas ao longo do corpo do<br>
código traduzido, utilizando o exemplo da Figura 23. As assertivas são identificadas através<br>
das tags @c2vhdl:ASSERT e @c2vhdl:END e a busca é realizado através destas tags. Ao<br>
ser encontrado a tag @c2vhdl:ASSERT, é realizado um loop até que seja encontrada a tag<br>
Chapter 4. MÉTODO PROPOSTO 46<br>
@c2vhdl:END e com isso toda a assertiva inserida possa ser passada a função de busca das<br>
informações da assertiva contidas entre as tags apresentadas.<br>
Com os dados das assertivas obtidos é realizado a busca da condição, mensagem e<br>
severidade através dos comandos ??assert, ??report e ??severity respectivamente.<br>
Estas informações são encontradas através do uso e uma Regex no código e que são adicionadas<br>
ao código C seguindo o modelo definido na macro. Este processo é repetido até outra assertiva<br>
ser encontrada ou caso chegue ao fina do código C.<br>
Com a função __ESBMC_assume() ocorre processo semelhante ao das assertivas.<br>
Utilizando novamente uma regex que realiza a busca por esta função no código e é retirado o<br>
comentário da mesma, desta forma a mesma passa a esta acessivél para o ESBMC, visto que a<br>
declaração da mesma já segue o modelo padrão a ser utilizado pelo ESBMC.<br>
Durante a instrumentação de código também é realizado a entrada de sinais não de-<br>
terministicos para variaveis não inicializadas ou argumentos de funções do código C gerado<br>
da tradução, utilizando a função __VERIFIER_nondet_int(). Esta função é utilizada em<br>
todas as variaveis de entrada e também nos sinais criados ao longo da arquitetura. Desta forma,<br>
todas as variavéis necessárias são inicializadas para verificação.<br>
Explicar o funcionamento do nondet com o ESBMC<br>
Em outras palavras, na instrumentação de código é realizado a traduçao das assertivas do<br>
modelo utilizado no código VHDL para para o modelo utilizado em linguagem C, além como de<br>
outras funções que possam ser utilizados pelo VHDL. Ao final da instrumentação o código C<br>
fica disponivel para que possa ser dado como entrada para outras ferramentas de verificação de<br>
código e não apenas o ESBMC.<br>
4.5 Verificação de assertivas usando Model Checker<br>
O model checker adotado no desenvolvimento de método é o ESBMCna versão 3.0.0 referência<br>
e conforme explicado na subsection 2.2.3, esta ferramenta recebe como entrada um código C<br>
ou C++ e devido a isso foi escolhida neste projeto. Nesta seção será apresentado a etapa D do apresentar<br>
outras<br>
vanta-<br>
gens<br>
métod proposto na Figura 16.<br>
Para a verificação, a primeira etapa é a identificação das assertivas no código C analisado,<br>
para isso é utilizado uma opção do ESBMC (??show-claims), mais especificamente as<br>
assertivas instrumentadas no código C analisado. Cada assertiva é identificada através de uma<br>
numeração <span class='f1 c_30' id='c_30_1' href='#c_30_2' cs_f='.c_30' >de acordo com</span> a ordem de busca do código analisado. Cada assertiva encontrada é<br>
armazenada para que seja realizada uma análise individual de cada claim, ou seja, assertiva.<br>
Chapter 4. MÉTODO PROPOSTO 47<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas.<br>
1 VAR<br>
2 c o n t a d o r : i n t e i r o<br>
3 c l a i m : l i s t a<br>
4 c l a i m _ s t r i n g : s t r i n g<br>
5<br>
6 FUNCAO c a l l _ e s b m c : a r q u i v o<br>
7 c o n t a d o r &lt;?0<br>
8 INICIO<br>
9 s a i d a &lt;?f un ca o de g e r a c a o das c l a i m s p e l o ESBMC<br>
10 ENQUANTO c o n t a d o r &lt; s a i d a FACA<br>
11 c o n t a d o r +=2<br>
12 r e g e x p a r a p r o c u r a r c l a i m e numeracao da c l a i m<br>
13 SE e n c o n t r a r c l a i m ENTAO<br>
14 r e g e x p a r a p r o c u r a r a p a l a v r a " a s s e r t i o n "<br>
15 SE e n c o n t r a r a p a l a v r a " a s s e r t i o n " ENTAO<br>
16 c o n t a d o r +=1<br>
17 A d i c i o n a a numeracao da c l a i m na l i s t a<br>
18 FIM?SE<br>
19 FIM?SE<br>
20 FIM?ENQUANTO<br>
21 FIM?FUNCAO<br>
Fonte: Própria.<br>
Na Linha 9 da Figura 24 é apresentado a chamada da ferramenta ESBMC que ocorre e<br>
através da opção ??show-claims lista todas as claims presentes no texto, como apresentado<br>
na Figura 25. Como o ESBMC infere de forma automatica assertivas a serem verificadas no<br>
código. Visando isolar somente as assertivas instrumentadas pelo método proposto, juntamente<br>
com a opção –show-claims é utilizado as opções:<br>
• ??no-pointer-check: para não realizar a checagem de ponteiros no código;<br>
• ??no-div-by-zero-check: para não realizar a checagem de divisões por zero no<br>
código; e<br>
• ??no-bounds-check: para não realizar a checagem de array bounds no código.<br>
Chapter 4. MÉTODO PROPOSTO 48<br>
Figure 25 – Imagem de claims contendo assertivas.<br>
Fonte:Própria<br>
Após a listagem das claims com assertivas ser gerada, outra função, indicada na Figura 26,<br>
é chamada para verificação de cada claim individualmente. Para cada claim, ocorre a chamada do<br>
ESBMC, utilizando as opções ??no-pointer-check, ??no-div-by-zero-check e<br>
??no-bounds-check, juntamente com a opção ??unwind em que realiza o número de<br>
desdobramentos dos laços no código analisado.<br>
Contudo, dependendo da complexidade da assertiva, faz-se necessário aumentar o número<br>
de desdobramentos que, por padrão são dez, conforme análise experimentais. A função é chamada<br>
na Linha 11 da Figura 26 e após a analise da claim é realizado a busca do resultado e exibição<br>
caso seja uma propriedade violada.<br>
Desta forma o ESBMC realiza apenas a checagem necessária dentro da assertiva, evitando<br>
que outros parâmetros sejam verificados, sem a devida necessidade do mesmo. Ao final de todos<br>
os desdobramentos é apresentado o resultado, apresentado na Figura 27, sendo positiva (sem<br>
erros) ou negativa (com violação de propriedades), dependendo da assertiva e do código analisado.<br>
Este processo se repete até a lista de assertivas ser finalizada.<br>
Chapter 4. MÉTODO PROPOSTO 49<br>
Figure 26 – Pseudocódigo da função de análise das claims.<br>
1 VAR<br>
2 c o n t a d o r 1 : i n t e i r o<br>
3 c o n t a d o r 2 : i n t e i r o<br>
4 r e s u l t a d o : l i s t a<br>
5<br>
6 FUNCAO esbmc_c la ims : l i s t a , a r q u i v o<br>
7 c o n t a d o r 1 &lt;?0<br>
8 c o n t a d o r 2 &lt;?0<br>
9 busca p e l o nome da fu nc a o no a r q u i v o<br>
10 ENQUANTO c o n t a d o r &lt; l i s t a FACA<br>
11 s a i d a &lt;?Execu ta comando de a n a l i s e da c l a i m<br>
numerada na l i s t a<br>
12 ENQUANTO c o n t a d o r 2 &lt; s a i d a<br>
13 Regex busca se a p r o p r i e d a d e f o i v i o l a d a<br>
14 SE p r o p r i e d a d e f o i v i o l a d a ENTAO<br>
15 Pu la p a r a l i n h a da v i o l a ç ã o<br>
16 A d i c i o n a o e r r o ao r e s u l t a d o<br>
17 FIM?SE<br>
18 FIM?ENQUANTO<br>
19 FIM?ENQUANTO<br>
20 FIM?FUNCAO<br>
Fonte: Própria.<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta.<br>
Fonte:Própria<br>
Ajustar os códigos, alguns estao muito grandes e com trechos desnecessário, não foi<br>
citado o link do repo da ferramenta<br>
Chapter 4. MÉTODO PROPOSTO 50<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C.<br>
1 void u l a _ t c c ( i n t i n _ d a t a [ ] , i n t o u t _ d a t a [ ] )<br>
2 {<br>
3 i n t _ i _ =0;<br>
4 i n t _c on t_ ;<br>
5 enum s e g n a l e {A, B , B i n v e r t i d o , Op1 , Op2 , R e s u l t a d o , and_po r t , o r _ p o r t ,<br>
6 x o r _ p o r t , mux2x1 , _MAX_} ;<br>
7 i n t o l d [_MAX_ ] ;<br>
8 i n t new [_MAX_ ] ;<br>
9 i n t chg [_MAX_ ] ;<br>
10 new [A] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
11 new [B] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
12 new [ B i n v e r t i d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
13 new [ Op1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
14 new [ Op2 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
15 new [ R e s u l t a d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
16 new [ a n d _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
17 new [ o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
18 new [ x o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
19 new [ mux2x1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
20<br>
21 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
22 {<br>
23 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
24 }<br>
25 new [A] = i n _ d a t a [ 1 ] ;<br>
26 new [B] = i n _ d a t a [ 2 ] ;<br>
27 new [ B i n v e r t i d o ] = i n _ d a t a [ 3 ] ;<br>
28 new [ Op1 ] = i n _ d a t a [ 4 ] ;<br>
29 new [ Op2 ] = i n _ d a t a [ 5 ] ;<br>
30<br>
31 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
32 {<br>
33 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
34 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
35 }<br>
36<br>
37 do {<br>
38 _ co n t _ =0;<br>
39 /? S t a r t o f T r a n s l a t i o n ? /<br>
40<br>
41 /? p0 : ? /<br>
42 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
43 /?PORTA AND ? /<br>
44 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
45 \ \ __ESBMC_assume ( o l d [A] = 1) ;<br>
46 \ \ __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
47 new [ a n d _ p o r t ] = 1 ;<br>
48 }<br>
49 e l s e {<br>
50 new [ a n d _ p o r t ] = 0 ;<br>
51 }<br>
52 /?PORTA OR ? /<br>
53 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
54 new [ a n d _ p o r t ] = 0 ;<br>
55 }<br>
56 e l s e {<br>
57 new [ a n d _ p o r t ] = 1 ;<br>
58 }<br>
59 /?PORTA XOR ? /<br>
60 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
61 new [ x o r _ p o r t ] = 0 ;<br>
62 }<br>
63 e l s e i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==1) ) {<br>
64 new [ x o r _ p o r t ] = 0 ;<br>
65 }<br>
66 e l s e {<br>
67 new [ x o r _ p o r t ] = 1 ;<br>
68 }<br>
69 /? INVERSOR ? /<br>
70 i f ( ( o l d [ B i n v e r t i d o ]==0) ) {<br>
71 i f ( chg [B ] ) {<br>
72 new [ mux2x1 ]= o l d [B ] ;<br>
73 }<br>
74 }<br>
75 e l s e {<br>
76 i f ( chg [B ] ) {<br>
77 new [ mux2x1 ]=~ o l d [B ] ;<br>
78 }<br>
79 }<br>
80 /?MUX4X1 ? /<br>
81 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
82 i f ( chg [ a n d _ p o r t ] ) {<br>
83 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
84 \ \ @c2vhdl : ASSERT<br>
85 \ \ a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
86 \ \ r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
87 \ \ s e v e r i t y ERROR;<br>
88 \ \ @c2vhdl :END<br>
89 }<br>
90 }<br>
91 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
92 i f ( chg [ o r _ p o r t ] ) {<br>
93 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
94 }<br>
95 }<br>
96 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
97 i f ( chg [ x o r _ p o r t ] ) {<br>
98 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
99 }<br>
100 }<br>
101 }<br>
102<br>
103 /? End o f T r a n s l a t i o n ? /<br>
104 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
105 {<br>
106 i f ( new [ _ i _ ] ! = o l d [ _ i _ ] ) _ con t_ =1;<br>
107 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
108 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
109 }<br>
110 } whi le ( _c on t_ ) ;<br>
111<br>
112 new [A] &= 0X01 ;<br>
113 new [B] &= 0X01 ;<br>
114 new [ B i n v e r t i d o ] &= 0X01 ;<br>
115 new [ Op1 ] &= 0X01 ;<br>
116 new [ Op2 ] &= 0X01 ;<br>
117 new [ R e s u l t a d o ] &= 0X01 ;<br>
118 new [ a n d _ p o r t ] &= 0X01 ;<br>
119 new [ o r _ p o r t ] &= 0X01 ;<br>
120 new [ x o r _ p o r t ] &= 0X01 ;<br>
121 new [ mux2x1 ] &= 0X01 ;<br>
122<br>
123 o u t _ d a t a [ 0 ] = 0 ; _ i _ =0;<br>
124 o u t _ d a t a [ 0 ] | = new [A] &lt;&lt; _ i _ ; _ i _ +=1;<br>
125 o u t _ d a t a [ 0 ] | = new [B] &lt;&lt; _ i _ ; _ i _ +=1;<br>
126 o u t _ d a t a [ 0 ] | = new [ B i n v e r t i d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
127 o u t _ d a t a [ 0 ] | = new [ Op1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
128 o u t _ d a t a [ 0 ] | = new [ Op2 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
129 o u t _ d a t a [ 0 ] | = new [ R e s u l t a d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
130 o u t _ d a t a [ 0 ] | = new [ a n d _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
131 o u t _ d a t a [ 0 ] | = new [ o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
132 o u t _ d a t a [ 0 ] | = new [ x o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
133 o u t _ d a t a [ 0 ] | = new [ mux2x1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
134<br>
135 o u t _ d a t a [ 1 ] = new [ R e s u l t a d o ] ;<br>
136 }<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 51<br>
Figure 23 – Código com assertivas traduzida para linguagem C<br>
1 # inc lude &lt; s t d i o . h&gt;<br>
2 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r , M , __FILE__ , __LINE__ , ##<br>
__VA_ARGS__ ) / / Update t o p r i n t t h e t r a <span class='f1 c_18' id='c_18_1' href='#c_18_2' cs_f='.c_18' >c e<br>
3 # d</span> e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
4<br>
5 . . .<br>
6<br>
7 do {<br>
8 _co n t _ =0;<br>
9 /? S t a r t o f T r a n s l a t i o n ? /<br>
10 chg [A] = __VERIFIER_nondet_int ( ) ;<br>
11 chg [B] = __VERIFIER_nondet_int ( ) ;<br>
12 chg [ B i n v e r t i d o ] = __VERIFIER_nondet_int ( ) ;<br>
13 chg [ Op1 ] = __VERIFIER_nondet_int ( ) ;<br>
14 chg [ a n d _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
15 chg [ R e s u l t a d o ] = __VERIFIER_nondet_int ( ) ;<br>
16 chg [ o r _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
17 chg [ mux2x1 ] = __VERIFIER_nondet_int ( ) ;<br>
18<br>
19 /? p0 : ? /<br>
20 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
21 /?PORTA AND ? /<br>
22 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
23 __ESBMC_assume ( o l d [A] = 1) ;<br>
24 __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
25 new [ a n d _ p o r t ] = 1 ;<br>
26 }<br>
27 e l s e {<br>
28 new [ a n d _ p o r t ] = 0 ;<br>
29 }<br>
30<br>
31 . . .<br>
32<br>
33 /?MUX4X1 ? /<br>
34 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
35 i f ( chg [ a n d _ p o r t ] ) {<br>
36 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
37 __MY_asser t ( new [ R e s u l t a d o ] == 1 , "O r e s u l t a d o é d i f e r e n t e de 0 " ) ;<br>
38 }<br>
39 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
40 i f ( chg [ o r _ p o r t ] ) {<br>
41 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
42 }<br>
43 }<br>
44 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
45 i f ( chg [ x o r _ p o r t ] ) {<br>
46 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
47 }<br>
48 }<br>
49 }<br>
50<br>
51 /? End o f T r a n s l a t i o n ? /<br>
52 . . .<br>
Fonte: Própria.<br>
52<br>
5 CRONOGRAMA<br>
53<br>
6 CONSIDERAÇÕES PARCIAIS E<br>
TRABALHOS FUTUROS<br>
O trabalho aborda <span class='f1 c_43' id='c_43_1' href='#c_43_2' cs_f='.c_43' >o desenvolvimento de um</span> método para análise de circuitos lógicos de-<br>
scrito em VHDL através da aplicação de técnica de transformação de código e a técnica Bounded<br>
Model Cheking. Este método tem como objetivo de explorar os estados alcanç alcançáveis no<br>
circuito, e dessa forma identificar erros que possam resutar em mal funcionamento do sistema.<br>
Entre as dificuldade encontradas, a principal esta ligada a etapa de tradução de código.<br>
Devido a ferramenta utilizada inicialmente conter diversas limitações, a mesma diminui a eficácia<br>
da ferramenta, pois a quantidade de estruturas que podem ser utilizadas é limitada e com isso<br>
limitando também <span class='f1 c_27' id='c_27_1' href='#c_27_2' cs_f='.c_27' >o processo de</span> criação de protótipos.<br>
Os trabalhos futuros é necessário buscar uma nova ferramenta ou método de tradução<br>
que tenha uma gama maior de tradução, seja em estruturas ou palavras reservadas,deste forma<br>
o método desenvlvido torna-se mais eficiente e gerando uma menor intervenção do usuário no<br>
código VHDL. A melhoria na tradução de código também beneficia ageração das assertivas<br>
automáticamente, pois com uma gama maior de estruturas suportadas, mais assertivas podem ser<br>
geradas.<br>
Além disso a geração automática das assertivas é Outro ponto abordado, já sitado anterior-<br>
mente, é a geração automática das assertivas, visto que na estapa atual ainda nõ foi implementado.<br>
Este recuros visa da liberdade ao desenvolvedor promovendo de maneira automática os teste<br>
sobre o código, não necessitando que uma intervenção, tornando a inserção manual apenas em<br>
casos especificos de testes.<br>
54<br>
BIBLIOGRAPHY<br>
ABE, J. Introducao a Logica Para a Ciencia Da Computacao. Arte & Ciência, 2002. ISBN<br>
9788574730455. Disponível em: &lt;https://books.google.com.br/books?id=AgBJdjoNPwUC&gt;.<br>
ACM. 2018. Acessado em: 01 de março de 2018. Disponível em: &lt;http://dl.acm.org/&gt;.<br>
AHO, A. V.; SETHI, R.; ULLMAN, J. D. Compilers: principles, techniques, and tools. [S.l.]:<br>
Addison-wesley Reading, 2007. v. 2.<br>
ALLEN, F. E. Control flow analysis. In: ACM. ACM Sigplan Notices. [S.l.], 1970. v. 5, n. 7, p.<br>
1–19.<br>
BAIER, C.; KATOEN, J.-P.; LARSEN, K. G. Principles of model checking. [S.l.]: MIT press,<br>
2008.<br>
BARA, A. et al. Formal verification of timed vhdl programs. In: IET. FDL. [S.l.], 2010. p.<br>
80–85.<br>
BASILI, V. R.; CALDIERA, G.; ROMBACH, H. D. Experience factory. Encyclopedia of<br>
software engineering, Wiley Online Library, 1994.<br>
BENSALEM, S.; LAKHNECH, Y. Automatic generation of invariants. Formal Methods in<br>
System Design, Springer, v. 15, n. 1, p. 75–92, 1999.<br>
BIERE, A. The aiger and-inverter graph (aig) format. Available at http://fmv.jku.at/aiger, 2016.<br>
BIOLCHINI, J. et al. Systematic review in software engineering. System Engineering and<br>
Computer Science Department COPPE/UFRJ, Technical Report ES, v. 679, n. 05, p. 45, 2005.<br>
BOULE, M.; ZILIC, Z. Incorporating efficient assertion checkers into hardware emulation. In:<br>
IEEE. Computer Design: VLSI in Computers and Processors, 2005. ICCD 2005. Proceedings.<br>
2005 IEEE International Conference on. [S.l.], 2005. p. 221–228.<br>
BOULE, M.; ZILIC, Z. Efficient automata-based assertion-checker synthesis of seres for<br>
hardware emulation. In: IEEE COMPUTER SOCIETY. Proceedings of the 2007 Asia and South<br>
Pacific Design Automation Conference. [S.l.], 2007. p. 324–329.<br>
BRAYTON, R.; MISHCHENKO, A. Abc: An academic industrial-strength verification tool. In:<br>
SPRINGER. Computer Aided Verification. [S.l.], 2010. p. 24–40.<br>
B.V. 2018. Acessado em 1 de março de 2018. Disponível em: &lt;http://www.sciencedirect.com/&gt;.<br>
CABODI, G. et al. Hardware model checking competition 2014: an analysis and comparison of<br>
solvers and benchmarks. Journal on Satisfiability, Boolean Modeling and Computation, v. 9, p.<br>
135–172, 2016.<br>
CAPPELATTI, D. Praticando VHDL. Editora Feevale, 2010. ISBN 9788577171200. Disponível<br>
em: &lt;https://books.google.com.br/books?id=z4\_CYog\_UskC&gt;.<br>
Bibliography 55<br>
CHRISTEN, E.; BAKALAR, K. Vhdl-ams-a hardware description language for analog and<br>
mixed-signal applications. IEEE Transactions on Circuits and Systems II: Analog and Digital<br>
Signal Processing, IEEE, v. 46, n. 10, p. 1263–1272, 1999.<br>
CHU, P. P. RTL hardware design using VHDL: coding for efficiency, portability, and scalability.<br>
[S.l.]: John Wiley & Sons, 2006.<br>
CLARKE, E. et al. Verification of hybrid systems based on counterexample-guided abstraction<br>
refinement. In: SPRINGER. TACAS. [S.l.], 2003. v. 3, p. 192–207.<br>
CLARKE, E. M. The birth of model checking. In: 25 Years of Model Checking. [S.l.]: Springer,<br>
2008. p. 1–26.<br>
CLARKE, E. M.; GRUMBERG, O.; LONG, D. E. Model checking and abstraction. ACM<br>
transactions on Programming Languages and Systems (TOPLAS), ACM, v. 16, n. 5, p.<br>
1512–1542, 1994.<br>
CORDEIRO, L.; FISCHER, B.; MARQUES-SILVA, J. Smt-based <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >bounded model checking</span> for<br>
embedded ansi-c software. IEEE Transactions on Software Engineering, IEEE, v. 38, n. 4, p.<br>
957–974, 2012.<br>
COUSOT, P.; COUSOT, R. A gentle introduction to formal verification of computer systems by<br>
abstract interpretation. [S.l.]: IOS Press, 2010.<br>
DAHAN, A. et al. Combining system level modeling with assertion based verification. In: Sixth<br>
international symposium on quality electronic design (isqed’05). [S.l.: s.n.], 2005. p. 310–315.<br>
ISSN 1948-3287.<br>
D’SILVA, V.; KROENING, D.; WEISSENBACHER, G. A survey of automated techniques<br>
for formal software verification. IEEE Transactions on Computer-Aided Design of Integrated<br>
Circuits and Systems, IEEE, v. 27, n. 7, p. 1165–1178, 2008.<br>
ELSEVIER. 2017. Acessado em: 01 março 2018. Disponível<br>
em: &lt;https://www.elsevier.com/__data/assets/pdf_file/0007/69451/<br>
0597-Scopus-Content-Coverage-Guide-US-LETTER-v4-HI-singles-no-ticks.pdf&gt;.<br>
G1. Acidente foi provocado por falha em circuito eletrônico, diz se-<br>
cretário. 2012. Disponível em: &lt;http://g1.globo.com/sao-paulo/noticia/2012/05/<br>
acidente-foi-provocado-por-falha-em-circuito-eletronico-diz-secretario.html&gt;.<br>
GUGLIELMO, G. D. et al. On the use of assertions for embedded-software dynamic verification.<br>
In: IEEE. Design and Diagnostics of Electronic Circuits & Systems (DDECS), 2012 IEEE 15th<br>
International Symposium on. [S.l.], 2012. p. 330–335.<br>
GUPTA, A. Formal hardware verification methods: A survey. In: SPRINGER. Computer-Aided<br>
Verification. [S.l.], 1992. p. 5–92.<br>
HALDER, A.; VENKATESWARLU, A. A study of petri nets modeling analysis and simulation.<br>
Department of Aerospace Engineering Indian Institute of Technology Kharagpur, India, 2006.<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Interpolation and symbol elimination in vampire.<br>
Automated Reasoning, Springer, p. 188–195, 2010.<br>
Bibliography 56<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Case studies on invariant generation using a<br>
saturation theorem prover. Advances in Artificial Intelligence, Springer, p. 1–15, 2011.<br>
IDOETA, I. V.; CAPUANO, F. G. Elementos de eletrônica digital. [S.l.]: Livros Erica, 1982.<br>
IEC/IEEE International Standard - Behavioural languages - Part 1-1: VHDL Language<br>
Reference Manual. IEC 61691-1-1:2011(E) IEEE Std 1076-2008, p. 1–648, May 2011.<br>
IEEE. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http://ieeexplore.ieee.org/<br>
Xplore/home.jsp&gt;.<br>
IEEE Standard for Property Specification Language (PSL). IEEE Std 1850-2010 (Revision of<br>
IEEE Std 1850-2005), p. 1–182, April 2010.<br>
IEEE Standard for Verilog Hardware Description Language. IEEE Std 1364-2005 (Revision of<br>
IEEE Std 1364-2001), p. 1–560, 2006.<br>
KITCHENHAM, B. Procedures for performing systematic reviews. Keele, UK, Keele University,<br>
v. 33, n. 2004, p. 1–26, 2004.<br>
KITCHENHAM, B. et al. Systematic literature reviews in software engineering–a systematic<br>
literature review. Information and software technology, Elsevier, v. 51, n. 1, p. 7–15, 2009.<br>
KNOOP, J.; RÜTHING, O.; STEFFEN, B. Partial dead code elimination. [S.l.]: ACM, 1994.<br>
v. 29.<br>
KOSCIANSKI, A.; SOARES, M. dos S. Qualidade de Software - 2a Edição: Aprenda as<br>
metodologias e técnicas mais modernas <span class='f1 c_34' id='c_34_1' href='#c_34_2' cs_f='.c_34' >para o desenvolvimento de</span> software. Novatec,<br>
2007. ISBN 9788575221129. Disponível em: &lt;https://books.google.com.br/books?id=<br>
O9aWoUq6L88C&gt;.<br>
KROPF, T. Introduction to Formal Hardware Verification. Springer Berlin Heidelberg,<br>
2013. ISBN 9783662038093. Disponível em: &lt;https://books.google.com.br/books?id=<br>
7ImrCAAAQBAJ&gt;.<br>
MAFRA, S. N.; TRAVASSOS, G. H. Estudos primarios e secundarios apoiando a busca por<br>
evidencia em engenharia de software. Relatorio Tecnico, RT-ES, v. 687, n. 06, 2006.<br>
MUKHERJEE, R. et al. Unbounded safety verification for hardware using software analyzers.<br>
In: EDA CONSORTIUM. Proceedings of the 2016 Conference on Design, Automation & Test in<br>
Europe. [S.l.], 2016. p. 1152–1155.<br>
MUKHERJEE, R.; TAUTSCHNIG, M.; KROENING, D. v2c–a verilog to c translator. In:<br>
SPRINGER. International Conference on Tools and Algorithms for the Construction and<br>
Analysis of Systems. [S.l.], 2016. p. 580–586.<br>
MURATA, T. Petri nets: Properties, analysis and applications. Proceedings of the IEEE, IEEE,<br>
v. 77, n. 4, p. 541–580, 1989.<br>
RAMESH, U. B. K.; SENTILLES, S.; CRNKOVIC, I. Energy management in embedded<br>
systems: Towards a taxonomy. In: IEEE PRESS. Proceedings of the First International<br>
Workshop on Green and Sustainable Software. [S.l.], 2012. p. 41–44.<br>
ROCHA, H. et al. Exploiting safety properties in <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >bounded model checking</span> for test cases<br>
generation of c programs. 2010.<br>
Bibliography 57<br>
ROCHA, H. et al. Model checking embedded c software using k-induction and invariants<br>
(extended version). arXiv preprint arXiv:1509.02471, 2015.<br>
ROCHA, H. O. et al. Verificacao de sistemas de software baseada em transformacoes de codigo<br>
usando <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >bounded model checking</span>. <span class='f1 c_3' id='c_3_1' href='#c_3_2' cs_f='.c_3' >Universidade Federal do</span> Amazonas, 2015.<br>
SARGENT, R. G. Verification and validation of simulation models. In: WINTER SIMULATION<br>
CONFERENCE. Proceedings of the 37th conference on Winter simulation. [S.l.], 2005. p.<br>
130–143.<br>
SEGER, C.-J. An introduction to formal hardware verification. [S.l.]: University of British<br>
Columbia, Department of Computer Science, 1992.<br>
SOMMERVILLE, I. Engenharia de software. PEARSON BRASIL, 2011. ISBN 9788579361081.<br>
Disponível em: &lt;https://books.google.com.br/books?id=H4u5ygAACAAJ&gt;.<br>
SONS, J. W. . 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http:<br>
//onlinelibrary.wiley.com/&gt;.<br>
SOUZA, J. Lógica para Ciência da Computação. Elsevier Brasil, 2017. ISBN 9788535278255.<br>
Disponível em: &lt;https://books.google.com.br/books?id=Ds2sCQAAQBAJ&gt;.<br>
SPRINGER. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;https:<br>
//link.springer.com/&gt;.<br>
SRIKANT, Y.; SHANKAR, P. The Compiler Design Handbook: Optimizations and<br>
Machine Code Generation. CRC Press, 2002. ISBN 9781420040579. Disponível em:<br>
&lt;https://books.google.com.br/books?id=0K\_jIsgyNpoC&gt;.<br>
THOMAS, D.; MOORBY, P. The Verilog R© Hardware Description Language. Springer<br>
US, 2008. ISBN 9780387853444. Disponível em: &lt;https://books.google.com.br/books?id=<br>
DxQGrz7q-SwC&gt;.<br>
TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L. Sistemas digitais: princípios e aplicações. [S.l.]:<br>
Prentice Hall, 2003. v. 8.<br>
TRAVASSOS, G. H. et al. An environment to support large scale experimentation in software<br>
engineering. In: IEEE. Engineering of Complex Computer Systems, 2008. ICECCS 2008. 13th<br>
IEEE International Conference on. [S.l.], 2008. p</div>
<!-- DIVISOR_DIV_CANDIDATE -->

<div class='divisor divisor-texto' id="cand__file3"><hr class='text-separator'><br>Input file: <a href='#'>main.pdf</a> (12773 chunks)<br>File found: <a href='http://ufrr.br/pic/index.php/component/phocadownload/category/24-editais-pibic.html?download=471:edital-05-2017-pibic' target='_blank'>http://ufrr.br/pic/index.php/component/phocadownload/category/24-editais-pibic.html?download=471:edital-05-2017-pibic</a> (4618 chunks)<br><br>Chunks in common: 47<br>Similarity: 0.27%<br><br><div class='textInfo'>The following is the content of the document <br>&nbsp;"<b>main.pdf</b>". <br>The terms in red were found in the document <br>&nbsp;"<b>http://ufrr.br/pic/index.php/component/phocadownload/category/24-editais-pibic.html?download=471:edital-05-2017-pibic</b>".<br><hr class='text-separator'></div>  <span class='f1 c_46' id='c_46_1' href='#c_46_2' cs_f='.c_46' >UNIVERSIDADE FEDERAL DE RORAIMA</span><br>
PRÓ-REITORIA DE ENSINO E EXTENSÃO<br>
DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >formal de circuitos</span> lógicos baseado em transformação de código <span class='f1 c_27' id='c_27_1' href='#c_27_2' cs_f='.c_27' >com<br>
Bounded Model Checking</span><br>
<span class='f1 c_41' id='c_41_1' href='#c_41_2' cs_f='.c_41' >Boa Vista - RR</span><br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >formal de circuitos</span> lógicos baseado em transformação de código<br>
<span class='f1 c_27' id='c_27_1' href='#c_27_2' cs_f='.c_27' >com Bounded Model Checking</span><br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
<span class='f1 c_10' id='c_10_1' href='#c_10_2' cs_f='.c_10' >da Universidade Federal de Roraima</span> como<br>
requisito parcial para a obtenção <span class='f1 c_37' id='c_37_1' href='#c_37_2' cs_f='.c_37' >do grau<br>
de</span> Bacharel em Ciência da Computação.<br>
Orientador: Dr. <span class='f1 c_14' id='c_14_1' href='#c_14_2' cs_f='.c_14' >Herbert Oliveira Rocha</span><br>
<span class='f1 c_41' id='c_41_1' href='#c_41_2' cs_f='.c_41' >Boa Vista - RR</span><br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >formal de circuitos</span> lógicos baseado em transformação de código <span class='f1 c_27' id='c_27_1' href='#c_27_2' cs_f='.c_27' >com<br>
Bounded Model Checking</span><br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
<span class='f1 c_10' id='c_10_1' href='#c_10_2' cs_f='.c_10' >da Universidade Federal de Roraima</span> como<br>
requisito parcial para a obtenção <span class='f1 c_37' id='c_37_1' href='#c_37_2' cs_f='.c_37' >do grau de</span><br>
Bacharel em Ciência da Computação.<br>
Defendido em 06 de março de 2017 e<br>
aprovado pela seguinte banca examinadora:<br>
Prof. Dr. <span class='f1 c_14' id='c_14_1' href='#c_14_2' cs_f='.c_14' >Herbert Oliveira Rocha</span><br>
Orientador / Curso de Ciência da Computação -<br>
UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Fazer dedicatória<br>
ACKNOWLEDGEMENTS<br>
Fazer agradecimentos!!<br>
Procurar frase massa!!<br>
ABSTRACT<br>
Fazer resumo!!<br>
Palavras-chaves: ??<br>
ABSTRACT<br>
Fazer Abstract!!<br>
Key-words: ??<br>
LISTA DE FIGURAS<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog. . . . . . . . . . . . . . . . 15<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL. . . . . . . . . . . . . . . . . 16<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade. . . . . . . . . . . . . . . 17<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL. . . . . . . . . . . . . . . . 17<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1. . . . . . . . . . 18<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas. . . . . . . . . 18<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas. . . . . . . . . . 19<br>
Figure 8 – Arvore de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
Figure 9 – Rede de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL. . . . . . . . . . . . . . . . . 27<br>
Figure 11 – Trecho de código em VHDL representando porta AND. . . . . . . . . . . . 28<br>
Figure 12 – Trecho de código traduzido para linguagem C. . . . . . . . . . . . . . . . . 29<br>
Figure 13 – Exemplo de bloco basico de código. . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 14 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 15 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 31<br>
Figure 16 – Ciclo da ferramenta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR. . . . . . . 41<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR. . . . . . . . . . . . . . 42<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume(). . . . . . . . . . . 43<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19. . . . . . . . . . . . . . . 44<br>
Figure 22 – Macros das assertivas implementadas em linguagem C . . . . . . . . . . . . 45<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas. . . . . . . 47<br>
Figure 25 – Imagem de claims contendo assertivas. . . . . . . . . . . . . . . . . . . . . 48<br>
Figure 26 – Pseudocódigo da função de análise das claims. . . . . . . . . . . . . . . . . 49<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta. . . . . . . . . . . . . . 49<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C. . . . . . . . . . . . . 50<br>
Figure 23 – Código com assertivas traduzida para linguagem C . . . . . . . . . . . . . . 51<br>
LISTA DE TABELAS<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM . . . . . . . . . . . . . . . 33<br>
SUMÁRIO<br>
1 INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11<br>
1.1 Definição do problema . . . . . . . . . . . . . . . . . . . . . . . . . . . 12<br>
1.2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13<br>
1.3 Organização do trabalho . . . . . . . . . . . . . . . . . . . . . . . . . 14<br>
2 CONCEITOS E DEFINIÇÕES . . . . . . . . . . . . . . . . . . . . . . 15<br>
2.1 Linguagens de descrição de hardware . . . . . . . . . . . . . . . . . 15<br>
2.1.1 VHSIC Hardware Description Language - VHDL . . . . . . . . . . . . . 16<br>
2.1.2 Portas lógicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18<br>
2.2 Verificação de sistemas . . . . . . . . . . . . . . . . . . . . . . . . . . 19<br>
2.2.1 Diagrama de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.2 Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.3 <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Bounded Model Checking</span> . . . . . . . . . . . . . . . . . . . . . . . . . . 21<br>
2.2.4 Redes de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22<br>
2.2.5 Verificação de hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
2.2.6 Verificação formal de software . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.7 Lógica proposicional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.8 Linguagem de especificação de propriedades . . . . . . . . . . . . . . 26<br>
2.2.9 Verificação baseada em assertivas . . . . . . . . . . . . . . . . . . . . 26<br>
2.2.10 Propriedades de segurança . . . . . . . . . . . . . . . . . . . . . . . . 27<br>
2.3 Técnicas de compiladores . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.1 Transformações de código . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2 Otimização de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2.1 Grafo Acliclico Direcional - GAD . . . . . . . . . . . . . . . . . . . . . . . . 29<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.3 Eliminção de código morto . . . . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.4 Análise do fluxo de dados . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
2.3.2.5 Gerador de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
3 TRABALHOS CORRELATOS . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1 Revisão sistemática . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1.1 Planejamento da Revisão Sistemática . . . . . . . . . . . . . . . . . . 33<br>
3.1.1.1 Procedimentos de Seleção e Critérios . . . . . . . . . . . . . . . . . . . . 35<br>
3.2 Revisão da literatura . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.1 V2c-A verilog to C translator . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.2 Unbounded safety verification for hardware using software analyzers . 37<br>
3.2.3 Formal verification of timed VHDL programs . . . . . . . . . . . . . . . 38<br>
3.2.4 On the use of assertions for embedded-software dynamic verification 38<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation . . 39<br>
4 MÉTODO PROPOSTO . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.1 Visão geral do método . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.2 Preprocessamento do VHDL e inserção de assertivas . . . . . . . 42<br>
4.3 Tradução de código VHDL para a linguagem C . . . . . . . . . . . . 43<br>
4.4 Instrumentação de código . . . . . . . . . . . . . . . . . . . . . . . . 45<br>
4.5 Verificação de assertivas usando Model Checker . . . . . . . . . . 46<br>
5 CRONOGRAMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52<br>
6 CONSIDERAÇÕES PARCIAIS E TRABALHOS FUTUROS . . . . . 53<br>
BIBLIOGRAPHY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54<br>
11<br>
1 INTRODUÇÃO<br>
A complexidade de sistemas computacionais cresce exponencialmente. Muitas compan- Exemplificar<br>
este<br>
cresci-<br>
mento.<br>
hias e organizações estão rotineiramente lidando com software que contém milhares de linhas<br>
de código, escritos por diferentes pessoas, que usam linguagens distintas, ferramentas, estilos e<br>
hardware projetados de diversas formas e combinações (HODER et al., 2011).<br>
No contexto de sistemas compostos de hardware e software, tem-se os sistemas embarca-<br>
dos (SE) que são dispositivos semicondutores com software integrados, os quais se conectam<br>
a outros dispositivos. Usualmente, o principal propósito dos SE é o controle e provimento de<br>
informações para uma função específica (RAMESH et al., 2012).<br>
Os SE são extremamente interativos com seu ambiente, operam geralmente em tempo real<br>
e estão disponíveis continuamente. No entanto, estes sistemas, por possuírem um curto espaço<br>
de tempo para a liberação do produto ao mercado, precisam ser desenvolvidos rapidamente e<br>
atingir um alto nível de qualidade, mas, devido a esta necessidade, os programadores podem<br>
cometer enganos durante a fase de desenvolvimento destes sistemas.<br>
Os SE têm se proliferado em partes consideráveis das atividades do nosso cotidiano,<br>
com a característica de possuir grande quantidade de complexidade e diversidade. Devido a esta<br>
complexidade, erros podem passar despercebidos, causando não apenas penalidades econômicas<br>
e/ou fracassos do produto no mercado, mas principalmente o risco de perda de vidas humanas<br>
(CABODI et al., 2016). Como, por exemplo, o acidente noticiado no (G1, 2012), no qual, de<br>
acordo com o secretário de transportes, uma falha na placa do circuito eletrônico responsável<br>
pelo controle de velocidade dos trens ocasionou a colisão entre duas composições na estação de<br>
metrô de São Paulo.<br>
Segundo ROCHA et al.2015b, para se obter um alto nível de qualidade no desenvolvi-<br>
mento dos sistemas de hardware e software, a execução desses sistemas deve ser controlada e da<br>
mesma forma deve-se buscar meios de garantir que as propriedades definidas sejam atingidas. Por<br>
exemplo, a partir do conhecimento prévio do modo de implementação de determinado hardware,<br>
é possível utilizá-lo de forma mais eficiente. Neste sentido, diversas estratégias de verificação e<br>
de teste estão sendo pesquisadas e aplicadas para garantir a qualidade do software e hardware<br>
(HODER et al., 2010; ROCHA et al., 2010; BRAYTON; MISHCHENKO, 2010; CORDEIRO et<br>
al., 2012; CABODI et al., 2016).<br>
Por este motivo, com o intuito de analisar e otimizar a descrição dos circuitos digitais,<br>
tem-se utilizado as linguagens de descrição de hardware (HDL). Estas se diferem das linguagens<br>
de programação por conseguirem gerar execuções não apenas sequenciais, como também con-<br>
correntes ou paralelas (CHU, 2006). Neste contexto, a VHSIC Hardware Description Language<br>
Chapter 1. INTRODUÇÃO 12<br>
(VHDL) é uma das linguagens de descrição de hardware mais utilizadas atualmente. A descrição<br>
em VHDL pode ser em vários níveis de abstração, sendo o mais alto o nível comportamen-<br>
tal que permite a descrição do circuito através de loops e processos, definido-o <span class='f1 c_31' id='c_31_1' href='#c_31_2' cs_f='.c_31' >na forma de</span><br>
algoritmo. Como características das linguagens de descrição, o VHDL permite declarações se-<br>
quenciais ou concorrentes onde as declarações continuam ativas e sua ordem torna-se irrelevante<br>
(CAPPELATTI, 2010).<br>
Aliada à linguagem de descrição de hardware, a verificação formal de sistemas computa-<br>
cionais tem desempenhado um papel importante para assegurar a previsibilidade e a confiabili-<br>
dade na concepção de aplicações críticas. E, para isso, tem-se utilizado a técnica denominada<br>
model checking, que é baseada em formalismos matemáticos para provar propriedades de pro-<br>
gramas reativos (BENSALEM; LAKHNECH, 1999). Esta técnica gera uma busca exaustiva no<br>
espaço de estados do modelo para determinar se uma dada propriedade é válida ou não (BAIER<br>
et al., 2008), tendo como principal razão para o seu sucesso o funcionamento completamente<br>
automático, ou seja, sem qualquer intervenção do usuário.<br>
Visando contribuir com a verificação de sistemas embarcados no âmbito de sistemas<br>
computacionais, o contexto deste trabalho está situado <span class='f1 c_35' id='c_35_1' href='#c_35_2' cs_f='.c_35' >no uso de</span> metodologias e técnicas de<br>
verificação formal para programas escritos em VHDL (BIERE, 2016), focando principalmente<br>
no <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Bounded Model Checking</span> (CORDEIRO et al., 2012; ROCHA et al., 2015a). Este trabalho está<br>
interessado especificamente na parte de: verificação de modelos de hardware descritos em níveis<br>
de circuitos de bits na linguagem VHDL, via transformações de código para gerar modelos (com<br>
assertivas) já suportados por model checkers, como o ESBMC (CORDEIRO et al., 2012).<br>
Dessa forma, o trabalho almeja analisar as propriedades de alcançabilidade para a<br>
identificação de localizações de erro, bem como, assertivas contendo propriedades de segurança.<br>
A propriedade de alcançabilidade ou propriedade <span class='f1 c_16' id='c_16_1' href='#c_16_2' cs_f='.c_16' >do estado de</span> erro é satisfatória (SAT), se um<br>
estado de erro é alcançável. Caso contrário, a propriedade é considerada insatisfatória (UNSAT).<br>
No caso SAT, o model checking também gera um rastreio da validação da propriedade (contra-<br>
exemplo), ou seja, uma sequência de estados que mostra como chegar ao erro <span class='f1 c_40' id='c_40_1' href='#c_40_2' cs_f='.c_40' >a partir de</span> um<br>
ponto inicial.<br>
1.1 Definição do problema<br>
O avanço da tecnologia, principalmente nas áreas de design e fabricação de eletrônicos,<br>
aumentou a importância do hardware nos dias atuais. Cada vez com mais funcionalidades<br>
integradas, aliada a velocidade e circuitos menores, faz com que a complexidade dos sistemas<br>
de hardware aumente. Entretanto, devido à complexidade cada vez maior, a detecção tardia<br>
de erros no sistema pode resultar em perda de produção, mas também custos <span class='f1 c_1' id='c_1_1' href='#c_1_2' cs_f='.c_1' >associados ao<br>
desenvolvimento</span> do sistema(GUPTA, 1992). Devido a isso, a verificação de hardware visa<br>
assegurar que o circuito atinja as especificações para o qual foi projetado, através de técnicas<br>
Chapter 1. INTRODUÇÃO 13<br>
formais ou dinâmicas (BOULE; ZILIC, 2007).<br>
Por esta razão, a utilização de métodos formais tornou-se uma abordagem atraente<br>
para superar as limitações inerentes à validação baseada em simulação. Portanto, a maioria<br>
das empresas de semicondutores têm investigado a sua aplicabilidade. Escolhas individuais de<br>
métodos, ferramentas e áreas de aplicação das empresas têm variado, assim como o seu nível<br>
de sucesso (CABODI et al., 2016). Com os recentes avanços na escalabilidade de automação<br>
dos model checkers e nas equivalências sequenciais de verificação, a maioria das empresas têm<br>
crescido ao contar com essas técnicas(CLARKE, 2008).<br>
O problema considerado neste trabalho é expresso na seguinte questão: Como comple-<br>
mentar e aprimorar a verificação de propriedades de segurança em circuitos lógicos, de tal<br>
forma que uma propriedade possa ser mapeada em um problema de alcançabilidade sim-<br>
bólica, ou seja, se é possível alcançar um estado específico (para uma dada propriedade) a<br>
partir do estado inicial?<br>
1.2 Objetivos<br>
O objetivo principal deste trabalho é projetar e avaliar um método para efetuar verificação<br>
de circuitos, de forma automática, descritos em VHDL com portas lógicas em nível de bit<br>
pela utilização de técnicas de transformação de códigos combinado com a técnica <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Bounded<br>
Model Checking</span> para exploração de estados alcançáveis no circuito, visando identificar erros ou<br>
comportamentos indevidos ou inesperados que podem resultar no funcionamento incorreto de<br>
um dado sistema.<br>
Os objetivos específicos são:<br>
1. Propor um método para especificar pré e pós-condições de circuitos digitais em nível de<br>
portas lógicas descritos em VHDL;<br>
2. Analisar ferramentas de verificação de modelos que utilizam a técnica <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Bounded Model<br>
Checking</span>;<br>
3. Especificar uma técnica de conversão de circuitos em linguagem de descrição de hardware<br>
VHDL <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >para um modelo</span> a ser verificado usando a técnica <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Bounded Model Checking</span>;<br>
4. Desenvolver um método para identificação de estados de erros ou ocorrências indevidas,<br>
de um dado circuito analisado, em modelos de hardware descritos em nível de bit na<br>
linguagem de descrição VHDL.<br>
5. Validar a aplicação do método proposto sobre benchmarks públicos de programas em<br>
VHDL, a fim de examinar a sua eficácia e aplicabilidade.<br>
Chapter 1. INTRODUÇÃO 14<br>
1.3 Organização do trabalho<br>
A introdução deste trabalho apresentou: o contexto, definição do problema, e objetivos<br>
deste trabalho. Os próximos capítulos estão organizados da seguinte forma:<br>
No Capítulo 2 Conceitos e Definições, são apresentados os conceitos abordados neste<br>
trabalho, especificamente: Linguagens de descrição de hardware; Verificação e validação de<br>
sistemas; e Técnicas de compiladores.<br>
No Capítulo 3 Trabalhos Correlatos, serão apresentados o método de pesquisa bibli-<br>
ográfica utilizado, sendo ele a revisão sistemática, seguido do resultado encontrado com esta<br>
pesquisa e, por fim, a contribuição dos artigos utilizados no desenvolvimento do projeto.<br>
No Capítulo 4 Método Proposto, são descritas as etapas de execução do novo método<br>
proposto que consiste na transformação do código, instrumentação de assertivas e verificação de<br>
código utilizando um model checker.<br>
No Capítulo 5, será apresentado o cronograma de atividades a ser realizado na elaboração<br>
do método durante o desenvolvimento do projeto.<br>
E, por fim, no Capítulo 6 Considerações parciais e trabalhos futuros, serão apresentas<br>
as considerações parciais e as sugestões de trabalhos futuros que podem ser desenvolvidos.<br>
15<br>
2 CONCEITOS E DEFINIÇÕES<br>
Este capítulo tem apresenta os principais conceitos e definições abordados neste tra-<br>
balho, tais como: Linguagens de descrição de hardware, Verificação de sistemas e Técnicas de<br>
Compiladores.<br>
2.1 Linguagens de descrição de hardware<br>
As linguagens de descrição de hardware (HDL) foram desenvolvidas com o intuito de<br>
auxiliar a criação de circuitos lógicos com grande número de elementos e com uma gama de<br>
abstrações lógicas e eletrônicas (THOMAS; MOORBY, 2008). Entre os exemplos, podemos<br>
citar: VDHL (IEC/IEEE. . . , 2011), Verilog (IEEE. . . , 2006) e SystemC (??).<br>
Segundo CHRISTEN; BAKALAR,1999, linguagens de descrição de hardware são lingua-<br>
gens de programação utilizadas com o intuito de descrever o comportamento de um determinado<br>
circuito, técnica conhecida como modelagem. Os modelos descritos em HDL são utilizados<br>
como entrada para um simulador, onde o mesmo pode ter seu comportamento analisado.<br>
As HDL’s trazem consigo diversas vantagens, entre elas códigos independentes de tec-<br>
nologia e fabricante, podendo ser portáteis e reutilizáveis (CAPPELATTI, 2010). As linguagens<br>
mais modernas, tais como VHDL e Verilog, possuem suporte tanto a descrição do circuito pro-<br>
priamente dito, quanto ao comportamento que o mesmo deve exercer (CHRISTEN; BAKALAR,<br>
1999).<br>
A Verilog, como já citado, é uma linguagem de descrição de hardware que fornece<br>
diversos níveis de abstração para desenvolvimento de sistemas digitais(THOMAS; MOORBY,<br>
2008). A linguagem foi desenvolvida para ser simples e efetiva nos diversos níveis de abstração<br>
incluindo o <span class='f1 c_6' id='c_6_1' href='#c_6_2' cs_f='.c_6' >suporte ao desenvolvimento</span>, verificação, síntese e testes de software (IEEE. . . , 2006).<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog.<br>
1 p r i m i t i v e m u l t i p l e x e r ( mux , c o n t r o l , dataA , da taB ) ;<br>
2 o u t p u t mux ;<br>
3 i n p u t c o n t r o l , dataA , da taB ;<br>
4 e n d p r i m i t i v e<br>
Fonte: Adaptado de (IEEE. . . , 2006).<br>
Na Figura 1 apresenta um exemplo de multiplexador descrito em Verilog utilizando a<br>
estrutura de modelagem, chamada UDP que permite a criação de novos primitivas para serem<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 16<br>
utilizada. Apresenta uma saída apenas(mux) e três entradas sendo uma de controle(control) e<br>
duas de dados(dataA e dataB).<br>
A VHDL é uma linguagem de descrição de hardware amplamente utilizada, concebida<br>
na década de 80, devido uma necessidade do Departamento de Defesa dos Estados Unidos<br>
da América (CAPPELATTI, 2010). Assim como a Verilog, esta linguagem também suporta o<br>
desenvolvimento, a verificação, a síntese, e os testes de hardware (IEC/IEEE. . . , 2011).<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL.<br>
1 l i b r a r y IEEE ;<br>
2 use IEEE . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 use IEEE . s t d _ l o g i c _ u n s i g n e d . a l l ;<br>
4 e n t i t y mux2x1 i s<br>
5 p o r t ( s e l : i n STD_LOGIC ;<br>
6 a , b : i n STD_LOGIC ;<br>
7 y : o u t STD_LOGIC ) ;<br>
8 end mux2x1 ;<br>
9<br>
10 a r c h i t e c t u r e d a t a f l o w of mux2x1 i s b e g i n<br>
11 y &lt;= ( a AND NOT s e l ) OR ( b AND s e l ) ;<br>
12 end d a t a f l o w .<br>
Fonte: (CAPPELATTI, 2010).<br>
Na Figura 2 está descrito um multiplexador de duas entradas descrito em VHDL, apre-<br>
sentando na parte inicial as bibliotecas e na entidade(entity) a declaração das variáveis utilizadas.<br>
Na arquitetura(architecture) apresenta o funcionamento do multiplexador, relacionando en-<br>
tradas e saídas conforme tenham sido declarados. Este conceitos serão melhor apresentados na<br>
subsection 2.1.1.<br>
Conforme apresentado nas Figura 1 e Figura 2, ambas as linguagens apresentam difer-<br>
enças no modelos de declaração e utilização para descrição de hardware. Para este trabalho foi<br>
escolhido a VHDL devido a linguagem apresentar um melhor escopo para análise, facilitando o<br>
trabalho de análise proposto para este projeto.<br>
2.1.1 VHSIC Hardware Description Language - VHDL<br>
Revisar textos e verificar a necessidade de mais exemplo<br>
VHDL é uma linguagem de descrição de hardware destinada a ser utilizada em todas<br>
as etapas da criação de sistemas eletrônicos, sendo elas: desenvolvimento; verificação; síntese;<br>
e, teste de circuitos (IEC/IEEE. . . , 2011). Segundo (CAPPELATTI, 2010), a VHDL apresenta<br>
três principais pilares: abstração, que consiste na descrição com diferentes níveis de detalhes;<br>
modularidade, que permite a divisão do projeto em vários blocos ou módulos para posterior<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 17<br>
interconexão; e hierarquia, permite que módulos possam ser compostos por submódulos e, os<br>
mesmos tenham níveis de abstração diferentes, dependendo da necessidade do projeto. Devido a<br>
esta versatilidade que a linguagem VHDL foi selecionada para o trabalho proposto.<br>
Segundo IEC/IEEE. . . ,2011, é necessário um padrão para formatação da descrição em<br>
VHDL: Entity (Pinos de entrada/saída) e Architecture (Arquitetura). A Entity ou entidade repre-<br>
senta o bloco onde são declaradas as entradas e as saídas do circuito utilizadas em todo o sistema,<br>
conforme apresentado na Figura 3. A Architecture ou arquitetura, apresentado na Figura 4, define<br>
a relação entre entradas e saídas declaradas na entidade, podendo tais especificações serem<br>
completas ou parciais. Assim como em outras linguagens, bibliotecas podem ser adicionadas,<br>
para que novas funções e atributos possam ser utilizados no projeto.<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade.<br>
1 l i b r a r y i e e e ;<br>
2 use IEEE . STD_LOGIC_1164 . ALL<br>
3<br>
4 ENTITY f u l l _ a d d e r IS PORT(<br>
5 x1 , x2 , c i n : i n s t d _ l o g i c ;<br>
6 S , c o u n t : o u t s t d _ l o g i c ) ;<br>
7 END f u l l _ a d d e r ;<br>
Fonte: Própria.<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL.<br>
1 ARCHITECTURE b e h a v i o r a l OF f u l l _ a d d e r IS<br>
2 BEGIN<br>
3 s &lt;=x1 XOR x2 XOR c i n ;<br>
4 cout &lt;=( x1 AND x2 ) OR ( x1 AND c i n ) OR ( b<br>
AND c i n ) ;<br>
5 END b e h a v i o r a l ;<br>
Fonte: Própria.<br>
Segundo CAPPELATTI,2010 uma descrição em VHDL pode conter diferentes níveis de<br>
abstração:<br>
• Comportamental: Permite descrever o circuito através de laços e processos. O circuito<br>
é definido em forma de um algoritmo, utilizando construção similares as utilizadas em<br>
linguagem de programação.<br>
• Transferência de registradores: Englobando a representação do dispositivo em nível de<br>
transferência entre registradores, que consiste na utilização de funções lógicas combina-<br>
cionais e de registradores.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 18<br>
• Estrutural: O circuito é descrito mais próximo da implementação real, podendo ser<br>
definidas portas lógicas com atrasos unitários ou com atrasos detalhados.<br>
2.1.2 Portas lógicas<br>
Segundo (IDOETA; CAPUANO, 1982), o conceito de portas lógicas é baseado na<br>
conhecida álgebra de Boole ou álgebra booleana, desenvolvida pelo matemático inglês George<br>
Boole em 1854. A álgebra booleana é representada por apenas dois valores, sendo eles o 0 e 1 e,<br>
através disso, expressa a relação entre entrada e saída dentro de um circuito. As portas lógicas<br>
podem ser construídas <span class='f1 c_40' id='c_40_1' href='#c_40_2' cs_f='.c_40' >a partir de</span> diodos, transistores e resistores interconectados de modo que a<br>
saída seja o resultante de uma operação lógica básica realizada sobre as entradas (TOCCI et al.,<br>
2003). A Figura 5 apresenta um exemplo de álgebra booleana sem a utilização de diagramas.<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1.<br>
Fonte: (TOCCI et al., 2003)<br>
Ainda segundo TOCCI et al.,2003, devido a esta característica, a álgebra booleana possui<br>
três operações básicas, OR (ou), AND (e) e NOT (não). Tal conjunto de operações também é<br>
denominado de operações booleanas e, por meio da utilização de tabelas verdade é possível<br>
descrever as saídas baseando-se nas entradas e na operação aplicada. Cada operação booleana<br>
possui sua tabela verdade ( Figura 6), bem como sua representação em forma de diagrama.<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas.<br>
Fonte: (TOCCI et al., 2003)<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 19<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas.<br>
Fonte: (TOCCI et al., 2003)<br>
A Figura 7 apresenta um circuito lógico formado pelas portas básicas da álgebra booleana.<br>
O circuito apresenta três entradas representadas pelas letras A, B e C, mas também formada<br>
por duas portas AND, uma porta NOT e uma porta OR. Cada uma destas portas representando<br>
operações a serem realizadas, podendo receber como entrada um valor inicial ou resultante de<br>
outra porta, como no exemplo ocorre com a última porta AND.<br>
Entetanto, segundo (KROPF, 2013), a análise de circuitos é extremamente complexa,<br>
resultando em um problema NP-Completo, algoritmos possuem tempo de execução exponencial.<br>
Contudo, este tempo de execução exponencial é uma complexidade exponencial para o pior caso,<br>
resultando crescimento exponencial da execução a medida que o tamanho do problema aumenta.<br>
Ainda, segundo (KROPF, 2013) a avaliação das funções booleanas podem ser ver-<br>
dadeiras(True) ou falso(False), com isso, para um função com n variáveis, apresenta 2n possibili-<br>
dades de avaliação. Utilizando o exemplo da Figura 7 que apresenta 3 entradas, logo apresenta 8<br>
possibilidade de avaliação ao final e este número aumenta à medida que o número de variáveis<br>
tambe aumenta<br>
2.2 Verificação de sistemas<br>
No contexto de verificação de sistemas, faz-se necessário a diferenciação entre verificação<br>
e validação. Verificação e validação possuem o intuíto de mostrar que determinado sistema fun-<br>
cione conforme o especificado, além de satisfazer as especificações do cliente (SOMMERVILLE,<br>
2011).<br>
Segundo (SARGENT, 2005), verificação é o processo de determinar se um modelo<br>
computacional obtido por discretização de um modelo matemático de um evento físico e o<br>
código que implementa o modelo computacional pode ser usado para representar o modelo<br>
matemático do evento com precisão suficiente e validação é o processo de determinar se um<br>
modelo matemático de um evento físico representa o evento físico real com precisão suficiente.<br>
A verificação consite identificação de erros e provavéis problemas que um componente<br>
pronto possa apresentar, enquanto a validação busca analisar se tal componete esta seguindo<br>
os requisitos pré-definidos para sua construção (KOSCIANSKI; SOARES, 2007). O teste de<br>
programa, na qual o software é executado com dados de teste é a principal forma de validação,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 20<br>
porém, tecnicas de verificação, tais como, inspeção e revisões também podem integrar a etapa de<br>
validação (SOMMERVILLE, 2011).<br>
2.2.1 Diagrama de decisão binária<br>
Um diagrama de decisão binária(DDB) pode ser definido como um grafo aciclico para<br>
representação de funcões boolenas. Existe uma ordem rigorosa na ocorrência de variáveis à me-<br>
dida que se percorre o grafo da raiz para a folha. Dado como exemplo a formula f=(a?b)?(c?d)<br>
e utilizando a ordenação de variavél a &lt; b &lt; c &lt; d, na Figura 8. Dada a atribuição de valores<br>
booleanos as variaveis a, b, c e d, pode-se decidir se a atribuição torna a fórmula verdadeira<br>
atravessando o início do gráfico na raiz e ramificação em cada nó. Definindo a, c e d = 1 e c = 0<br>
leva a folha de rótulo 1, portanto, a fórmula é verdadeira para essa tarefa (CLARKE et al., 1994).<br>
Figure 8 – Arvore de decisão binária<br>
Fonte: (CLARKE et al., 1994)<br>
Adicionar mais detalhes e descrever onde DDB é utilizado.<br>
O DDB permite o teste eficiente de satisfabilidade, validade e eficiência (KROPF, 2013).<br>
O uso e DDB em conjunto com Model Checking e técnicas de abstração permitiu o aumento na<br>
capacidade de verificação, de modo que sistemas mais realistas podessem ser verificados(??)<br>
2.2.2 Model Checking<br>
Model checking é uma técnica de verificação formal que explora todos os possíveis<br>
estados do sistema, de modo a provar se um modelo satisfaz determinada propriedade. Pode ser<br>
aplicada em uma ampla gama de aplicações, tais como sistema embarcados, design de hardware<br>
e engenharia de software (BAIER et al., 2008).<br>
Entre as vantagens da utilização de Model Checking estão:<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 21<br>
• Possuem suporte a verificação parcial, em outras palavras, a verificação individual de<br>
propriedades, permitido foco primeiro as propriedades essenciais(BAIER et al., 2008).<br>
• Não requer qualquer interação do usuário, nem um alto grau de especialização para <span class='f1 c_26' id='c_26_1' href='#c_26_2' cs_f='.c_26' >o uso<br>
de</span> model checking(BAIER et al., 2008).<br>
• Possui como base a teoria de grafos, estruturas de dados e lógica <span class='f1 c_24' id='c_24_1' href='#c_24_2' cs_f='.c_24' >no desenvolvimento da</span><br>
solução(BAIER et al., 2008).<br>
• Útil <span class='f1 c_2' id='c_2_1' href='#c_2_2' cs_f='.c_2' >para fins de</span> depuração, pois formece informações em caso de uma propriedade seja<br>
invalidada(BAIER et al., 2008).<br>
Por outro lado, apresenta também algumas desvantagens:<br>
• Sofre do problema de explosão de espaço de estados, ou seja, a quantidade de estados<br>
necessários pode ser maior que a memória disponivel pelo sistema(BAIER et al., 2008).<br>
• Faz a verificação apenas dos requisios declarados, logo, não a garantia de integridade.<br>
Baseado nisso, a validade de propriedades não verificadas não pode ser julgada(BAIER et<br>
al., 2008).<br>
• A verificação de modelos geralmente não é computável, isso deve-se a questões de decidi-<br>
bilidade utilizada (BAIER et al., 2008).<br>
Outras técnicas foram implementadas em conjuntos com Model checkings com o intuito<br>
de aumentas a capacidade de verificação, como a técnica SAT na qual não sofre do problema de<br>
explosão de estados existente usando DDB. A técnica SAT em conjuto com Model Checking é<br>
conhecida como <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Bounded Model Checking</span> (??).<br>
2.2.3 <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Bounded Model Checking</span><br>
Segundo ROCHA et al., <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Bounded Model Checking</span> (BMC) é um tipo especial de Model<br>
Checking que usualmente adota o método de satisfabilidade booleana, o qual tem sido introduzido<br>
como uma técnica complementar para diagrama de decisão binaria para aliviar o problema da<br>
explosão de estados, visto que a técnica de Model Checking busca todos os estados possíveis<br>
para verificação.<br>
<span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Bounded Model Checking</span> é uma técnica para a verificação de uma dada propriedade<br>
em uma determinada profundidade do sistema analisado. Logo, dado <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >um sistema de</span> transições<br>
M, uma propriedade ?, e um limite (bound) k, o BMC desenrola o sistema k vezes e traduz o<br>
sistema em uma condição de verificação(CV) ? tal que ? é satisfeito se e somente se ? tem um<br>
contra-exemplo de profundidade menor ou igual a k (ROCHA et al., 2015b).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 22<br>
O Extended SMT-Based Bounded Model Checker (ESBMC) é um <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Bounded Model<br>
Checking</span> baseado em satisfabilidade booleana (SAT) que permite verificação aritmética de Já tem<br>
su-<br>
porte<br>
a<br>
SMT<br>
adi-<br>
cionar<br>
ao<br>
texto<br>
overflow e undeflow, segurança de ponteiros, limite de array, de gerar propriedades de segurança<br>
em programas em C/C++. ESBMC utiliza uma versão modificada do CBMC no front-end para<br>
analisar o código ANSI-C e para gerar as condições de verificação através de execução simbólica<br>
(CORDEIRO et al., 2012; ROCHA et al., 2015b).<br>
No ESBMC, o programa analisado é modelado em <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >um sistema de</span> transição de estados,<br>
conforme a trupla: M = (S,R, S0), o qual é gerado um grafo <span class='f1 c_18' id='c_18_1' href='#c_18_2' cs_f='.c_18' >de controle de</span> fluxo (GFC), onde<br>
S representa o conjunto de estados, R ? SxS representa as transições e S ? S representa<br>
o conjuto de estados iniciais. Um estado s ? S consiste no valor do contador de programa<br>
(PC) e os valores de todas as variáveis dos programas. O estado inicial S0 atribui o inicio do<br>
programa GFC ao PC, desta forma o ESBMC identifica as transições, conforme a formula lógica,<br>
?=(Si,Si+1) que captura as retrições sobre os valores correspondntes do PC e das variáveis do<br>
programa (CORDEIRO et al., 2012).<br>
Segundo o site do ESBMC(??), a ferramenta permite ao usuário indicar propriedades<br>
adicionaisusando assertivas que também são verificadas. O ESBMC converte as condições Descrever<br>
quais<br>
pro-<br>
priedades<br>
o<br>
esbmc<br>
su-<br>
porta<br>
usando diferentes técnicas de backgroundpara posteriormente passar para verificador SMT. Outra<br>
apresentar<br>
exem-<br>
plo<br>
vantagem é a ferramenta permitir verificação de software single-thread e multi-thread.<br>
Descrever qual a razão da escolha para o trabalho, apresentar resultados do SV-COMP<br>
dos últimos 3 anos<br>
2.2.4 Redes de petri<br>
Apresentar definição formal para RP<br>
corrigir o texto abaixo RP não é uma ferramenta e sim um método de modelagem<br>
Redes de petri são utilizadas como ferramentas de modelagem gráfica com propriedades<br>
matemática. Como ferramenta gráfica são utilizadas como comunicação visual, como fluxogra-<br>
mas, por exemplo, e como ferramenta matemática podem configurar modelos matemáticos que<br>
regem o comportamento dos sistemas. A grade premissa desta ferramenta é descrever sistemas<br>
de processamento de informações caracterizados como concorrentes, assíncronos, distribuídos,<br>
paralelos, não deterministas e/ou estocásticos (MURATA, 1989).<br>
As redes de petri são representados como grafos direcionais compostos por nós e arcos,<br>
conforme apresentado na Figura 9. Os nós representam as transições e eventos e os arcos<br>
representam os pesos. Dentro desta representação, os arcos e eventos são componentes passivos<br>
enquanto as transições são ativos. A principal vantagem da utilização das redes de petri esta<br>
relacionado ao chamado "Token game" que consiste no comportamento da rede de petri, em<br>
outras palavras, representa o funcionamento do sistema representado pela rede(HALDER;<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 23<br>
VENKATESWARLU, 2006).<br>
Figure 9 – Rede de petri<br>
Fonte: (HALDER; VENKATESWARLU, 2006)<br>
Descrever o funcionamento da RP apresentado na IMG<br>
Descrever quais propriedades podem ser verificadas com RP e onde será utilizado no seu<br>
trabalho.<br>
2.2.5 Verificação de hardware<br>
Para a verificação de hardware diversas técnicas têm sido propostas (). Por meio da Apresentar<br>
exem-<br>
plos<br>
com<br>
refer-<br>
ências<br>
simulação, visa assegurar que uma implemetação, descrição do hardware em qualquer qualquer<br>
nível de abstração da hierarquia de hardware, atinja suas especificações, propriedades que devem<br>
ser respeitadas para que a corretude do mesmo seja comprovada (GUPTA, 1992). A Verificação<br>
formal de hardware consiste na utilização de técnicas para corretude de circuitos lógicos, ou<br>
seja, consiste na utilização de modelos matemáticos para descrição de propriedade e/ou de<br>
comportamento de um dado sistema (KROPF, 2013).<br>
Entre as abordagens utilizadas na verificação formal de hardware consiste tanto na imple-<br>
mentação quanto a especificação estarem descritas em lógica formal, neste caso a corretude será<br>
obtida através da comprovada relação entre a implementação e a especificação (SEGER, 1992).<br>
A especificação formal consiste na descrição do comportamento, bem como, das propriedades<br>
do sistema em linguagem matemática, tornando-se crucial para o processo de verificação. Na<br>
implementação formal, o nível de abstração, tais como, Gate level e RTL são importantes infor-<br>
mações <span class='f1 c_33' id='c_33_1' href='#c_33_2' cs_f='.c_33' >para o desenvolvimento</span> do formalismo, bem como as classes, por exemplo se o circuito<br>
é sequencial ou combinacional, se utiliza pipeline, etc (KROPF, 2013).<br>
Apresentar um exemplo de RTL<br>
A utilização de Model Checking também se faz presente nos modelos formais de ver-<br>
ificação de hardware, onde apenas é utilizado o comportamento dos circuitos na verificação,<br>
de modo a verificar a se as propriedades presentes são satisfeitas. Para isso, são utilizados os<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 24<br>
conceitos da lógica proposicional, que por meio da utilização de fórmulas que representem as<br>
propriedades dos estados, é possível realizar as verificações necessárias (SEGER, 1992).<br>
Apresentar um exemplo com um circuito e como este pode ser verificando com model<br>
checking<br>
2.2.6 Verificação formal de software<br>
Observa-se que <span class='f1 c_26' id='c_26_1' href='#c_26_2' cs_f='.c_26' >o uso de</span> verificacão de software tem sido feito aplicado em muitas áreas,<br>
tais como, infraestruturas industriais de missão critica e de segurança. Logo, existe a necessidade<br>
de garantir a corretude destes sistemas. Devido a isso, a verificação formal tem sido utilizada em<br>
três principais abordagens, sendo elas (COUSOT; COUSOT, 2010; D’SILVA et al., 2008):<br>
Apresentar exemplos para os métodos apresentados abaixo<br>
• Métodos dedutivos: Produzem provas matemáticas formais de corretude usando provadores<br>
de teoremas ou assistentes de prova para execução da prova e necessitam da interação<br>
humana para prover os argumentos (COUSOT; COUSOT, 2010);<br>
• Verificação de modelos: Exploram exaustivamente modelos de execuções de programa,<br>
que podem ser sujeitos a explosão combinatória, necessário a intervenção humana para<br>
geração dos modelos (ROCHA et al., 2015b);<br>
• Analise estática: Engloba diversas técnicas para calcular automaticamente informações<br>
sobre o comportamento de um programa sem executá-lo, sendo utilizado em otimização<br>
de código e verificação em compiladres (D’SILVA et al., 2008).<br>
Segundo ROCHA et al., na verificação formal de software apresentam-se dificuldades,<br>
tais como: quais as propriedades são de interesse na verificação em tempo de execução; e<br>
impossibilidade matemática de provar a corretude de propriedades não triviais no comportamento<br>
de programas (COUSOT; COUSOT, 2010).<br>
2.2.7 Lógica proposicional<br>
A lógica proposicional é uma linguagem formal onde é definida um alfabeto e conectivos<br>
proposicionais, e um conjunto de regras gramaticais, as quais serão utilizadas para construção<br>
das proposições (SOUZA, 2017). Porém apesar de importante, ela é limitada, não podendo<br>
expressar sentenças elementares importantes, tais como a da aritmética elementar. Por exemplo:<br>
1. Todos são mortais.<br>
2. Alguém é bondoso.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 25<br>
Na lógica preposicional, não poderiam ser analisadas, pois não teria como decompor<br>
ambas em sentença e assim não teria como analisar as diferenças entre ambas(ABE, 2002).<br>
Contudo, no exemplo: Existem cavalos com patas verdes. A relação criada pela frase poderia a<br>
ser analisada pela lógica proposicional(ABE, 2002). Descrever<br>
como<br>
seria<br>
está<br>
analise<br>
Segundo SOUZA, alfabeto da lógica proposicional é formado por símbolo de pontuação,<br>
símbolos proposicionais e conectivos proposicionais, onde cada um apresenta uma função em<br>
específico, sendo:<br>
• Símbolos de pontuação: Apenas dois símbolos de pontuação são utilizados o "(" e o ")".<br>
• Símbolos proposicionais: São utilizados para representar as proposições, onde um sím-<br>
bolo P pode ser utilizado para representar uma proposição qualquer, por exemplo: P="Está<br>
chovendo". O conjunto de símbolos proposicionais é infinito e enumerável, sendo possível<br>
representar infinitos e enumerável conjunto de proposições.<br>
• Conectivos proposicionais: São os símbolos usando frequentemente na matemática. Os<br>
símbolos recebem a seguinte denominação:<br>
1. ¬: Representa a partícula de negação, ou seja, "Não".<br>
2. ?: Representa a partícula "Ou"<br>
3. ?: Representa a partícula "E"<br>
4. ?: Representa a partícula "Se então ou implica".<br>
5. ?: Representa a partícula "Se, e somente se".<br>
Ainda segundo SOUZA, existem as fórmulas que são constituídas de forma indutiva, <span class='f1 c_40' id='c_40_1' href='#c_40_2' cs_f='.c_40' >a<br>
partir de</span> símbolos do alfabeto conforme as regras apresentadas abaixo:<br>
• Todo o símbolo preposicional é uma fórmula<br>
• Se H é uma fórmula, então (¬H), a negação de H, é uma fórmula.<br>
• Se H e G são fórmulas, então a disjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a conjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o antecedente e G consequente da fórmula.<br>
• Se H e G são fórmulas, então a bi-implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o lado esquerdo e G o lado direito da fórmula.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 26<br>
2.2.8 Linguagem de especificação de propriedades<br>
Linguagem de especificação de propriedades, do inglês Property Specification Language<br>
- PSL, é uma notação formal para especificação de comportamento em sistemas eletrônicos,<br>
compatível com as linguagens VHDL, Verilog, SystemC e SystemVerilog. Destina-se a utilização Adicionar<br>
refer-<br>
ência<br>
a cada<br>
Ling<br>
citada<br>
para a especificação funcional, mas também para entrada de ferramentas de verificação. A<br>
especificação do PSL é a utilização de assertivas sobre propriedades <span class='f1 c_30' id='c_30_1' href='#c_30_2' cs_f='.c_30' >de um sistema</span>, sendo estas<br>
propriedades constituídas de três elementos: expressões boolenas, expressões sequenciais e<br>
operadores temporais (IEEE. . . , 2010).<br>
Corrigir a apresentação da citação IEEE... estranho<br>
Segundo (IEEE. . . , 2010), o PSL foi totalmente desenvolvida com o intuito fornecer<br>
leitura e escrita de fácil entendimento, sintaxe concisa, semântica formal e rigorosamente bem<br>
definida e ser matematicamente precisa, visto a utilização da mesma em processo de verificação.<br>
O PSL pode ser utilizado para capturar requisitos relativos ao comportamento total do projeto,<br>
bem como, sobre o modo que o mesmo deverá operar no ambiente, ms também para capturar<br>
requisitos comportamentais e os pressupostos que surgem durante o processo de design. Ambas<br>
podem ser utilizadas para verificação de sistemas.<br>
Apresentar exemplos de uso da PSL<br>
2.2.9 Verificação baseada em assertivas<br>
Verificação baseada em assertivas, do inglês Assertion-Based Verification - ABV, é um<br>
paradigma de verificação igualente adequado para verificação formal e abordagens baseadas em<br>
simulação (BOULE; ZILIC, 2005) e em conjunto com a tecnica de PSL tem ganhado aceitação<br>
como um método essencial para verificação funcional do hardware (DAHAN et al., 2005).<br>
Na ABV as assertivas são declaração adicionadas ao projeto com o intuito de especificar<br>
o comportamento do projeto (BOULE; ZILIC, 2005), podendo escritos em PSL ou em SVA<br>
(System Verilog Assertions). No caso deste projeto será utilizado a PSL, devido a mesma ser<br>
utilizada juntamente com a linguagem VHDL.<br>
Com a utilização de ABV o circuito pode ser verificado usando técnicas de simulação<br>
e/ou verificação, por exemplo, model checking, para garantir que o mesmo esteja de acordo<br>
com o pretendido projeto (DAHAN et al., 2005). Na Figura 19 apresenta o modelo de assertiva<br>
utilizada no projeto, utilizando de um modelo próprio para assertivas, unindo as funcionalidades<br>
já existentes nas assertivas do VHDL, mas também novas (serão apresentadas nas próximas<br>
seções), fornecendo assim mais propriedades a serem analisadas.<br>
Descrever qual o objetivo da assert apresentado<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 27<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 e n t i t y AND_ent i s<br>
5 p o r t ( x , y : i n b i t ;<br>
6 F : o u t b i t<br>
7 ) ;<br>
8 end AND_ent ;<br>
9<br>
10 a r c h i t e c t u r e behav1 of AND_ent i s<br>
11 b e g i n<br>
12 ??@c2vhdl : ASSERT<br>
13 ??a s s e r t n o t ( x= ’ 0 ’ and y= ’ 1 ’ )<br>
14 ?? r e p o r t " Both v a l u e s o f s i g n a l s x and y a r e e q u a l t o 1 "<br>
15 ??s e v e r i t y ERROR;<br>
16 ??@c2vhdl :END<br>
17<br>
18 p r o c e s s ( x , y )<br>
19 b e g i n<br>
20 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
21 F &lt;= ’ 1 ’ ;<br>
22 e l s e<br>
23 F &lt;= ’ 0 ’ ;<br>
24 end i f ;<br>
25 end p r o c e s s ; 4<br>
26 end behav1 ;<br>
Fonte: Própria.<br>
2.2.10 Propriedades de segurança<br>
Propriedades de segurança é um meio de validação do comportamento de um determinado<br>
sistema, de modo que se uma dada propriedade de segurança for violada, então através de<br>
uma execução finita, é possível verificar tal erro. Algumas propriedades de segurança, no<br>
entanto, podem impor requisitos em fragmentos de caminho finito e não podem ser verificadas<br>
considerando apenas os estados alcançáveis. (BAIER et al., 2008).<br>
Segundo (CLARKE et al., 2003), podemos definir uma propriedade de segurança como:<br>
dado <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >um sistema de</span> transições ST = (S, S0, E), seja um conjunto B ? S que especifica um<br>
conjunto de maus estados tais que S0 ?B = ?, pode-se dizer que ST é seguro com relação a B,<br>
denotado por ST |= AG¬B se não existe um caminho no sistema de transição do estado inicial<br>
S0 até o estado B, de outro modo é dito que ST não é seguro.<br>
Adicionar exemplos de propriedades de segurança em hardware<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 28<br>
2.3 Técnicas de compiladores<br>
Compiladores são sistemas de software utilizados para tradução de uma linguagem de<br>
programação para outra, ou seja, o programa da linguagem fonte é lido e traduzido para um<br>
código equivalente na outra linguagem, ou linguagem alvo. Geralmente utilizada para transformar<br>
trechos de código em uma linguagem a ser executada pelo computador (AHO et al., 2007).<br>
Diversas técnicas podem ser utilizadas nas diversas etapas, até que o código seja traduzido,<br>
tais como LL(1) e LR na análise sintática; eliminação de código morto; propagação de constante<br>
e Peephole na otimização de código(AHO et al., 2007). Neste projeto serão focados as áreas de<br>
transformações de código e otimização de código.<br>
2.3.1 Transformações de código<br>
Transformações de código correspondem a uma complexa função que envolve analise de<br>
fluxo de dados e modificação completa do programa que são parte integral da alta performance e<br>
sistemas computacionais. Podem ser classificados em transformações escalares que reduzem<br>
o número de instruções a serem executadas no programa ou transformações paralelas que<br>
maximizam o paralelismo (SRIKANT; SHANKAR, 2002).<br>
A Figura 11 representa o trecho de código apresentado na Figura 19. O trecho representa<br>
o comportamento das entradas, neste caso de um código da porta AND. E a figura Figura 12<br>
representa a tradução deste trecho em código na linguagem C. Esta tradução foi realizada pela<br>
ferramenta V2C, utilizada neste projeto. Adicionar<br>
refer-<br>
ência<br>
Figure 11 – Trecho de código em VHDL representando porta AND.<br>
1 p r o c e s s ( x , y )<br>
2 b e g i n<br>
3 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
4 F &lt;= ’ 1 ’ ;<br>
5 e l s e<br>
6 F &lt;= ’ 0 ’ ;<br>
7 end i f ;<br>
8 end p r o c e s s ;<br>
Fonte: Própria.<br>
Expandir esta seção. Apresentar propriedades de transformação e técnicas para avaliar a<br>
transformação<br>
2.3.2 Otimização de código<br>
A otimização de código consiste na melhoria do código intermediário gerado pelos<br>
algoritmos de compilação com o objetivo de obter um menor tempo de execução do programa,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 29<br>
Figure 12 – Trecho de código traduzido para linguagem C.<br>
1 /? S t a r t o f T r a n s l a t i o n ? /<br>
2 /? p0 : ? /<br>
3 i f ( chg [ x ] | | chg [ y ] ) {<br>
4 i f ( ( ( o l d [ x ]==1) && ( o l d [ y ]==1) ) ) {<br>
5 new [ f ] = 1 ;<br>
6 }<br>
7 e l s e {<br>
8 new [ f ] = 0 ;<br>
9 }<br>
10 }<br>
11 /? End o f T r a n s l a t i o n ? /<br>
Fonte: Própria.<br>
porém outros fatores podem ser introduzidos, como algoritmos menores. Este fato não implica<br>
em afirmar que o melhor código é gerado, visto que dada a complexidade, raramente pode ser<br>
obtido que o código gerado pode ser o melhor possível (AHO et al., 2007).<br>
Segundo AHO et al., otimização local de código consiste na otimização de um bloco<br>
básico de código, ou seja, a otimização ocorre em um trecho especifico de código. Os blocos<br>
básicos são trecho onde não ocorrem saltos ou loops, para nenhuma outra parte do código. A<br>
otimização global de código é baseado na analise do fluxo de dados, de modo que ocorra as<br>
elminação de instruções não necessárias ou substituição mais facil. A otimização global consite<br>
na analise completa do código. Neste sentido, nas próximas seções serão apresentadas algumas<br>
importantes técnicas de otimizações.<br>
2.3.2.1 Grafo Acliclico Direcional - GAD<br>
Grafo Aciclico Direcional é utilizado para diversos fins dentro da estrutura de compi-<br>
ladores, principalmente para geração da parse tree otimização de código. Pode ser usado na<br>
representação de instruções unicas blocos básicos de código(AHO et al., 2007). <span class='f1 c_26' id='c_26_1' href='#c_26_2' cs_f='.c_26' >O uso de</span> GAD<br>
permite a melhoria de de código, tais como:<br>
• Elminação de subexpressões locais comuns, ou seja, expressões que o valor já foi com-<br>
putado anteriomente;<br>
• Eliminação de código morto;<br>
• Reordernamento de declarações buscando reduzir o tempo que o valor temporário necessita<br>
ser preservado em um registro;<br>
A Figura 13 apresenta um bloco básico com algumas instruções, no caso apresentando<br>
são 4 operações entre somas e multiplicação e a partir deste bloco a Figura 14 apresenta o GDA<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 30<br>
Figure 13 – Exemplo de bloco basico de código.<br>
1 a = b + c<br>
2 b = a ? d<br>
3 c = b + c<br>
4 d = a ? d<br>
Fonte: (AHO et al., 2007)<br>
Figure 14 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
deste trecho de código. Nele apresenta cada nó como uma operação especifica e os terminais<br>
como as parcelas das operações.<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC<br>
Grafo de fluxo de controle corresponde a um grafo direcionado, no qual cada nó rep-<br>
resenta blocos básicos e cada aresta representa os caminhos de fluxo entre os blocos basi-<br>
cos (ALLEN, 1970). É importante ressaltar que saltos determinam o final de um determinado<br>
bloco básico, ou seja, saltos indicam um caminho para uma nova região de código básico (AHO<br>
et al., 2007).<br>
Apresentar um exemplo de como e utilizado em código<br>
2.3.2.3 Eliminção de código morto<br>
A eliminacação de código morto é uma técnica que busca a eficiência de um programa<br>
evitando a execução de instruções não necessária em tempo de execução (KNOOP et al., 1994).<br>
O código morto consiste em instruções que não serão alcançáveis durante o fluxo do programa,<br>
sendo esta técnica basicamente a retirada de qualquer variável que não será utilizada em qualquer<br>
outro nó do grafo (AHO et al., 2007).<br>
A utilização de GAD corresponde na eliminação de qualquer nó raiz, ou seja, nó sem<br>
ancestrais, as quais não esteja ativa anexada a mesma. A execução repetida desta operação<br>
removerá todos os nós correspondentes a código morto (AHO et al., 2007).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 31<br>
Figure 15 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
Na Figura 15, supondo que os nós a, b e c estejam ativa, porém o nó énão esteja, o último Corrigir<br>
nó é?pode ser eliminado imediatamente. Os nós restantes continuam no GDA, a menos que não tenho<br>
variáveis ativas atreladas aos nós (AHO et al., 2007).<br>
2.3.2.4 Análise do fluxo de dados<br>
Análise de fluxo de dados refere-se ao conjunto de técnicas que derivam informações<br>
sobre o fluxo de dados ao longo dos caminhos de execução do programa. Para análise do<br>
programa, é necessário considerar todas as posiveis execuções através do grafo de fluxo de<br>
controle (AHO et al., 2007).<br>
Apresentar exemplos<br>
2.3.2.5 Gerador de código<br>
O gerador de código é responsavél pela tradução final do programa-fonte para o programa-<br>
alvo, o mesmo recebe como entrada um código intermediário juntamente com a tabela de<br>
símbolos. Faz-se necessário que o programa-fonte tenha sido analisado sintatica e lexicamente,<br>
assim evitando que erros possam ser passados para o programa-alvo, por outro lado a existência<br>
de uma nível de otimização, faz-se opicional neste caso (AHO et al., 2007).<br>
O gerador de código possui três tarefas primarias, sendo as mesmas seleção de instrução,<br>
alocação de registros e atribuições. A seleção de instruções envolve a escolha das instruções<br>
apropriadas da máquina-alvo para implementar as declarações do código intermediario. A<br>
atribuição e atribuição de registros envolve a decisão sobre os valores a serem registrados nos<br>
registros(AHO et al., 2007).<br>
Apresentar exemplo<br>
32<br>
3 TRABALHOS CORRELATOS<br>
Sugiro apenas mencionar que foi feito a revisão sistemática; o que já foi feito e os resul-<br>
tados. As outras seções sobre RS e mover para apêndice.<br>
3.1 Revisão sistemática<br>
A revisão sistemática consiste é um método de identificação, análise e interpretação de<br>
pesquisas relevantes em determinada área ou questão de pesquisa. Para execução da revisão sis-<br>
temática se requer um esforço maior, em comparação as pesquisas tradicionais, sendo necessário<br>
seguir uma sequência de passos metodológicos sobre a área ou questão de pesquisa ao qual<br>
deseja ser feita a pesquisa (KITCHENHAM, 2004).<br>
Para a execução da revisão sistemática, é necessário um esforço considerável, se com-<br>
parado a uma revisão informal a literatura. Enquanto que a revisão de literatura informal é<br>
conduzida de forma ad-hoc, sem planejamento e critérios de seleção estabelecidos a priori,<br>
a revisão sistemática requer um protocolo formal bem definido, com uma sequência de pas-<br>
sos metodológicos, para conduzir uma <span class='f1 c_9' id='c_9_1' href='#c_9_2' cs_f='.c_9' >pesquisa sobre o</span> tema ao qual deseja-se realizar a<br>
pesquisa (MAFRA; TRAVASSOS, 2006).<br>
A aplicação da revisão sistemática requer que seja seguido um conjunto bem definido e<br>
sequêncial de passos, seguindo um protocolo de pesquisa desenvolvido previamente. Através<br>
deste método é possível realizar uma extensa pesquisa, contemplando uma grande quantidade<br>
de informações sobre o assunto pesquisado (MAFRA; TRAVASSOS, 2006). Este protocolo é<br>
construído considerando um tema específico que representa o elemento central da investigação,<br>
onde os passos da pesquisa, as estratégias definidas para coletar as evidências e o foco das<br>
questões de pesquisa são definidas explicitamente, de tal forma que outros pesquisadores sejam<br>
capazes de reproduzir o mesmo protocolo de pesquisa (BIOLCHINI et al., 2005).<br>
Segundo MAFRA; TRAVASSOS, o processo para a condução de revisões sistemáticas<br>
envolve três etapas:<br>
1. Planejamento da Revisão: os objetivos da pesquisa são listados e o protocolo da revisão<br>
é definido.<br>
2. Condução da Revisão:nesta atividade, as fontes para a revisão sistemática são sele-<br>
cionadas, os estudos primários são identificados, selecionados e avaliados de acordo com<br>
os critérios de inclusão, exclusão, e de qualidade estabelecidos durante o protocolo da<br>
revisão.<br>
Chapter 3. TRABALHOS CORRELATOS 33<br>
3. Análise dos Resultados: os dados dos estudos são extraídos e sintetizados para análise e<br>
apresentação dos resultados.<br>
Vale ressaltar que como o objetivo deste trabalho é realizar um estudo exploratório de<br>
caracterização de área podemos dizer que esta revisão sistemática se caracteriza como uma quasi-<br>
sistemática (TRAVASSOS et al., 2008), pois segue o mesmo processo da revisão sistemática e<br>
preserva o rigor e mesmo formalismo para as fases metodológicas de elaboração de protocolo e<br>
execução da revisão, mas sem a aplicação de uma meta-análise a princípio, que pode ser aplicada<br>
posteriormente.<br>
3.1.1 Planejamento da Revisão Sistemática<br>
Objetivo: Este estudo tem o objetivo esquematizado <span class='f1 c_43' id='c_43_1' href='#c_43_2' cs_f='.c_43' >a partir da</span> estrutura do paradigma<br>
GQM (do ingles Goal,Question and Metric)(BASILI et al., 1994).<br>
Analisar Publicações científicas através de um estudo baseado em revisão sis-<br>
temática<br>
Com propósito de Identifica-las<br>
Com relação as Vantagens e desvantagens da utilização de assertiva e transformações<br>
de código na verificação do código na linguagem de descrição VHDL<br>
Do ponto de vista do Pesquisador<br>
No contexto Acadêmico ou industrial para verificação de assertivas na linguagem<br>
de descrição VHDL<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM<br>
Formulação da Pergunta: Buscamos respostas para as seguintes perguntas:<br>
• Q1: Quais são os métodos para verificação de circuitos lógicos descritos na linguagem de<br>
programação VHDL?<br>
– Q1.1: Foi desenvolvido e está disponível alguma ferramenta para aplicação do<br>
método?<br>
– Q1.2: Qual a técnica de exploração de estados para circuitos lógicos?<br>
– Q1.3: O método proposto é baseado em técnicas de verificação de software?<br>
– Q1.4: Como o método proposto valida pré e pós condições no programa?<br>
– Q1.3: Foi utilizado algum benchmark de programas em VHDL para experimentação<br>
e o mesmo encontra-se disponível?<br>
– Q1.4: Quais as perspectivas futuras para melhorar da aplicação do método proposto?<br>
Escopo da pesquisa:Na delimitação do escopo da pesquisa foram estabelecidos critérios,<br>
buscando garantir a viabilidade da execução, acessibilidade dos dados e abrangência do estudo re-<br>
alizado. A pesquisa dar-se-á <span class='f1 c_40' id='c_40_1' href='#c_40_2' cs_f='.c_40' >a partir de</span> bibliotecas digitais através das suas respectivas máquinas<br>
Chapter 3. TRABALHOS CORRELATOS 34<br>
de busca e, quando os dados não estiverem disponíveis eletronicamente, através de consultas<br>
manuais.<br>
Critérios de Seleção de Fontes. Para as bibliotecas digitais é desejado:<br>
• Possuir uma máquina de busca que permita <span class='f1 c_26' id='c_26_1' href='#c_26_2' cs_f='.c_26' >o uso de</span> expressões lógicas ou mecanismo<br>
equivalente.<br>
• Incluir em sua base, publicações de exatas ou correlatas que possuam relação direta com o<br>
tema a ser pesquisado<br>
• As máquinas de busca deverão permitir a busca no texto completo das publicações.<br>
Segundo ROCHA et al., os mecanismos de busca utilizados devem garantir resultados<br>
únicos através da busca de um mesmo conjunto de palavras-chaves (string de busca). Quando<br>
isto não for possível, deve-se estudar e documentar uma forma de minimizar os potenciais efeitos<br>
colaterais desta limitação.<br>
Métodos de Busca das Publicações. As fontes digitais foram acessadas via Web, através<br>
de expressões de busca pré-estabelecidas. A biblioteca digital consultada foi a Scopus, acessível<br>
em http://www.scopus.com. Segundo a editora ELSEVIER, a Scopus é uma das maiores bases<br>
de dados de resumos e citações da literatura de pesquisa peer-reviewed com mais de 22, 800<br>
títulos de mais de 5, 000 editoras internacionais abrangendo as áreas de tecnologia, medicina,<br>
artes, ciências sócias e com atualizações diárias. Entre as editoras podemos citar: Springer<br>
(SPRINGER, 2018); IEEE Xplore Digital Library (IEEE, 2018);ACM Digital Library (ACM,<br>
2018) ; ScienceDirect/Elsevier (B.V, 2018); Wiley Online Library (SONS, 2018); dentre outras.<br>
String de Busca. A string de busca foi definida segundo o padrão PICO (do inglês<br>
Population, Intervention, Comparison, Outcomes) (KITCHENHAM et al., 2009), conforme a<br>
estrutura abaixo:<br>
• População: Trabalhos publicados em conferências e periódicos que relacionam verificação<br>
de propriedades de circuitos lógicos em códigos para a descrição de hardware.<br>
• Intervenção: Verificação de propriedades relacionadas a verificação de circuitos para as<br>
diferentes estruturas das linguagens de descrição de hardware;<br>
• Comparação: análise de cobertura e suporte das abordagens identificadas para a verificação<br>
de propriedades das linguagens de descrição de hardware;<br>
• Resultados: <span class='f1 c_43' id='c_43_1' href='#c_43_2' cs_f='.c_43' >a partir da</span> descrição das abordagens pretende-se verificar a cobertura que cada<br>
abordagem apresenta na manipulação das diferentes estruturas da linguagem de descrição<br>
de hardware para a verificação de propriedades baseada em assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 35<br>
Segundo ROCHA et al., como este estudo representa <span class='f1 c_7' id='c_7_1' href='#c_7_2' cs_f='.c_7' >um estudo de</span> mapeamento/caracteri-<br>
zação, a string de busca foi definida de acordo com dois aspectos: População e Intervenção, como<br>
é apresentado na estrutura abaixo. Posteriormente esta mesma string de busca será executada<br>
na biblioteca Scopus para busca de artigos e publicações de modo a gerar uma interseção entre<br>
população e intervenção.<br>
• População: publicações que fazem referência a verificação de propriedades de circuitos<br>
lógicos e sinônimos:<br>
– Palavras-chaves: "circuit checker" OR "circuit verification" OR "contract based<br>
verification" OR "code analysis" OR "static analysis" OR "dynamic analysis" OR<br>
"safety verification" OR "RTL analysis" OR "program analysis" OR "property veri-<br>
fication" OR "formal verification" OR "model checking" OR "model checker" OR<br>
"hardware checker" OR "hardware verification" OR "validity checker" OR "hard-<br>
ware assertion" OR "assertion checker" OR "assert verification" OR "assertion-based<br>
verification" OR "assertion based verification" OR "assertion-based design" OR "bit<br>
level verification"<br>
• Intervenção: Verificação de circuitos e sinônimos:<br>
– Palavras-chaves:"hardware statement" OR "hardware code" OR "hardware source<br>
code" OR "hardware semantics" OR "hardware property" OR "logical gates" OR<br>
"sequential circuit" OR "parallel circuit" OR "real circuits" OR "complex circuits"<br>
OR "control circuitry" OR ”software netlist” OR “hardware emulation” OR “silicon<br>
debug”<br>
3.1.1.1 Procedimentos de Seleção e Critérios<br>
A estratégia de busca será aplicada por um pesquisador para identificar as publicações<br>
em potencial. A seleção das publicações dar-se-á em 2 etapas, conforme apresentado a seguir.<br>
1. Seleção e catalogação preliminar dos dados coletados: A seleção preliminar das publi-<br>
cações será feita <span class='f1 c_43' id='c_43_1' href='#c_43_2' cs_f='.c_43' >a partir da</span> aplicação da string de busca na biblioteca Scopus, o resultado<br>
desta busca corresponde a seleção preliminar. Todas as publicações serão armazenadas<br>
para análise posterior;<br>
2. Seleção dos dados relevantes - [1 filtro]: A seleção preliminar com <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >o uso da</span> expressão<br>
de busca não garante que todo o material coletado seja útil no contexto da pesquisa, pois a<br>
aplicação das expressões de busca é restrita ao aspecto sintático. Por isso, é necessário a<br>
criação de filtros de exclusão e inclusão, de modo a classificar os artigos e publicações que<br>
se enquadram no contexto da pesquisa realizada. Nesta epata apenas serão lidos o título,<br>
abstracts, e palavras-chaves e classificar de acordo com os filtros, ou seja, se será aceito ou<br>
excluído. Devem ser excluídas as publicações contidas no conjunto preliminar que:<br>
Chapter 3. TRABALHOS CORRELATOS 36<br>
• CE1-01: Não serão selecionadas publicações em que as palavras-chave da busca<br>
não apareçam no título, resumo e/ou texto da publicação (excluem-se os seguintes<br>
campos: as seções de agradecimentos, biografia dos autores, referências bibliográficas<br>
e anexas).<br>
• CE1-02: Não serão selecionadas publicações em que descrevam e/ou apresentam<br>
‘keynote speeches’, tutoriais, cursos e similares.<br>
• CE1-03: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação/validação de códigos para descrição de hardware.<br>
• CE1-04: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação de código de descrição de hardware baseado em assertivas ou propriedades<br>
de verificação de hardware.<br>
Podem ser incluídas apenas as publicações contidas no conjunto preliminar que:<br>
• CI1-01:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita uma abordagem para verificação<br>
de código de descrição de hardware baseado em assertivas ou propriedades de<br>
verificação de hardware.<br>
• CI1-02:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita recomendações de melhoria<br>
na utilização de abordagens para verificação de código de descrição de hardware<br>
baseado em assertivas ou propriedades de verificação de hardware.<br>
3. Seleção dos dados relevantes - [2 filtro]: Apesar do 1o filtro limitar o universo de busca,<br>
infelizmente não há garantias de que todo material selecionado no filtro anterior seja útil<br>
no contexto da pesquisa. Neste caso, novos filtros são gerados, buscando, da mesma forma<br>
que o primeiro filtro, classificar os artigos e publicações que se enquadram no contexto<br>
da pesquisa. Para este filtro é necessário a leitura na integras dos artigos selecionados<br>
anteriormente. O objetivo é identificar que relacionam assertivas e/ou propriedade de<br>
verificação de hardware.<br>
• CS2 -ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware e não citam assertivas<br>
• CS2 +ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware, mas citam assertivas<br>
• CS2 -ASS +VER_HARD: Não devem ser selecionadas publicações que contextual-<br>
izam verificação de hardware, mas citam assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 37<br>
Dessa forma, todas as publicações devem respeitar o critério abaixo:<br>
• CS3 +ASS +VER_HARD: Serão selecionadas publicações que contextualizam<br>
verificação de hardware e citam assertivas em seu contexto.<br>
Devido ao tempo necessário <span class='f1 c_33' id='c_33_1' href='#c_33_2' cs_f='.c_33' >para o desenvolvimento</span> execução dos filtros da revisão<br>
sistemática serem extensos, apenas o primeiro filtro foi executado neste projeto, mesmo que<br>
os parâmetros para o segundo filtro já tenho sido desenvolvidos. Em contra partida foram<br>
selecionados 6 artigos que serviram como ferramentas de estudo <span class='f1 c_33' id='c_33_1' href='#c_33_2' cs_f='.c_33' >para o desenvolvimento</span> da<br>
metodologia que será apesentada no Capítulo 4.<br>
3.2 Revisão da literatura<br>
Nesta sessão serão apresentados trabalho relevantes <span class='f1 c_33' id='c_33_1' href='#c_33_2' cs_f='.c_33' >para o desenvolvimento</span> do método<br>
proposto que foram identificados utlizando a revisão sistemática mencionado anteriormente.<br>
Os artigos apresentam técnicas de transformações de código, utilização de Assertion-Based<br>
Verification e PSL para verificação de hardware.<br>
3.2.1 V2c-A verilog to C translator<br>
O artigo de MUKHERJEE et al. apresenta uma ferramenta implementada em C++<br>
chamada v2c para transformação de código da linguagem de descrição Verilog para linguagem<br>
de programação C. A ferramenta é executada a nível de palavra, visto que esta abordagem garante<br>
uma aumento na escalabilidade, mas também proporionando que técnicas, como interpolaçãoe adicionar<br>
refer-<br>
ência<br>
aceleração de looppossam ser utilizadas para verificação, algo inviavél, caso a tradução fosse<br>
adicionar<br>
refer-<br>
ência<br>
executada a nível de bit. O sistema recebe como entrada um código em Verilg, onde são aplicadas<br>
regras semânticas e mapeando os bit de operação, chamado software netlist. Após isso, o código<br>
intermediário é convertido para C.<br>
A contribuição deste trabalhoconsiste na utilização de transformações de código como<br>
Qual<br>
tra-<br>
balho?<br>
base principal e partindo deste pressuposto torna-se vantajoso devido a utilização de outras<br>
ferramentas que não apresente suporte a certas linguagens, tais com a ferramenta ESBMC,<br>
utilizada neste trabalho, não apresenta suporte a VHDL, porém apresenta suporte as linguagens<br>
C/C++. Em outras palavras, a contribuição deste trabalhofoi a utilização de traduções de códigos<br>
Qual<br>
tra-<br>
balho?<br>
e utilizado este conceito como modelo de entrada para analise de circuitos.<br>
3.2.2 Unbounded safety verification for hardware using software ana-<br>
lyzers<br>
No artigo de MUKHERJEE et al. foi apresentado uma metodologia que aborda a utiliza-<br>
ção de técnicas e analisadores de software, com o objetivo de de abordar a análise de circuitos e<br>
Chapter 3. TRABALHOS CORRELATOS 38<br>
com isso trançar um paralelo entre as abordagens. Para testes foram utilizadas três metodologias<br>
de análise, usando interpolação, k-inductione tecnologias hibrídas. Como resultante dos testes, foi adicionar<br>
refer-<br>
ência<br>
adicionar<br>
refer-<br>
ência<br>
observado as principais causas de erros, por exemplo, bits não preciso e no caso das operações<br>
a bit-level ocorria perda de informações. Também foi obeservado que apesar de não serem<br>
otimizadas para análises de hardware, alguns analisadores de softaware podem, dependendo da<br>
técnica utilizada no analisador, ser utilizada para analise de hardware.<br>
Descrever<br>
qual<br>
o mo-<br>
tivo.<br>
A utilização de técnicas de análise de software <span class='f1 c_33' id='c_33_1' href='#c_33_2' cs_f='.c_33' >para o desenvolvimento de</span> análise de<br>
hardware é o foco a ser abordado neste neste trabalho de maneira prática, utilizando os princípio<br>
analisados por (MUKHERJEE et al., 2016a). Neste contexto, o objetivo deste trabalho é a<br>
utilização de técnicas de software para análise de circuitos, diferente do artigo apresentado acima<br>
que busca utilização uma abordagem mais complexa provando a possibilidade da utilização de<br>
técnicas de analise de software no contexto da verificação de hardware.<br>
A última frase está confusa, no meu entedimento é o mesmo sentido.<br>
3.2.3 Formal verification of timed VHDL programs<br>
No trabalho apresentado por BARA et al. é proposto uma abordagem para a análise<br>
de tempo relacionado a cada porta lógica dentro de um dado circuito analisado. A abordagem<br>
apresenta a tradução de um circuito lógico codificado em VHDL para um formalismo baseado<br>
em automato de tempo. Tal formalismo é representado por uma automato de estados finitos referência<br>
com relogios simbólicos que evoluem em taxa uniforme. A tradução é executada de modo<br>
automatico, baseado na emulação da propagação de cada transação ao longo de cada sinal, o<br>
seja, são automatos programados e cronometrados do circuito. Após a tradução para automato, a<br>
analise é feita pela ferramenta UPPALque é um model checking de verificação de propriedades referência<br>
de tempo. Seguindo esta metodologia a análise pode ser extraida de modo independente de cada<br>
bloco, desta forma a análise é feita de forma mais precisa, podendo ser analisado inumeros<br>
fatores, tais como limites de intervalo e sinal de correlação.<br>
O artigo apresenta uma abordagem de tempo, que torna-se interessante adição ao método.<br>
Porém até o momento a função não foi implementada ficando a trabalho futuros.<br>
Expandir o texto acima, exemplo, descrever como o método poderia ser incluindo no seu<br>
TCC.<br>
3.2.4 On the use of assertions for embedded-software dynamic verifica-<br>
tion<br>
Em GUGLIELMO et al. é apresentado uma metodologia para a integração dinamica de<br>
Assertion-Based Verification para várias fases da análise da verificação de fluxo em sistemas<br>
embarcados, por exemplo, emulação, diagnosticos e Debug, mas também um ferramenta chamada<br>
Chapter 3. TRABALHOS CORRELATOS 39<br>
RadCheck. O metodo de aplicação, chamado V-model é dividido em fases de verificação em<br>
paralelo com as fases de design do circuito. Com base no V-model, o método é aplicado, iniciando<br>
com o nível de sistema e as especificação do sistema, neste caso especificado usando PSL.<br>
Neste nível é especificado todas as funcionalidades gerais da aplicação. No nível de integração<br>
visa investigar problemas de interação que possam ocorrer, definindo propriedades que cobrem<br>
incrementalmente as unidades estruturais interativas de aplicação. No nível de unidade descrevem<br>
comportamentos internos e são definidas através de parâmetros de entrada/saída das unidade e<br>
estruturas de dados internas.<br>
A contribuição deste projeto está relacionado a utilização de assertivas no contexto da<br>
verificação de software. As assertivas são o principal meio de análise proposto neste projeto,<br>
visto que estas mesma assertivas serão analisadas pelo ESBMC. Aliado a isso em GUGLIELMO<br>
et al. é apresentado modelos de utilização de assertivas <span class='f1 c_36' id='c_36_1' href='#c_36_2' cs_f='.c_36' >no processo de</span> verificação de hardware,<br>
e tais assertivas foram adaptadas <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >para um modelo</span> proposto neste trabalho.<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation<br>
No trabalho de BOULE; ZILIC é apresentado uma ferramenta de geração de assertivas<br>
no contexto da emulação de circuitos, de modo que estas assertivas descrita em PSL possam<br>
transformadas para o modelo de linguagem de descrição de hardware. Inicialmente é realizada<br>
toda análise de cada assertiva e a mesma é traduzida em partes, levando em consideração os<br>
operadores e cada estrutura, por exemplo if-else, utilizado na declaração da assertiva.<br>
Apresentar um exemplo para explicar o texto acima<br>
trabalho de BOULE; ZILIC consolida e apresenta aspectos importantes, tais como a<br>
utilização de uma ferramenta para geração de assertivas, o que torna-se no contexto deste projeto,<br>
extremamente importante, visto que o modelo adotado atualmente consiste tanto na geração<br>
automática das assertivas, bem como a inserção manual por parte do usuário.<br>
40<br>
4 MÉTODO PROPOSTO<br>
Este Capítulo descreve o método proposto neste trabalho, baseado transformações de<br>
código para análise de circuitos lógicos descritos em VHDL utilizando <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >Bounded Model Checking</span>,<br>
neste caso o model checker ESBMC.<br>
4.1 Visão geral do método<br>
O método proposto consiste inicialmente em receber como entrada um circuito lógico<br>
descrito em VHDL, onde uma dada propriedade representada em uma assertiva será analisada,<br>
as assertivas serão inseridas de automaticamente pelo método ou pelo próprio usuário do método.<br>
O código VHDL analisado posteriomente é traduzido para linguagem C e recebe uma instrumen-<br>
tação de código (com funções especificas suportadas pelo método) para a posterior validação do<br>
mesmo. O Código em C automaticamente gerado, já instrumentado, será processado e analisado<br>
pelo ESBMC de acordo com as assertivas inseridas e ao final é apresentado o resultado. Caso<br>
alguma das assertivas seja violada, um contra-exemplo é apresentado ao usuário. Uma visão<br>
geral do método proposto é apresentado na Figura 16 e nas sessões a seguir serão apresentados<br>
cada etapa do método proposto neste trabalho.<br>
Figure 16 – Ciclo da ferramenta<br>
Fonte: Própria<br>
Com o intuito de auxiliar nas explicações apresentadas nas próximas sessões, o código<br>
na Figura 17 será utilizado nas explanações, bem como será apresentado todas as alterações do<br>
mesmo, conforme cada etapa do método.<br>
Chapter 4. MÉTODO PROPOSTO 41<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 ENTITY U l a _ t c c IS<br>
5 PORT(A, B , B i n v e r t i d o , Op1 , Op2 : IN BIT ;<br>
6 R e s u l t a d o :OUT BIT ) ;<br>
7 END U l a _ t c c ;<br>
8<br>
9 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
10 SIGNAL a n d _ p o r t : b i t ;<br>
11 SIGNAL o r _ p o r t : b i t ;<br>
12 SIGNAL x o r _ p o r t : b i t ;<br>
13 SIGNAL mux2x1 : b i t ;<br>
14 BEGIN<br>
15 PROCESS(A, B , B i n v e r t i d o , Op1 )<br>
16 BEGIN<br>
17 ??PORTA AND<br>
18 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
19 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
20 ELSE<br>
21 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
22 END IF ;<br>
23 ??PORTA OR<br>
24 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
25 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
26 ELSE<br>
27 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
28 END IF ;<br>
29 ??PORTA XOR<br>
30 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
31 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
32 ELSIF (A = ’ 1 ’ and mux2x1 = ’ 1 ’ ) THEN<br>
33 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
34 ELSE<br>
35 x o r _ p o r t &lt;= ’ 1 ’ ;<br>
36 END IF ;<br>
37 ??INVERSOR<br>
38 IF ( B i n v e r t i d o = ’ 0 ’ ) THEN<br>
39 mux2x1 &lt;= B ;<br>
40 ELSE<br>
41 mux2x1 &lt;= NOT B ;<br>
42 END IF ;<br>
43 ??MUX4X1<br>
44 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
45 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
46 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
47 R e s u l t a d o &lt;= o r _ p o r t ;<br>
48 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
49 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
50 END IF ;<br>
51 END PROCESS ;<br>
52 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 42<br>
4.2 Preprocessamento do VHDL e inserção de assertivas<br>
A fase inicial do método consiste no preprocessamento do código VHDL com as an-<br>
otações de código pelo usuário ou pelo método proposto de forma automática, incluindo as<br>
assertivas, conforme a Figura 16, na etapa A. O método não realiza qualquer tipo de verificação<br>
sobre o código VHDL, apenas utiliza o mesmo como entrada juntamente com as assertivas<br>
inseridas. Toda verificação é realizada sobre o código em linguagem C, que será traduzido a<br>
partir do código VHDL analisado, nas próximas etapas do método proposto. Vale ressaltar que<br>
mesmo a linguagem VHDL tendo <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >um modelo de</span> assertivas padrão, para o método tornou-se<br>
necessário a criação de um modelo (baseado em comentários) para que as funções do model<br>
checker adotado fossem suportadas, como a geração de valores não deterministicos.<br>
As assertivas manuais são adicionadas entre as tags @c2vhdl:ASSERT e @c2vhdl:END<br>
e todo trecho de código entre estas tags deve estar comentado, desta forma não apresentará<br>
erro na tradução do código em linguagem C, bem como na sintetização do código VHDL. Nas<br>
assertivas são incluidas as funções necessárias para a análise utilizando a ferramenta ESBMC. A<br>
assertiva apresenta três informações principais, sendo elas: condição, mensagem e gravidade.<br>
Ajustar está assertiva. Para quem não vê o código todo, ela não faz sentido<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR.<br>
1 ??@c2vhdl : ASSERT<br>
2 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ )<br>
3 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 "<br>
4 ??s e v e r i t y ERROR;<br>
5 ??@c2vhdl :END<br>
Fonte: Própria.<br>
A condição (na linha 2 da Figura 19) representa a assertiva propriamente dita e que será<br>
analisado pela aplicação. A condição será precedida de??assert e seguido ou não da palavra<br>
not, com isso a assertiva pode assumir valor negativo, conforme necessidade do usuário. Na<br>
Figura 19 a assertiva busca verificar se a variavél Resultado terá valor igual a 1. Qual a<br>
razão<br>
para<br>
isso,<br>
ex-<br>
plique!<br>
A mensagem (??report na linha 3 da Figura 19) é definida pelo usuário e será<br>
apresentado caso a assertiva apresente falha, assim a mensagem pode ser utilizada como um meio<br>
de depuração das propriedades validadas. A severidade (severity na linha 4 da Figura 19)<br>
pode ser definida como error, que representa um erro fatal e parada da verificação. A severidade<br>
do tipo warning que representa um erro não fatal, contabiliza as falhas das assertivas, porém<br>
não causa a parada da verificação. As mensagens futuramente pode ser integradas um framework<br>
para teste de unidade, contudo está é uma etapa ainda em planejamento neste trabalho.<br>
Juntamente com as assertivas outra função que pode ser utilizada é a função __ESBMC<br>
Chapter 4. MÉTODO PROPOSTO 43<br>
_assume() suportada pelo model checker ESBMC. Esta função utilizada em conjuto com a<br>
ferramenta ESBMC permite que durante a verificação uma variavél possa ter uma valor setado<br>
durante o tempo de execução da verificação. A importância desta função é fazer verificações onde<br>
se conhece os valores de entrada juntamente com o valor resultante, por exemplo, na verificação<br>
de portas lógicas.<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume().<br>
1 ??__ESBMC_assume (A = ’ 1 ’ )<br>
2 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
Fonte: Própria.<br>
A assertivas que serão verificadas são automáticas traduzidas a partir das entradas do<br>
código VHDL. Seja no modelo manual (assertivas escritas pelo usuário) ou automático (inferidas<br>
pelo método proposto por meio de análise estática), as entradas são mapeadas para serem<br>
utilizados na etapa de instrumentação. Desta forma, tais entradas podem ser utilizadas para gerar<br>
essas assertivas e então serem adicionadas diretamente ao código em linguagem C durante a fase<br>
de instrumentação.<br>
A Figura 20 apresenta o código juntamente com as assertivas conforme o padrão salien-<br>
tado na section 4.2. Neste exemplo foi implementado utilizado a inserção manual das assertivas<br>
e também da função __ESBMC_assume(), entretanto o objetivo é automatizar estas funções<br>
durante a execução da ferramenta.<br>
4.3 Tradução de código VHDL para a linguagem C<br>
Nesta etapa a tradução do código VHDL para linguagem C é executada, conforme<br>
apresentado na Figura 16, etapa B. A partir deste ponto, a ferramenta é executada de maneira<br>
propriamente dita, tendo todo o processo automatizado até a apresentação do resultado. Para<br>
esta etapa do método foi selecionado a ferramenta V2Cque realiza a tradução de VHDL para Adicionar<br>
refer-<br>
ência<br>
Linguagem C.<br>
A ferramenta V2C apresenta diversas vantagens em relação a equivalência de tradução<br>
de linguagens, contudo V2C apresenta certas limitação na tradução do código VHDL, em outras<br>
palavras, a mesma não reconhece algumas estruturas especificas do VHDL. A ferramenta aceita<br>
apenas entradas e saídas do tipo: bit, std_ulogic, qsim_state, std_ulogic_vector<br>
e interger. Na parte de arquitetura, a ferramenta aceita uma gama maior de estruturas, tra-<br>
balhando com expressoões do tipo: signal, variable, integers, strings e caracteres.<br>
Em expreções condicionais os operandos são AND, OR, NOT &lt;=, =&gt;,=,&lt;,&gt; e &lt;&gt;. Aceita<br>
também a estrutura de process, além da estutura block. A estrutura process é limitada<br>
Chapter 4. MÉTODO PROPOSTO 44<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 . . .<br>
4 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
5 SIGNAL a n d _ p o r t : b i t ;<br>
6 SIGNAL o r _ p o r t : b i t ;<br>
7 SIGNAL x o r _ p o r t : b i t ;<br>
8 SIGNAL mux2x1 : b i t ;<br>
9 BEGIN<br>
10 PROCESS(A, B , B i n v e r t i d o , Op1 ) IS<br>
11 BEGIN<br>
12 ??PORTA AND<br>
13 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
14 ??__ESBMC_assume (A = ’ 1 ’ )<br>
15 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
16 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
17 ELSE<br>
18 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
19 END IF ;<br>
20 . . .<br>
21 ??MUX4X1<br>
22 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
23 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
24 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
25 R e s u l t a d o &lt;= o r _ p o r t ;<br>
26 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
27 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
28 ??@c2vhdl : ASSERT<br>
29 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
30 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
31 ??s e v e r i t y ERROR;<br>
32 ??@c2vhdl :END<br>
33 END IF ;<br>
34 END PROCESS ;<br>
35 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
apenas a: if-else, case e loops. Como trabalho futuro, neste trabalho tem-se buscado<br>
novas abordagens para ampliar o suporte a estruturas não suportadas pelo V2C.<br>
Na tradução é necessário substituir os operadores originais por seus equivalentes em<br>
linguagem C. A excessão são os operadore específicos que gerenciam os valores de bit, tais<br>
como concatenação ou manipulação de partes vertoriais, para os quais são necessários construir<br>
procedimentos especificos em C.<br>
Conforme mostrado na Figura 21, na tradução são gerados vários vetores para suporte<br>
a tradução dos sinais representados no VHDL, sendo eles chg[], old[] e new[]. O vetor<br>
old[] contém o valor do sinais do passo anteriore a partir deste vetor o valor a ser usado nos Confuso<br>
issocálculo é obtido. O vetor new[] representa os novos valores a serem calculados pelos antigose<br>
Qual?<br>
Chapter 4. MÉTODO PROPOSTO 45<br>
o vetor chg[] contém um or exclusivo entre o valor novo e antigo e em caso de alteração entre<br>
os valores é copiado o valor de new[] para old[].<br>
O texto acima está muito confuso, corrigi rapidamente<br>
No código C gerado, os vetores in_data[] e out_data[] contêm os sinais de<br>
entrada e saída, respectivamente. No caso de circuitos sequênciais, o valor do status é inserido<br>
no primeiro (índice 0). A funçãoentão lerá os valores in_data[] e escreverá os resultados do qual?<br>
processamento em out_data[]. Ao final da operações os valores de estado são passado para<br>
out_data[].<br>
Conforme especificado e seguindo os parametros da ferramenta, a mesma realiza a<br>
tradução, mantendo inalterado qualquer fragmento de código que esteja comentado, neste caso,<br>
as assertivas presentes no código VHDL permanecem inalteradas, sendo utilizadas na próxima<br>
etapa do método proposto.<br>
4.4 Instrumentação de código<br>
As assertivas após a tradução permanecem comentadas, sendo necessário prepara-lás, ou<br>
seja traduzi-las, para verificação posterior do código na linguagem em C. Com isso é necessário<br>
uma instrumentação do código para prover suporte as assertivas traduzidas para análise, conforme<br>
apresentado na Figura 16, etapa C.<br>
Todas as etapas da instrumentação são realizados sobre o código C já traduzido. O passo<br>
inicial da instrumentação é a adição da macros no inicio do código C com as definição das<br>
assertivas a serem utilizadas. Na Figura 22 são apresentados os macros utilizadas no código C. A<br>
Linha 1 da figura corresponde a mensagem de erro a ser apresentada e a Linha 2 corresponde<br>
ao modelo da assertiva e a chamanda da macro definida na Linha 1 em caso de falha. Estas<br>
definições para as assertivas também podem ser utilizadas no código C traduzidos sem o uso do<br>
ESBMC.<br>
Figure 22 – Macros das assertivas implementadas em linguagem C<br>
1 # <span class='f1 c_32' id='c_32_1' href='#c_32_2' cs_f='.c_32' >d e f</span> i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r ,M, __FILE__ , __LINE__ , # # __VA_ARGS__ )<br>
2 # <span class='f1 c_32' id='c_32_1' href='#c_32_2' cs_f='.c_32' >d e f</span> i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
Fonte: Própria.<br>
O passo seguinte é a identificação das assertivas comentadas ao longo do corpo do<br>
código traduzido, utilizando o exemplo da Figura 23. As assertivas são identificadas através<br>
das tags @c2vhdl:ASSERT e @c2vhdl:END e a busca é realizado através destas tags. Ao<br>
ser encontrado a tag @c2vhdl:ASSERT, é realizado um loop até que seja encontrada a tag<br>
Chapter 4. MÉTODO PROPOSTO 46<br>
@c2vhdl:END e com isso toda a assertiva inserida possa ser passada a função de busca das<br>
informações da assertiva contidas entre as tags apresentadas.<br>
Com os dados das assertivas obtidos é realizado a busca da condição, mensagem e<br>
severidade através dos comandos ??assert, ??report e ??severity respectivamente.<br>
Estas informações são encontradas através do uso e uma Regex no código e que são adicionadas<br>
ao código C seguindo o modelo definido na macro. Este processo é repetido até outra assertiva<br>
ser encontrada ou caso chegue ao fina do código C.<br>
Com a função __ESBMC_assume() ocorre processo semelhante ao das assertivas.<br>
Utilizando novamente uma regex que realiza a busca por esta função no código e é retirado o<br>
comentário da mesma, desta forma a mesma passa a esta acessivél para o ESBMC, visto que a<br>
declaração da mesma já segue o modelo padrão a ser utilizado pelo ESBMC.<br>
Durante a instrumentação de código também é realizado a entrada de sinais não de-<br>
terministicos para variaveis não inicializadas ou argumentos de funções do código C gerado<br>
da tradução, utilizando a função __VERIFIER_nondet_int(). Esta função é utilizada em<br>
todas as variaveis de entrada e também nos sinais criados ao longo da arquitetura. Desta forma,<br>
todas as variavéis necessárias são inicializadas para verificação.<br>
Explicar o funcionamento do nondet com o ESBMC<br>
Em outras palavras, na instrumentação de código é realizado a traduçao das assertivas do<br>
modelo utilizado no código VHDL para para o modelo utilizado em linguagem C, além como de<br>
outras funções que possam ser utilizados pelo VHDL. Ao final da instrumentação o código C<br>
fica disponivel para que possa ser dado como entrada para outras ferramentas de verificação de<br>
código e não apenas o ESBMC.<br>
4.5 Verificação de assertivas usando Model Checker<br>
O model checker adotado no desenvolvimento de método é o ESBMCna versão 3.0.0 referência<br>
e conforme explicado na subsection 2.2.3, esta ferramenta recebe como entrada um código C<br>
ou C++ e devido a isso foi escolhida neste projeto. Nesta seção será apresentado a etapa D do apresentar<br>
outras<br>
vanta-<br>
gens<br>
métod proposto na Figura 16.<br>
Para a verificação, a primeira etapa é a identificação das assertivas no código C analisado,<br>
para isso é utilizado uma opção do ESBMC (??show-claims), mais especificamente as<br>
assertivas instrumentadas no código C analisado. Cada assertiva é identificada através de uma<br>
numeração de acordo com a ordem de busca do código analisado. Cada assertiva encontrada é<br>
armazenada para que seja realizada uma análise individual de cada claim, ou seja, assertiva.<br>
Chapter 4. MÉTODO PROPOSTO 47<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas.<br>
1 VAR<br>
2 c o n t a d o r : i n t e i r o<br>
3 c l a i m : l i s t a<br>
4 c l a i m _ s t r i n g : s t r i n g<br>
5<br>
6 FUNCAO c a l l _ e s b m c : a r q u i v o<br>
7 c o n t a d o r &lt;?0<br>
8 INICIO<br>
9 s a i d a &lt;?f un ca o de g e r a c a o das c l a i m s p e l o ESBMC<br>
10 ENQUANTO c o n t a d o r &lt; s a i d a FACA<br>
11 c o n t a d o r +=2<br>
12 r e g e x p a r a p r o c u r a r c l a i m e numeracao da c l a i m<br>
13 SE e n c o n t r a r c l a i m ENTAO<br>
14 r e g e x p a r a p r o c u r a r a p a l a v r a " a s s e r t i o n "<br>
15 SE e n c o n t r a r a p a l a v r a " a s s e r t i o n " ENTAO<br>
16 c o n t a d o r +=1<br>
17 A d i c i o n a a numeracao da c l a i m na l i s t a<br>
18 FIM?SE<br>
19 FIM?SE<br>
20 FIM?ENQUANTO<br>
21 FIM?FUNCAO<br>
Fonte: Própria.<br>
Na Linha 9 da Figura 24 é apresentado a chamada da ferramenta ESBMC que ocorre e<br>
através da opção ??show-claims lista todas as claims presentes no texto, como apresentado<br>
na Figura 25. Como o ESBMC infere de forma automatica assertivas a serem verificadas no<br>
código. Visando isolar somente as assertivas instrumentadas pelo método proposto, juntamente<br>
com a opção –show-claims é utilizado as opções:<br>
• ??no-pointer-check: para não realizar a checagem de ponteiros no código;<br>
• ??no-div-by-zero-check: para não realizar a checagem de divisões por zero no<br>
código; e<br>
• ??no-bounds-check: para não realizar a checagem de array bounds no código.<br>
Chapter 4. MÉTODO PROPOSTO 48<br>
Figure 25 – Imagem de claims contendo assertivas.<br>
Fonte:Própria<br>
Após a listagem das claims com assertivas ser gerada, outra função, indicada na Figura 26,<br>
é chamada para verificação de cada claim individualmente. Para cada claim, ocorre a chamada do<br>
ESBMC, utilizando as opções ??no-pointer-check, ??no-div-by-zero-check e<br>
??no-bounds-check, juntamente com a opção ??unwind em que realiza o número de<br>
desdobramentos dos laços no código analisado.<br>
Contudo, dependendo da complexidade da assertiva, faz-se necessário aumentar o número<br>
de desdobramentos que, por padrão são dez, conforme análise experimentais. A função é chamada<br>
na Linha 11 da Figura 26 e após a analise da claim é realizado a busca do resultado e exibição<br>
caso seja uma propriedade violada.<br>
Desta forma o ESBMC realiza apenas a checagem necessária dentro da assertiva, evitando<br>
que outros parâmetros sejam verificados, sem a devida necessidade do mesmo. Ao final de todos<br>
os desdobramentos é apresentado o resultado, apresentado na Figura 27, sendo positiva (sem<br>
erros) ou negativa (com violação de propriedades), dependendo da assertiva e do código analisado.<br>
Este processo se repete até a lista de assertivas ser finalizada.<br>
Chapter 4. MÉTODO PROPOSTO 49<br>
Figure 26 – Pseudocódigo da função de análise das claims.<br>
1 VAR<br>
2 c o n t a d o r 1 : i n t e i r o<br>
3 c o n t a d o r 2 : i n t e i r o<br>
4 r e s u l t a d o : l i s t a<br>
5<br>
6 FUNCAO esbmc_c la ims : l i s t a , a r q u i v o<br>
7 c o n t a d o r 1 &lt;?0<br>
8 c o n t a d o r 2 &lt;?0<br>
9 busca p e l o nome da fu nc a o no a r q u i v o<br>
10 ENQUANTO c o n t a d o r &lt; l i s t a FACA<br>
11 s a i d a &lt;?Execu ta comando de a n a l i s e da c l a i m<br>
numerada na l i s t a<br>
12 ENQUANTO c o n t a d o r 2 &lt; s a i d a<br>
13 Regex busca se a p r o p r i e d <span class='f1 c_42' id='c_42_1' href='#c_42_2' cs_f='.c_42' >a d e f</span> o i v i o l a d a<br>
14 SE p r o p r i e d <span class='f1 c_42' id='c_42_1' href='#c_42_2' cs_f='.c_42' >a d e f</span> o i v i o l a d a ENTAO<br>
15 Pu la p a r a l i n h a da v i o l a ç ã o<br>
16 A d i c i o n a o e r r o ao r e s u l t a d o<br>
17 FIM?SE<br>
18 FIM?ENQUANTO<br>
19 FIM?ENQUANTO<br>
20 FIM?FUNCAO<br>
Fonte: Própria.<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta.<br>
Fonte:Própria<br>
Ajustar os códigos, alguns estao muito grandes e com trechos desnecessário, não foi<br>
citado o link do repo da ferramenta<br>
Chapter 4. MÉTODO PROPOSTO 50<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C.<br>
1 void u l a _ t c c ( i n t i n _ d a t a [ ] , i n t o u t _ d a t a [ ] )<br>
2 {<br>
3 i n t _ i _ =0;<br>
4 i n t _c on t_ ;<br>
5 enum s e g n a l e {A, B , B i n v e r t i d o , Op1 , Op2 , R e s u l t a d o , and_po r t , o r _ p o r t ,<br>
6 x o r _ p o r t , mux2x1 , _MAX_} ;<br>
7 i n t o l d [_MAX_ ] ;<br>
8 i n t new [_MAX_ ] ;<br>
9 i n t chg [_MAX_ ] ;<br>
10 new [A] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
11 new [B] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
12 new [ B i n v e r t i d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
13 new [ Op1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
14 new [ Op2 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
15 new [ R e s u l t a d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
16 new [ a n d _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
17 new [ o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
18 new [ x o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
19 new [ mux2x1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
20<br>
21 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
22 {<br>
23 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
24 }<br>
25 new [A] = i n _ d a t a [ 1 ] ;<br>
26 new [B] = i n _ d a t a [ 2 ] ;<br>
27 new [ B i n v e r t i d o ] = i n _ d a t a [ 3 ] ;<br>
28 new [ Op1 ] = i n _ d a t a [ 4 ] ;<br>
29 new [ Op2 ] = i n _ d a t a [ 5 ] ;<br>
30<br>
31 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
32 {<br>
33 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
34 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
35 }<br>
36<br>
37 do {<br>
38 _ co n t _ =0;<br>
39 /? S t a r t o f T r a n s l a t i o n ? /<br>
40<br>
41 /? p0 : ? /<br>
42 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
43 /?PORTA AND ? /<br>
44 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
45 \ \ __ESBMC_assume ( o l d [A] = 1) ;<br>
46 \ \ __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
47 new [ a n d _ p o r t ] = 1 ;<br>
48 }<br>
49 e l s e {<br>
50 new [ a n d _ p o r t ] = 0 ;<br>
51 }<br>
52 /?PORTA OR ? /<br>
53 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
54 new [ a n d _ p o r t ] = 0 ;<br>
55 }<br>
56 e l s e {<br>
57 new [ a n d _ p o r t ] = 1 ;<br>
58 }<br>
59 /?PORTA XOR ? /<br>
60 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
61 new [ x o r _ p o r t ] = 0 ;<br>
62 }<br>
63 e l s e i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==1) ) {<br>
64 new [ x o r _ p o r t ] = 0 ;<br>
65 }<br>
66 e l s e {<br>
67 new [ x o r _ p o r t ] = 1 ;<br>
68 }<br>
69 /? INVERSOR ? /<br>
70 i f ( ( o l d [ B i n v e r t i d o ]==0) ) {<br>
71 i f ( chg [B ] ) {<br>
72 new [ mux2x1 ]= o l d [B ] ;<br>
73 }<br>
74 }<br>
75 e l s e {<br>
76 i f ( chg [B ] ) {<br>
77 new [ mux2x1 ]=~ o l d [B ] ;<br>
78 }<br>
79 }<br>
80 /?MUX4X1 ? /<br>
81 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
82 i f ( chg [ a n d _ p o r t ] ) {<br>
83 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
84 \ \ @c2vhdl : ASSERT<br>
85 \ \ a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
86 \ \ r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
87 \ \ s e v e r i t y ERROR;<br>
88 \ \ @c2vhdl :END<br>
89 }<br>
90 }<br>
91 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
92 i f ( chg [ o r _ p o r t ] ) {<br>
93 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
94 }<br>
95 }<br>
96 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
97 i f ( chg [ x o r _ p o r t ] ) {<br>
98 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
99 }<br>
100 }<br>
101 }<br>
102<br>
103 /? End o f T r a n s l a t i o n ? /<br>
104 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
105 {<br>
106 i f ( new [ _ i _ ] ! = o l d [ _ i _ ] ) _ con t_ =1;<br>
107 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
108 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
109 }<br>
110 } whi le ( _c on t_ ) ;<br>
111<br>
112 new [A] &= 0X01 ;<br>
113 new [B] &= 0X01 ;<br>
114 new [ B i n v e r t i d o ] &= 0X01 ;<br>
115 new [ Op1 ] &= 0X01 ;<br>
116 new [ Op2 ] &= 0X01 ;<br>
117 new [ R e s u l t a d o ] &= 0X01 ;<br>
118 new [ a n d _ p o r t ] &= 0X01 ;<br>
119 new [ o r _ p o r t ] &= 0X01 ;<br>
120 new [ x o r _ p o r t ] &= 0X01 ;<br>
121 new [ mux2x1 ] &= 0X01 ;<br>
122<br>
123 o u t _ d a t a [ 0 ] = 0 ; _ i _ =0;<br>
124 o u t _ d a t a [ 0 ] | = new [A] &lt;&lt; _ i _ ; _ i _ +=1;<br>
125 o u t _ d a t a [ 0 ] | = new [B] &lt;&lt; _ i _ ; _ i _ +=1;<br>
126 o u t _ d a t a [ 0 ] | = new [ B i n v e r t i d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
127 o u t _ d a t a [ 0 ] | = new [ Op1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
128 o u t _ d a t a [ 0 ] | = new [ Op2 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
129 o u t _ d a t a [ 0 ] | = new [ R e s u l t a d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
130 o u t _ d a t a [ 0 ] | = new [ a n d _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
131 o u t _ d a t a [ 0 ] | = new [ o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
132 o u t _ d a t a [ 0 ] | = new [ x o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
133 o u t _ d a t a [ 0 ] | = new [ mux2x1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
134<br>
135 o u t _ d a t a [ 1 ] = new [ R e s u l t a d o ] ;<br>
136 }<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 51<br>
Figure 23 – Código com assertivas traduzida para linguagem C<br>
1 # inc lude &lt; s t d i o . h&gt;<br>
2 # <span class='f1 c_32' id='c_32_1' href='#c_32_2' cs_f='.c_32' >d e f</span> i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r , M , __FILE__ , __LINE__ , ##<br>
__VA_ARGS__ ) / / Update t o p r i n t t h e t r a c e<br>
3 # <span class='f1 c_32' id='c_32_1' href='#c_32_2' cs_f='.c_32' >d e f</span> i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
4<br>
5 . . .<br>
6<br>
7 do {<br>
8 _co n t _ =0;<br>
9 /? S t a r t o f T r a n s l a t i o n ? /<br>
10 chg [A] = __VERIFIER_nondet_int ( ) ;<br>
11 chg [B] = __VERIFIER_nondet_int ( ) ;<br>
12 chg [ B i n v e r t i d o ] = __VERIFIER_nondet_int ( ) ;<br>
13 chg [ Op1 ] = __VERIFIER_nondet_int ( ) ;<br>
14 chg [ a n d _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
15 chg [ R e s u l t a d o ] = __VERIFIER_nondet_int ( ) ;<br>
16 chg [ o r _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
17 chg [ mux2x1 ] = __VERIFIER_nondet_int ( ) ;<br>
18<br>
19 /? p0 : ? /<br>
20 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
21 /?PORTA AND ? /<br>
22 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
23 __ESBMC_assume ( o l d [A] = 1) ;<br>
24 __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
25 new [ a n d _ p o r t ] = 1 ;<br>
26 }<br>
27 e l s e {<br>
28 new [ a n d _ p o r t ] = 0 ;<br>
29 }<br>
30<br>
31 . . .<br>
32<br>
33 /?MUX4X1 ? /<br>
34 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
35 i f ( chg [ a n d _ p o r t ] ) {<br>
36 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
37 __MY_asser t ( new [ R e s u l t a d o ] == 1 , "O r e s u l t a d o é d i f e r e n t e de 0 " ) ;<br>
38 }<br>
39 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
40 i f ( chg [ o r _ p o r t ] ) {<br>
41 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
42 }<br>
43 }<br>
44 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
45 i f ( chg [ x o r _ p o r t ] ) {<br>
46 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
47 }<br>
48 }<br>
49 }<br>
50<br>
51 /? End o f T r a n s l a t i o n ? /<br>
52 . . .<br>
Fonte: Própria.<br>
52<br>
5 CRONOGRAMA<br>
53<br>
6 CONSIDERAÇÕES PARCIAIS E<br>
TRABALHOS FUTUROS<br>
O trabalho aborda <span class='f1 c_45' id='c_45_1' href='#c_45_2' cs_f='.c_45' >o desenvolvimento de um</span> método para análise de circuitos lógicos de-<br>
scrito em VHDL através da aplicação de técnica de transformação de código e a técnica Bounded<br>
Model Cheking. Este método tem como objetivo de explorar os estados alcanç alcançáveis no<br>
circuito, e dessa forma identificar erros que possam resutar em mal funcionamento do sistema.<br>
Entre as dificuldade encontradas, a principal esta ligada a etapa de tradução de código.<br>
Devido a ferramenta utilizada inicialmente conter diversas limitações, a mesma diminui a eficácia<br>
da ferramenta, pois a quantidade de estruturas que podem ser utilizadas é limitada e com isso<br>
limitando também o processo de criação de protótipos.<br>
Os trabalhos futuros é necessário buscar uma nova ferramenta ou método de tradução<br>
que tenha uma gama maior de tradução, seja em estruturas ou palavras reservadas,deste forma<br>
o método desenvlvido torna-se mais eficiente e gerando uma menor intervenção do usuário no<br>
código VHDL. A melhoria na tradução de código também beneficia ageração das assertivas<br>
automáticamente, pois com uma gama maior de estruturas suportadas, mais assertivas podem ser<br>
geradas.<br>
Além disso a geração automática das assertivas é Outro ponto abordado, já sitado anterior-<br>
mente, é a geração automática das assertivas, visto que na estapa atual ainda nõ foi implementado.<br>
Este recuros visa da liberdade ao desenvolvedor promovendo de maneira automática os teste<br>
sobre o código, não necessitando que uma intervenção, tornando a inserção manual apenas em<br>
casos especificos de testes.<br>
54<br>
BIBLIOGRAPHY<br>
ABE, J. Introducao a Logica Para a Ciencia Da Computacao. Arte & Ciência, 2002. ISBN<br>
9788574730455. Disponível em: &lt;https://books.google.com.br/books?id=AgBJdjoNPwUC&gt;.<br>
ACM. 2018. Acessado em: 01 de março de 2018. Disponível em: &lt;http://dl.acm.org/&gt;.<br>
AHO, A. V.; SETHI, R.; ULLMAN, J. D. Compilers: principles, techniques, and tools. [S.l.]:<br>
Addison-wesley Reading, 2007. v. 2.<br>
ALLEN, F. E. Control flow analysis. In: ACM. ACM Sigplan Notices. [S.l.], 1970. v. 5, n. 7, p.<br>
1–19.<br>
BAIER, C.; KATOEN, J.-P.; LARSEN, K. G. Principles of model checking. [S.l.]: MIT press,<br>
2008.<br>
BARA, A. et al. Formal verification of timed vhdl programs. In: IET. FDL. [S.l.], 2010. p.<br>
80–85.<br>
BASILI, V. R.; CALDIERA, G.; ROMBACH, H. D. Experience factory. Encyclopedia of<br>
software engineering, Wiley Online Library, 1994.<br>
BENSALEM, S.; LAKHNECH, Y. Automatic generation of invariants. Formal Methods in<br>
System Design, Springer, v. 15, n. 1, p. 75–92, 1999.<br>
BIERE, A. The aiger and-inverter graph (aig) format. Available at http://fmv.jku.at/aiger, 2016.<br>
BIOLCHINI, J. et al. Systematic review in software engineering. System Engineering and<br>
Computer Science Department COPPE/UFRJ, Technical Report ES, v. 679, n. 05, p. 45, 2005.<br>
BOULE, M.; ZILIC, Z. Incorporating efficient assertion checkers into hardware emulation. In:<br>
IEEE. Computer Design: VLSI in Computers and Processors, 2005. ICCD 2005. Proceedings.<br>
2005 IEEE International Conference on. [S.l.], 2005. p. 221–228.<br>
BOULE, M.; ZILIC, Z. Efficient automata-based assertion-checker synthesis of seres for<br>
hardware emulation. In: IEEE COMPUTER SOCIETY. Proceedings of the 2007 Asia and South<br>
Pacific Design Automation Conference. [S.l.], 2007. p. 324–329.<br>
BRAYTON, R.; MISHCHENKO, A. Abc: An academic industrial-strength verification tool. In:<br>
SPRINGER. Computer Aided Verification. [S.l.], 2010. p. 24–40.<br>
B.V. 2018. Acessado em 1 de março de 2018. Disponível em: &lt;http://www.sciencedirect.com/&gt;.<br>
CABODI, G. et al. Hardware model checking competition 2014: an analysis and comparison of<br>
solvers and benchmarks. Journal on Satisfiability, Boolean Modeling and Computation, v. 9, p.<br>
135–172, 2016.<br>
CAPPELATTI, D. Praticando VHDL. Editora Feevale, 2010. ISBN 9788577171200. Disponível<br>
em: &lt;https://books.google.com.br/books?id=z4\_CYog\_UskC&gt;.<br>
Bibliography 55<br>
CHRISTEN, E.; BAKALAR, K. Vhdl-ams-a hardware description language for analog and<br>
mixed-signal applications. IEEE Transactions on Circuits and Systems II: Analog and Digital<br>
Signal Processing, IEEE, v. 46, n. 10, p. 1263–1272, 1999.<br>
CHU, P. P. RTL hardware design using VHDL: coding for efficiency, portability, and scalability.<br>
[S.l.]: John Wiley & Sons, 2006.<br>
CLARKE, E. et al. Verification of hybrid systems based on counterexample-guided abstraction<br>
refinement. In: SPRINGER. TACAS. [S.l.], 2003. v. 3, p. 192–207.<br>
CLARKE, E. M. The birth of model checking. In: 25 Years of Model Checking. [S.l.]: Springer,<br>
2008. p. 1–26.<br>
CLARKE, E. M.; GRUMBERG, O.; LONG, D. E. Model checking and abstraction. ACM<br>
transactions on Programming Languages and Systems (TOPLAS), ACM, v. 16, n. 5, p.<br>
1512–1542, 1994.<br>
CORDEIRO, L.; FISCHER, B.; MARQUES-SILVA, J. Smt-based <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >bounded model checking</span> for<br>
embedded ansi-c software. IEEE Transactions on Software Engineering, IEEE, v. 38, n. 4, p.<br>
957–974, 2012.<br>
COUSOT, P.; COUSOT, R. A gentle introduction to formal verification of computer systems by<br>
abstract interpretation. [S.l.]: IOS Press, 2010.<br>
DAHAN, A. et al. Combining system level modeling with assertion based verification. In: Sixth<br>
international symposium on quality electronic design (isqed’05). [S.l.: s.n.], 2005. p. 310–315.<br>
ISSN 1948-3287.<br>
D’SILVA, V.; KROENING, D.; WEISSENBACHER, G. A survey of automated techniques<br>
for formal software verification. IEEE Transactions on Computer-Aided Design of Integrated<br>
Circuits and Systems, IEEE, v. 27, n. 7, p. 1165–1178, 2008.<br>
ELSEVIER. 2017. Acessado em: 01 março 2018. Disponível<br>
em: &lt;https://www.elsevier.com/__data/assets/pdf_file/0007/69451/<br>
0597-Scopus-Content-Coverage-Guide-US-LETTER-v4-HI-singles-no-ticks.pdf&gt;.<br>
G1. Acidente foi provocado por falha em circuito eletrônico, diz se-<br>
cretário. 2012. Disponível em: &lt;http://g1.globo.com/sao-paulo/noticia/2012/05/<br>
acidente-foi-provocado-por-falha-em-circuito-eletronico-diz-secretario.html&gt;.<br>
GUGLIELMO, G. D. et al. On the use of assertions for embedded-software dynamic verification.<br>
In: IEEE. Design and Diagnostics of Electronic Circuits & Systems (DDECS), 2012 IEEE 15th<br>
International Symposium on. [S.l.], 2012. p. 330–335.<br>
GUPTA, A. Formal hardware verification methods: A survey. In: SPRINGER. Computer-Aided<br>
Verification. [S.l.], 1992. p. 5–92.<br>
HALDER, A.; VENKATESWARLU, A. A study of petri nets modeling analysis and simulation.<br>
Department of Aerospace Engineering Indian Institute of Technology Kharagpur, India, 2006.<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Interpolation and symbol elimination in vampire.<br>
Automated Reasoning, Springer, p. 188–195, 2010.<br>
Bibliography 56<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Case studies on invariant generation using a<br>
saturation theorem prover. Advances in Artificial Intelligence, Springer, p. 1–15, 2011.<br>
IDOETA, I. V.; CAPUANO, F. G. Elementos de eletrônica digital. [S.l.]: Livros Erica, 1982.<br>
IEC/IEEE International Standard - Behavioural languages - Part 1-1: VHDL Language<br>
Reference Manual. IEC 61691-1-1:2011(E) IEEE Std 1076-2008, p. 1–648, May 2011.<br>
IEEE. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http://ieeexplore.ieee.org/<br>
Xplore/home.jsp&gt;.<br>
IEEE Standard for Property Specification Language (PSL). IEEE Std 1850-2010 (Revision of<br>
IEEE Std 1850-2005), p. 1–182, April 2010.<br>
IEEE Standard for Verilog Hardware Description Language. IEEE Std 1364-2005 (Revision of<br>
IEEE Std 1364-2001), p. 1–560, 2006.<br>
KITCHENHAM, B. Procedures for performing systematic reviews. Keele, UK, Keele University,<br>
v. 33, n. 2004, p. 1–26, 2004.<br>
KITCHENHAM, B. et al. Systematic literature reviews in software engineering–a systematic<br>
literature review. Information and software technology, Elsevier, v. 51, n. 1, p. 7–15, 2009.<br>
KNOOP, J.; RÜTHING, O.; STEFFEN, B. Partial dead code elimination. [S.l.]: ACM, 1994.<br>
v. 29.<br>
KOSCIANSKI, A.; SOARES, M. dos S. Qualidade de Software - 2a Edição: Aprenda as<br>
metodologias e técnicas mais modernas <span class='f1 c_33' id='c_33_1' href='#c_33_2' cs_f='.c_33' >para o desenvolvimento de</span> software. Novatec,<br>
2007. ISBN 9788575221129. Disponível em: &lt;https://books.google.com.br/books?id=<br>
O9aWoUq6L88C&gt;.<br>
KROPF, T. Introduction to Formal Hardware Verification. Springer Berlin Heidelberg,<br>
2013. ISBN 9783662038093. Disponível em: &lt;https://books.google.com.br/books?id=<br>
7ImrCAAAQBAJ&gt;.<br>
MAFRA, S. N.; TRAVASSOS, G. H. Estudos primarios e secundarios apoiando a busca por<br>
evidencia em engenharia de software. Relatorio Tecnico, RT-ES, v. 687, n. 06, 2006.<br>
MUKHERJEE, R. et al. Unbounded safety verification for hardware using software analyzers.<br>
In: EDA CONSORTIUM. Proceedings of the 2016 Conference on Design, Automation & Test in<br>
Europe. [S.l.], 2016. p. 1152–1155.<br>
MUKHERJEE, R.; TAUTSCHNIG, M.; KROENING, D. v2c–a verilog to c translator. In:<br>
SPRINGER. International Conference on Tools and Algorithms for the Construction and<br>
Analysis of Systems. [S.l.], 2016. p. 580–586.<br>
MURATA, T. Petri nets: Properties, analysis and applications. Proceedings of the IEEE, IEEE,<br>
v. 77, n. 4, p. 541–580, 1989.<br>
RAMESH, U. B. K.; SENTILLES, S.; CRNKOVIC, I. Energy management in embedded<br>
systems: Towards a taxonomy. In: IEEE PRESS. Proceedings of the First International<br>
Workshop on Green and Sustainable Software. [S.l.], 2012. p. 41–44.<br>
ROCHA, H. et al. Exploiting safety properties in <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >bounded model checking</span> for test cases<br>
generation of c programs. 2010.<br>
Bibliography 57<br>
ROCHA, H. et al. Model checking embedded c software using k-induction and invariants<br>
(extended version). arXiv preprint arXiv:1509.02471, 2015.<br>
ROCHA, H. O. et al. Verificacao de sistemas de software baseada em transformacoes de codigo<br>
usando <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >bounded model checking</span>. Universidade Federal do Amazonas, 2015.<br>
SARGENT, R. G. Verification and validation of simulation models. In: WINTER SIMULATION<br>
CONFERENCE. Proceedings of the 37th conference on Winter simulation. [S.l.], 2005. p.<br>
130–143.<br>
SEGER, C.-J. An introduction to formal hardware verification. [S.l.]: University of British<br>
Columbia, Department of Computer Science, 1992.<br>
SOMMERVILLE, I. Engenharia de software. PEARSON BRASIL, 2011. ISBN 9788579361081.<br>
Disponível em: &lt;https://books.google.com.br/books?id=H4u5ygAACAAJ&gt;.<br>
SONS, J. W. . 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http:<br>
//onlinelibrary.wiley.com/&gt;.<br>
SOUZA, J. Lógica para Ciência da Computação. Elsevier Brasil, 2017. ISBN 9788535278255.<br>
Disponível em: &lt;https://books.google.com.br/books?id=Ds2sCQAAQBAJ&gt;.<br>
SPRINGER. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;https:<br>
//link.springer.com/&gt;.<br>
SRIKANT, Y.; SHANKAR, P. The Compiler Design Handbook: Optimizations and<br>
Machine Code Generation. CRC Press, 2002. ISBN 9781420040579. Disponível em:<br>
&lt;https://books.google.com.br/books?id=0K\_jIsgyNpoC&gt;.<br>
THOMAS, D.; MOORBY, P. The Verilog R© Hardware Description Language. Springer<br>
US, 2008. ISBN 9780387853444. Disponível em: &lt;https://books.google.com.br/books?id=<br>
DxQGrz7q-SwC&gt;.<br>
TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L. Sistemas digitais: princípios e aplicações. [S.l.]:<br>
Prentice Hall, 2003. v. 8.<br>
TRAVASSOS, G. H. et al. An environment to support large scale experimentation in software<br>
engineering. In: IEEE. Engineering of Complex Computer Systems, 2008. ICECCS 2008. 13th<br>
IEEE International Conference on. [S.l.], 2008. p</div>
<!-- DIVISOR_DIV_CANDIDATE -->

<div class='divisor divisor-texto' id="cand__file4"><hr class='text-separator'><br>Input file: <a href='#'>main.pdf</a> (12773 chunks)<br>File found: <a href='http://www.decom.ufop.br/imobilis/fpga-flexibilidade-no-projeto-de-hardware-parte-3-de-3/' target='_blank'>http://www.decom.ufop.br/imobilis/fpga-flexibilidade-no-projeto-de-hardware-parte-3-de-3/</a> (963 chunks)<br><br>Chunks in common: 29<br>Similarity: 0.21%<br><br><div class='textInfo'>The following is the content of the document <br>&nbsp;"<b>main.pdf</b>". <br>The terms in red were found in the document <br>&nbsp;"<b>http://www.decom.ufop.br/imobilis/fpga-flexibilidade-no-projeto-de-hardware-parte-3-de-3/</b>".<br><hr class='text-separator'></div>  UNIVERSIDADE FEDERAL DE RORAIMA<br>
PRÓ-REITORIA DE ENSINO E EXTENSÃO<br>
DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código<br>
com Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau<br>
de Bacharel em Ciência da Computação.<br>
Orientador: Dr. Herbert Oliveira Rocha<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau de<br>
Bacharel em Ciência da Computação.<br>
Defendido em 06 de março de 2017 e<br>
aprovado pela seguinte banca examinadora:<br>
Prof. Dr. Herbert Oliveira Rocha<br>
Orientador / Curso de Ciência da Computação -<br>
UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Fazer dedicatória<br>
ACKNOWLEDGEMENTS<br>
Fazer agradecimentos!!<br>
Procurar frase massa!!<br>
ABSTRACT<br>
Fazer resumo!!<br>
Palavras-chaves: ??<br>
ABSTRACT<br>
Fazer Abstract!!<br>
Key-words: ??<br>
LISTA DE FIGURAS<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog. . . . . . . . . . . . . . . . 15<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL. . . . . . . . . . . . . . . . . 16<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade. . . . . . . . . . . . . . . 17<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL. . . . . . . . . . . . . . . . 17<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1. . . . . . . . . . 18<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas. . . . . . . . . 18<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas. . . . . . . . . . 19<br>
Figure 8 – Arvore de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
Figure 9 – Rede de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL. . . . . . . . . . . . . . . . . 27<br>
Figure 11 – Trecho de código em VHDL representando porta AND. . . . . . . . . . . . 28<br>
Figure 12 – Trecho de código traduzido para linguagem C. . . . . . . . . . . . . . . . . 29<br>
Figure 13 – Exemplo de bloco basico de código. . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 14 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 15 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 31<br>
Figure 16 – Ciclo da ferramenta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR. . . . . . . 41<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR. . . . . . . . . . . . . . 42<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume(). . . . . . . . . . . 43<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19. . . . . . . . . . . . . . . 44<br>
Figure 22 – Macros das assertivas implementadas em linguagem C . . . . . . . . . . . . 45<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas. . . . . . . 47<br>
Figure 25 – Imagem de claims contendo assertivas. . . . . . . . . . . . . . . . . . . . . 48<br>
Figure 26 – Pseudocódigo da função de análise das claims. . . . . . . . . . . . . . . . . 49<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta. . . . . . . . . . . . . . 49<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C. . . . . . . . . . . . . 50<br>
Figure 23 – Código com assertivas traduzida para linguagem C . . . . . . . . . . . . . . 51<br>
LISTA DE TABELAS<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM . . . . . . . . . . . . . . . 33<br>
SUMÁRIO<br>
1 INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11<br>
1.1 Definição do problema . . . . . . . . . . . . . . . . . . . . . . . . . . . 12<br>
1.2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13<br>
1.3 Organização do trabalho . . . . . . . . . . . . . . . . . . . . . . . . . 14<br>
2 CONCEITOS E DEFINIÇÕES . . . . . . . . . . . . . . . . . . . . . . 15<br>
2.1 Linguagens de descrição de hardware . . . . . . . . . . . . . . . . . 15<br>
2.1.1 <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >VHSIC Hardware Description Language</span> - VHDL . . . . . . . . . . . . . 16<br>
2.1.2 Portas lógicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18<br>
2.2 Verificação de sistemas . . . . . . . . . . . . . . . . . . . . . . . . . . 19<br>
2.2.1 Diagrama de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.2 Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.3 Bounded Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . 21<br>
2.2.4 Redes de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22<br>
2.2.5 Verificação de hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
2.2.6 Verificação formal de software . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.7 Lógica proposicional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.8 Linguagem de especificação de propriedades . . . . . . . . . . . . . . 26<br>
2.2.9 Verificação baseada em assertivas . . . . . . . . . . . . . . . . . . . . 26<br>
2.2.10 Propriedades de segurança . . . . . . . . . . . . . . . . . . . . . . . . 27<br>
2.3 Técnicas de compiladores . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.1 Transformações de código . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2 Otimização de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2.1 Grafo Acliclico Direcional - GAD . . . . . . . . . . . . . . . . . . . . . . . . 29<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.3 Eliminção de código morto . . . . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.4 Análise do <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >fluxo de dados</span> . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
2.3.2.5 Gerador de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
3 TRABALHOS CORRELATOS . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1 Revisão sistemática . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1.1 Planejamento da Revisão Sistemática . . . . . . . . . . . . . . . . . . 33<br>
3.1.1.1 Procedimentos de Seleção e Critérios . . . . . . . . . . . . . . . . . . . . 35<br>
3.2 Revisão da literatura . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.1 V2c-A verilog to C translator . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.2 Unbounded safety verification for hardware using software analyzers . 37<br>
3.2.3 Formal verification of timed VHDL programs . . . . . . . . . . . . . . . 38<br>
3.2.4 On the use of assertions for embedded-software dynamic verification 38<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation . . 39<br>
4 MÉTODO PROPOSTO . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.1 Visão geral do método . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.2 Preprocessamento do VHDL e inserção de assertivas . . . . . . . 42<br>
4.3 Tradução de código VHDL para a linguagem C . . . . . . . . . . . . 43<br>
4.4 Instrumentação de código . . . . . . . . . . . . . . . . . . . . . . . . 45<br>
4.5 Verificação de assertivas usando Model Checker . . . . . . . . . . 46<br>
5 CRONOGRAMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52<br>
6 CONSIDERAÇÕES PARCIAIS E TRABALHOS FUTUROS . . . . . 53<br>
BIBLIOGRAPHY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54<br>
11<br>
1 INTRODUÇÃO<br>
A complexidade de sistemas computacionais cresce exponencialmente. Muitas compan- Exemplificar<br>
este<br>
cresci-<br>
mento.<br>
hias e organizações estão rotineiramente lidando com software que contém milhares de linhas<br>
de código, escritos por diferentes pessoas, que usam linguagens distintas, ferramentas, estilos e<br>
hardware projetados de diversas formas e combinações (HODER et al., 2011).<br>
No contexto de sistemas compostos de hardware e software, tem-se os sistemas embarca-<br>
dos (SE) que são dispositivos semicondutores com software integrados, os quais se conectam<br>
a outros dispositivos. Usualmente, o principal propósito dos SE é o controle e provimento de<br>
informações para uma função específica (RAMESH et al., 2012).<br>
Os SE são extremamente interativos com seu ambiente, operam geralmente em tempo real<br>
e estão disponíveis continuamente. No entanto, estes sistemas, por possuírem um curto espaço<br>
de tempo para a liberação do produto ao mercado, precisam ser desenvolvidos rapidamente e<br>
atingir um alto nível de qualidade, mas, devido a esta necessidade, os programadores podem<br>
cometer enganos durante a fase de desenvolvimento destes sistemas.<br>
Os SE têm se proliferado em partes consideráveis das atividades do nosso cotidiano,<br>
com a característica de possuir grande quantidade de complexidade e diversidade. Devido a esta<br>
complexidade, erros podem passar despercebidos, causando não apenas penalidades econômicas<br>
e/ou fracassos do produto no mercado, mas principalmente o risco de perda de vidas humanas<br>
(CABODI et al., 2016). Como, por exemplo, o acidente noticiado no (G1, 2012), no qual, de<br>
acordo com o secretário de transportes, uma falha na placa do circuito eletrônico responsável<br>
pelo controle de velocidade dos trens ocasionou a colisão entre duas composições na estação de<br>
metrô de São Paulo.<br>
Segundo ROCHA et al.2015b, para se obter um alto nível de qualidade no desenvolvi-<br>
mento dos sistemas de hardware e software, a execução desses sistemas deve ser controlada e da<br>
mesma forma deve-se buscar meios de garantir que as propriedades definidas sejam atingidas. Por<br>
exemplo, a partir do conhecimento prévio do modo de implementação de determinado hardware,<br>
é possível utilizá-lo de forma mais eficiente. Neste sentido, diversas estratégias de verificação e<br>
de teste estão sendo pesquisadas e aplicadas para garantir a qualidade do software e hardware<br>
(HODER et al., 2010; ROCHA et al., 2010; BRAYTON; MISHCHENKO, 2010; CORDEIRO et<br>
al., 2012; CABODI et al., 2016).<br>
Por este motivo, com o intuito de analisar e otimizar a descrição dos circuitos digitais,<br>
tem-se utilizado as linguagens de descrição de hardware (HDL). Estas se diferem das linguagens<br>
de programação por conseguirem gerar execuções não apenas sequenciais, como também con-<br>
correntes ou paralelas (CHU, 2006). Neste contexto, a <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >VHSIC Hardware Description Language</span><br>
Chapter 1. INTRODUÇÃO 12<br>
(VHDL) é uma das linguagens de descrição de hardware mais utilizadas atualmente. A descrição<br>
em VHDL pode ser em vários níveis de abstração, sendo o mais alto o nível comportamen-<br>
tal que permite a descrição do circuito através de loops e processos, definido-o na forma de<br>
algoritmo. Como características das linguagens de descrição, o VHDL permite declarações se-<br>
quenciais ou concorrentes onde as declarações continuam ativas e sua ordem torna-se irrelevante<br>
(CAPPELATTI, 2010).<br>
Aliada à linguagem de descrição de hardware, a verificação formal de sistemas computa-<br>
cionais tem desempenhado um papel importante para assegurar a previsibilidade e a confiabili-<br>
dade na concepção de aplicações críticas. E, para isso, tem-se utilizado a técnica denominada<br>
model checking, que é baseada em formalismos matemáticos para provar propriedades de pro-<br>
gramas reativos (BENSALEM; LAKHNECH, 1999). Esta técnica gera uma busca exaustiva no<br>
espaço de estados do modelo para determinar se uma dada propriedade é válida ou não (BAIER<br>
et al., 2008), tendo como principal razão para o seu sucesso o funcionamento completamente<br>
automático, ou seja, sem qualquer intervenção do usuário.<br>
Visando contribuir com a verificação de sistemas embarcados no âmbito de sistemas<br>
computacionais, o contexto deste trabalho está situado no uso de metodologias e técnicas de<br>
verificação formal para programas escritos em VHDL (BIERE, 2016), focando principalmente<br>
no Bounded Model Checking (CORDEIRO et al., 2012; ROCHA et al., 2015a). Este trabalho está<br>
interessado especificamente na parte de: verificação de modelos de hardware descritos em níveis<br>
de circuitos de bits na linguagem VHDL, via transformações de código para gerar modelos (com<br>
assertivas) já suportados por model checkers, como o ESBMC (CORDEIRO et al., 2012).<br>
Dessa forma, o trabalho almeja analisar as propriedades de alcançabilidade para a<br>
identificação de localizações de erro, bem como, assertivas contendo propriedades de segurança.<br>
A propriedade de alcançabilidade ou propriedade do estado de erro é satisfatória (SAT), se um<br>
estado de erro é alcançável. Caso contrário, a propriedade é considerada insatisfatória (UNSAT).<br>
No caso SAT, o model checking também gera um rastreio da validação da propriedade (contra-<br>
exemplo), ou seja, uma sequência de estados que mostra como chegar ao erro a partir de um<br>
ponto inicial.<br>
1.1 Definição do problema<br>
O avanço da tecnologia, principalmente nas áreas de design e fabricação de eletrônicos,<br>
aumentou a importância do hardware nos dias atuais. Cada vez com mais funcionalidades<br>
integradas, aliada a velocidade e circuitos menores, faz com que a complexidade dos sistemas<br>
de hardware aumente. Entretanto, devido à complexidade cada vez maior, a detecção tardia<br>
de erros no sistema pode resultar em perda de produção, mas também custos associados ao<br>
desenvolvimento do sistema(GUPTA, 1992). Devido a isso, a verificação de hardware visa<br>
assegurar que o circuito atinja as especificações para o qual foi projetado, através de técnicas<br>
Chapter 1. INTRODUÇÃO 13<br>
formais ou dinâmicas (BOULE; ZILIC, 2007).<br>
Por esta razão, a utilização de métodos formais tornou-se uma abordagem atraente<br>
para superar as limitações inerentes à validação baseada em simulação. Portanto, a maioria<br>
das empresas de semicondutores têm investigado a sua aplicabilidade. Escolhas individuais de<br>
métodos, ferramentas e áreas de aplicação das empresas têm variado, assim como o seu nível<br>
de sucesso (CABODI et al., 2016). Com os recentes avanços na escalabilidade de automação<br>
dos model checkers e nas equivalências sequenciais de verificação, a maioria das empresas têm<br>
crescido ao contar com essas técnicas(CLARKE, 2008).<br>
O problema considerado neste trabalho é expresso na seguinte questão: Como comple-<br>
mentar e aprimorar a verificação de propriedades de segurança em circuitos lógicos, de tal<br>
forma que uma propriedade possa ser mapeada em um problema de alcançabilidade sim-<br>
bólica, ou seja, se é possível alcançar um estado específico (para uma dada propriedade) a<br>
partir do estado inicial?<br>
1.2 Objetivos<br>
O objetivo principal deste trabalho é projetar e avaliar um método para efetuar verificação<br>
de circuitos, de forma automática, descritos em VHDL com portas lógicas em nível de bit<br>
pela utilização de técnicas de transformação de códigos combinado com a técnica Bounded<br>
Model Checking para exploração de estados alcançáveis no circuito, visando identificar erros ou<br>
comportamentos indevidos ou inesperados que podem resultar no funcionamento incorreto de<br>
um dado sistema.<br>
Os objetivos específicos são:<br>
1. Propor um método para especificar pré e pós-condições de circuitos digitais em nível de<br>
portas lógicas descritos em VHDL;<br>
2. Analisar ferramentas de verificação de modelos que utilizam a técnica Bounded Model<br>
Checking;<br>
3. Especificar uma técnica de conversão de circuitos em linguagem de descrição <span class='f1 c_6' id='c_6_1' href='#c_6_2' cs_f='.c_6' >de hardware<br>
VHDL</span> para um modelo a ser verificado usando a técnica Bounded Model Checking;<br>
4. Desenvolver um método para identificação de estados de erros ou ocorrências indevidas,<br>
de um dado circuito analisado, em modelos de hardware descritos em nível de bit na<br>
linguagem de descrição VHDL.<br>
5. Validar a aplicação do método proposto sobre benchmarks públicos de programas em<br>
VHDL, a fim de examinar a sua eficácia e aplicabilidade.<br>
Chapter 1. INTRODUÇÃO 14<br>
1.3 Organização do trabalho<br>
A introdução deste trabalho apresentou: o contexto, definição do problema, e objetivos<br>
deste trabalho. Os próximos capítulos estão organizados da seguinte forma:<br>
No Capítulo 2 Conceitos e Definições, são apresentados os conceitos abordados neste<br>
trabalho, especificamente: Linguagens de descrição de hardware; Verificação e validação de<br>
sistemas; e Técnicas de compiladores.<br>
No Capítulo 3 Trabalhos Correlatos, serão apresentados o método de pesquisa bibli-<br>
ográfica utilizado, sendo ele a revisão sistemática, seguido do resultado encontrado com esta<br>
pesquisa e, por fim, a contribuição dos artigos utilizados no <span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >desenvolvimento do projeto</span>.<br>
No Capítulo 4 Método Proposto, são descritas as etapas de execução do novo método<br>
proposto que consiste na transformação do código, instrumentação de assertivas e verificação de<br>
código utilizando um model checker.<br>
No Capítulo 5, será apresentado o cronograma de atividades a ser realizado na elaboração<br>
do método durante <span class='f1 c_18' id='c_18_1' href='#c_18_2' cs_f='.c_18' >o desenvolvimento do projeto</span>.<br>
E, por fim, no Capítulo 6 Considerações parciais e trabalhos futuros, serão apresentas<br>
as considerações parciais e as sugestões de trabalhos futuros que podem ser desenvolvidos.<br>
15<br>
2 CONCEITOS E DEFINIÇÕES<br>
Este capítulo tem apresenta os principais conceitos e definições abordados neste tra-<br>
balho, tais como: Linguagens de descrição de hardware, Verificação de sistemas e Técnicas de<br>
Compiladores.<br>
2.1 Linguagens de descrição de hardware<br>
As linguagens de descrição de hardware (HDL) foram desenvolvidas com o intuito de<br>
auxiliar a criação de circuitos lógicos com grande número de elementos e com uma gama de<br>
abstrações lógicas e eletrônicas (THOMAS; MOORBY, 2008). Entre os exemplos, podemos<br>
citar: VDHL (IEC/IEEE. . . , 2011), Verilog (IEEE. . . , 2006) e SystemC (??).<br>
Segundo CHRISTEN; BAKALAR,1999, linguagens de descrição de hardware são lingua-<br>
gens de programação utilizadas com o intuito de <span class='f1 c_3' id='c_3_1' href='#c_3_2' cs_f='.c_3' >descrever o comportamento</span> de um determinado<br>
circuito, técnica conhecida como modelagem. Os modelos descritos em HDL são utilizados<br>
como entrada para um simulador, onde o mesmo pode ter seu comportamento analisado.<br>
As HDL’s trazem consigo diversas vantagens, entre elas códigos independentes de tec-<br>
nologia e fabricante, podendo ser portáteis e reutilizáveis (CAPPELATTI, 2010). As linguagens<br>
mais modernas, tais como VHDL e Verilog, possuem suporte tanto a descrição do circuito pro-<br>
priamente dito, quanto ao comportamento que o mesmo deve exercer (CHRISTEN; BAKALAR,<br>
1999).<br>
A Verilog, como já citado, é <span class='f1 c_26' id='c_26_1' href='#c_26_2' cs_f='.c_26' >uma linguagem de</span> descrição de hardware que fornece<br>
diversos níveis de abstração para desenvolvimento <span class='f1 c_4' id='c_4_1' href='#c_4_2' cs_f='.c_4' >de sistemas digitais</span>(THOMAS; MOORBY,<br>
2008). A linguagem foi desenvolvida para ser simples e efetiva nos diversos níveis de abstração<br>
incluindo o suporte ao desenvolvimento, verificação, síntese e testes de software (IEEE. . . , 2006).<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog.<br>
1 p r i m i t i v e m u l t i p l e x e r ( mux , c o n t r o l , dataA , da taB ) ;<br>
2 o u t p u t mux ;<br>
3 i n p u t c o n t r o l , dataA , da taB ;<br>
4 e n d p r i m i t i v e<br>
Fonte: Adaptado de (IEEE. . . , 2006).<br>
Na Figura 1 apresenta <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >um exemplo de</span> multiplexador descrito em Verilog utilizando a<br>
estrutura de modelagem, chamada UDP que permite a criação de novos primitivas para serem<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 16<br>
utilizada. Apresenta uma saída apenas(mux) e três entradas sendo uma de controle(control) e<br>
duas de dados(dataA e dataB).<br>
A VHDL é <span class='f1 c_26' id='c_26_1' href='#c_26_2' cs_f='.c_26' >uma linguagem de</span> descrição de hardware amplamente utilizada, concebida<br>
na década de 80, devido uma necessidade do Departamento de Defesa dos Estados Unidos<br>
da América (CAPPELATTI, 2010). Assim como a Verilog, esta linguagem também suporta o<br>
desenvolvimento, a verificação, a síntese, e os testes de hardware (IEC/IEEE. . . , 2011).<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL.<br>
1 l i b r a r y IEEE ;<br>
2 use IEEE . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 use IEEE . s t d _ l o g i c _ u n s i g n e d . a l l ;<br>
4 e n t i t y mux2x1 i s<br>
5 p o r t ( s e l : i n STD_LOGIC ;<br>
6 a , b : i n STD_LOGIC ;<br>
7 y : o u t STD_LOGIC ) ;<br>
8 end mux2x1 ;<br>
9<br>
10 a r c h i t e c t u r e d a t a f l o w of mux2x1 i s b e g i n<br>
11 y &lt;= ( a AND NOT s e l ) OR ( b AND s e l ) ;<br>
12 end d a t a f l o w .<br>
Fonte: (CAPPELATTI, 2010).<br>
Na Figura 2 está descrito um multiplexador de duas entradas descrito em VHDL, apre-<br>
sentando na parte inicial as bibliotecas e na entidade(entity) a declaração das variáveis utilizadas.<br>
Na arquitetura(architecture) apresenta o funcionamento do multiplexador, relacionando en-<br>
tradas e saídas conforme tenham sido declarados. Este conceitos serão melhor apresentados na<br>
subsection 2.1.1.<br>
Conforme apresentado nas <span class='f1 c_16' id='c_16_1' href='#c_16_2' cs_f='.c_16' >Figura 1 e Figura</span> 2, ambas as linguagens apresentam difer-<br>
enças no modelos de declaração e utilização para descrição de hardware. Para este trabalho foi<br>
escolhido a VHDL devido a linguagem apresentar um melhor escopo para análise, facilitando o<br>
trabalho de análise proposto para este projeto.<br>
2.1.1 <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >VHSIC Hardware Description Language</span> - VHDL<br>
Revisar textos e verificar a necessidade de mais exemplo<br>
VHDL é <span class='f1 c_26' id='c_26_1' href='#c_26_2' cs_f='.c_26' >uma linguagem de</span> descrição de hardware destinada a ser utilizada em todas<br>
as etapas da criação de sistemas eletrônicos, sendo elas: desenvolvimento; verificação; síntese;<br>
e, teste de circuitos (IEC/IEEE. . . , 2011). Segundo (CAPPELATTI, 2010), a VHDL apresenta<br>
três principais pilares: abstração, que consiste na descrição com diferentes níveis de detalhes;<br>
modularidade, que permite a divisão do projeto em vários blocos ou módulos para posterior<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 17<br>
interconexão; e hierarquia, permite que módulos possam ser compostos por submódulos e, os<br>
mesmos tenham níveis de abstração diferentes, dependendo da necessidade do projeto. Devido a<br>
esta versatilidade que a linguagem VHDL foi selecionada para o trabalho proposto.<br>
Segundo IEC/IEEE. . . ,2011, é necessário um padrão para formatação da descrição em<br>
VHDL: Entity (Pinos de entrada/saída) e Architecture (Arquitetura). A Entity ou entidade repre-<br>
senta o bloco onde são declaradas as entradas e as saídas do circuito utilizadas em todo o sistema,<br>
conforme apresentado na Figura 3. A Architecture ou arquitetura, apresentado na Figura 4, define<br>
a relação entre entradas e saídas declaradas na entidade, podendo tais especificações serem<br>
completas ou parciais. Assim como em outras linguagens, bibliotecas podem ser adicionadas,<br>
para que novas funções e atributos possam ser utilizados no projeto.<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade.<br>
1 l i b r a r y i e e e ;<br>
2 use IEEE . STD_LOGIC_1164 . ALL<br>
3<br>
4 ENTITY f u l l _ a d d e r IS PORT(<br>
5 x1 , x2 , c i n : i n s t d _ l o g i c ;<br>
6 S , c o u n t : o u t s t d _ l o g i c ) ;<br>
7 END f u l l _ a d d e r ;<br>
Fonte: Própria.<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL.<br>
1 ARCHITECTURE b e h a v i o r a l OF f u l l _ a d d e r IS<br>
2 BEGIN<br>
3 s &lt;=x1 XOR x2 XOR c i n ;<br>
4 cout &lt;=( x1 AND x2 ) OR ( x1 AND c i n ) OR ( b<br>
AND c i n ) ;<br>
5 END b e h a v i o r a l ;<br>
Fonte: Própria.<br>
Segundo CAPPELATTI,2010 uma descrição em VHDL pode conter diferentes níveis de<br>
abstração:<br>
• Comportamental: Permite descrever o circuito através de laços e processos. O circuito<br>
é definido em forma de um algoritmo, utilizando construção similares as utilizadas em<br>
linguagem de programação.<br>
• Transferência de registradores: Englobando a representação do dispositivo em nível de<br>
transferência entre registradores, que consiste na utilização de funções lógicas combina-<br>
cionais e de registradores.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 18<br>
• Estrutural: O circuito é descrito mais próximo da implementação real, podendo ser<br>
definidas portas lógicas com atrasos unitários ou com atrasos detalhados.<br>
2.1.2 Portas lógicas<br>
Segundo (IDOETA; CAPUANO, 1982), o conceito de portas lógicas é baseado na<br>
conhecida álgebra de Boole ou álgebra booleana, desenvolvida pelo matemático inglês George<br>
Boole em 1854. A álgebra booleana é representada por apenas dois valores, sendo eles o 0 e 1 e,<br>
através disso, expressa a relação entre entrada e saída dentro de um circuito. As portas lógicas<br>
podem ser construídas a partir de diodos, transistores e resistores interconectados de modo que a<br>
saída seja o resultante de uma operação lógica básica realizada sobre as entradas (TOCCI et al.,<br>
2003). A Figura 5 apresenta <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >um exemplo de</span> álgebra booleana sem a utilização de diagramas.<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1.<br>
Fonte: (TOCCI et al., 2003)<br>
Ainda segundo TOCCI et al.,2003, devido a esta característica, a álgebra booleana possui<br>
três operações básicas, OR (ou), AND (e) e NOT (não). Tal conjunto de operações também é<br>
denominado de operações booleanas e, por meio da utilização de tabelas verdade é possível<br>
descrever as saídas baseando-se nas entradas e na operação aplicada. Cada operação booleana<br>
possui sua tabela verdade ( Figura 6), bem como sua representação em forma de diagrama.<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas.<br>
Fonte: (TOCCI et al., 2003)<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 19<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas.<br>
Fonte: (TOCCI et al., 2003)<br>
A Figura 7 apresenta um circuito lógico formado pelas portas básicas da álgebra booleana.<br>
O circuito apresenta três entradas representadas pelas letras A, <span class='f1 c_7' id='c_7_1' href='#c_7_2' cs_f='.c_7' >B e C</span>, mas também formada<br>
por duas portas AND, uma porta NOT e uma porta OR. Cada uma destas portas representando<br>
operações a serem realizadas, podendo receber como entrada um valor inicial ou resultante de<br>
outra porta, como no exemplo ocorre com a última porta AND.<br>
Entetanto, segundo (KROPF, 2013), a análise de circuitos é extremamente complexa,<br>
resultando em um problema NP-Completo, algoritmos possuem tempo de execução exponencial.<br>
Contudo, este tempo de execução exponencial é uma complexidade exponencial para o pior caso,<br>
resultando crescimento exponencial da execução a medida que o tamanho do problema aumenta.<br>
Ainda, segundo (KROPF, 2013) a avaliação das funções booleanas podem ser ver-<br>
dadeiras(True) ou falso(False), com isso, para um função com n variáveis, apresenta 2n possibili-<br>
dades de avaliação. Utilizando o exemplo da Figura 7 que apresenta 3 entradas, logo apresenta 8<br>
possibilidade de avaliação ao final e este número aumenta à medida que o número de variáveis<br>
tambe aumenta<br>
2.2 Verificação de sistemas<br>
No contexto de verificação de sistemas, faz-se necessário a diferenciação entre verificação<br>
e validação. Verificação e validação possuem o intuíto de mostrar que determinado sistema fun-<br>
cione conforme o especificado, além de satisfazer as especificações do cliente (SOMMERVILLE,<br>
2011).<br>
Segundo (SARGENT, 2005), verificação é o processo de determinar se um modelo<br>
computacional obtido por discretização de um modelo matemático de um evento físico e o<br>
código que implementa o modelo computacional pode ser usado para representar o modelo<br>
matemático do evento com precisão suficiente e validação é o processo de determinar se um<br>
modelo matemático de um evento físico representa o evento físico real com precisão suficiente.<br>
A verificação consite identificação de erros e provavéis problemas que um componente<br>
pronto possa apresentar, enquanto a validação busca analisar se tal componete esta seguindo<br>
os requisitos pré-definidos para sua construção (KOSCIANSKI; SOARES, 2007). O teste de<br>
programa, na qual o software é executado com dados de teste é a principal forma de validação,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 20<br>
porém, tecnicas de verificação, tais como, inspeção e revisões também podem integrar a etapa de<br>
validação (SOMMERVILLE, 2011).<br>
2.2.1 Diagrama de decisão binária<br>
Um diagrama de decisão binária(DDB) pode ser definido como um grafo aciclico para<br>
representação de funcões boolenas. Existe uma ordem rigorosa na ocorrência de variáveis à me-<br>
dida que se percorre o grafo da raiz para a folha. Dado como exemplo a formula f=(a?b)?(c?d)<br>
e utilizando a ordenação de variavél a &lt; b &lt; c &lt; d, na Figura 8. Dada a atribuição de valores<br>
booleanos as variaveis a, b, c e d, pode-se decidir se a atribuição torna a fórmula verdadeira<br>
atravessando o início do gráfico na raiz e ramificação em cada nó. Definindo a, c e d = 1 e c = 0<br>
leva a folha de rótulo 1, portanto, a fórmula é verdadeira para essa tarefa (CLARKE et al., 1994).<br>
Figure 8 – Arvore de decisão binária<br>
Fonte: (CLARKE et al., 1994)<br>
Adicionar mais detalhes e descrever onde DDB é utilizado.<br>
O DDB permite o teste eficiente de satisfabilidade, validade e eficiência (KROPF, 2013).<br>
O uso e DDB em conjunto com Model Checking e técnicas de abstração permitiu o aumento na<br>
capacidade de verificação, de modo que sistemas mais realistas podessem ser verificados(??)<br>
2.2.2 Model Checking<br>
Model checking é uma técnica de verificação formal que explora todos os possíveis<br>
estados do sistema, de modo a provar se um modelo satisfaz determinada propriedade. Pode ser<br>
aplicada em uma ampla gama de aplicações, tais como sistema embarcados, design de hardware<br>
e engenharia de software (BAIER et al., 2008).<br>
Entre as vantagens da utilização de Model Checking estão:<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 21<br>
• Possuem suporte a verificação parcial, em outras palavras, a verificação individual de<br>
propriedades, permitido foco primeiro as propriedades essenciais(BAIER et al., 2008).<br>
• Não requer qualquer interação do usuário, nem um alto grau de especialização para o uso<br>
de model checking(BAIER et al., 2008).<br>
• Possui como base a teoria de grafos, estruturas <span class='f1 c_2' id='c_2_1' href='#c_2_2' cs_f='.c_2' >de dados e</span> lógica no desenvolvimento da<br>
solução(BAIER et al., 2008).<br>
• Útil para fins de depuração, pois formece informações em caso de uma propriedade seja<br>
invalidada(BAIER et al., 2008).<br>
Por outro lado, apresenta também algumas desvantagens:<br>
• Sofre do problema de explosão de espaço de estados, <span class='f1 c_19' id='c_19_1' href='#c_19_2' cs_f='.c_19' >ou seja, a</span> quantidade de estados<br>
necessários pode ser maior que a memória disponivel pelo sistema(BAIER et al., 2008).<br>
• Faz a verificação apenas dos requisios declarados, logo, não a garantia de integridade.<br>
Baseado nisso, a validade de propriedades não verificadas não pode ser julgada(BAIER et<br>
al., 2008).<br>
• A verificação de modelos geralmente não é computável, isso deve-se a questões de decidi-<br>
bilidade utilizada (BAIER et al., 2008).<br>
Outras técnicas foram implementadas em conjuntos com Model checkings com o intuito<br>
de aumentas a capacidade de verificação, como a técnica SAT na qual não sofre do problema de<br>
explosão de estados existente usando DDB. A técnica SAT em conjuto com Model Checking é<br>
conhecida como Bounded Model Checking (??).<br>
2.2.3 Bounded Model Checking<br>
Segundo ROCHA et al., Bounded Model Checking (BMC) é um tipo especial de Model<br>
Checking que usualmente adota o método de satisfabilidade booleana, o qual tem sido introduzido<br>
como uma técnica complementar para diagrama de decisão binaria para aliviar o problema da<br>
explosão de estados, visto que a técnica de Model Checking busca todos os estados possíveis<br>
para verificação.<br>
Bounded Model Checking é uma técnica para a verificação de uma dada propriedade<br>
em uma determinada profundidade do sistema analisado. Logo, dado um sistema de transições<br>
M, uma propriedade ?, e um limite (bound) k, o BMC desenrola o sistema k vezes e traduz o<br>
sistema em uma condição de verificação(CV) ? tal que ? é satisfeito se e somente se ? tem um<br>
contra-exemplo de profundidade menor ou igual a k (ROCHA et al., 2015b).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 22<br>
O Extended SMT-Based Bounded Model Checker (ESBMC) é um Bounded Model<br>
Checking baseado em satisfabilidade booleana (SAT) que permite verificação aritmética de Já tem<br>
su-<br>
porte<br>
a<br>
SMT<br>
adi-<br>
cionar<br>
ao<br>
texto<br>
overflow e undeflow, segurança de ponteiros, limite de array, de gerar propriedades de segurança<br>
em programas em C/C++. ESBMC utiliza uma versão modificada do CBMC no front-end para<br>
analisar o código ANSI-C e para gerar as condições de verificação através de execução simbólica<br>
(CORDEIRO et al., 2012; ROCHA et al., 2015b).<br>
No ESBMC, o programa analisado é modelado em um sistema de transição de estados,<br>
conforme a trupla: M = (S,R, S0), o qual é gerado um grafo de controle de fluxo (GFC), onde<br>
S representa o conjunto de estados, R ? SxS representa as transições e S ? S representa<br>
o conjuto de estados iniciais. Um estado s ? S consiste no valor do contador de programa<br>
(PC) e os valores de todas as variáveis dos programas. O estado inicial S0 atribui o inicio do<br>
programa GFC ao PC, desta forma o ESBMC identifica as transições, conforme a formula lógica,<br>
?=(Si,Si+1) que captura as retrições sobre os valores correspondntes do PC e das variáveis do<br>
programa (CORDEIRO et al., 2012).<br>
Segundo o site do ESBMC(??), a ferramenta permite ao usuário indicar propriedades<br>
adicionaisusando assertivas que também são verificadas. O ESBMC converte as condições Descrever<br>
quais<br>
pro-<br>
priedades<br>
o<br>
esbmc<br>
su-<br>
porta<br>
usando diferentes técnicas de backgroundpara posteriormente passar para verificador SMT. Outra<br>
apresentar<br>
exem-<br>
plo<br>
vantagem é a ferramenta permitir verificação de software single-thread e multi-thread.<br>
Descrever qual a razão da escolha para o trabalho, apresentar resultados do SV-COMP<br>
dos últimos 3 anos<br>
2.2.4 Redes de petri<br>
Apresentar definição formal para RP<br>
corrigir o texto abaixo RP não é uma ferramenta e sim um método de modelagem<br>
Redes de petri são utilizadas como ferramentas de modelagem gráfica com propriedades<br>
matemática. Como ferramenta gráfica são utilizadas como comunicação visual, como fluxogra-<br>
mas, por exemplo, e como ferramenta matemática podem configurar modelos matemáticos que<br>
regem o comportamento dos sistemas. A grade premissa desta ferramenta é descrever sistemas<br>
de processamento de informações caracterizados como concorrentes, assíncronos, distribuídos,<br>
paralelos, não deterministas e/ou estocásticos (MURATA, 1989).<br>
As redes de petri são representados como grafos direcionais compostos por nós e arcos,<br>
conforme apresentado na Figura 9. Os nós representam as transições e eventos e os arcos<br>
representam os pesos. Dentro desta representação, os arcos e eventos são componentes passivos<br>
enquanto as transições são ativos. A principal vantagem da utilização das redes de petri esta<br>
relacionado ao chamado "Token game" que consiste no comportamento da rede de petri, em<br>
outras palavras, representa o funcionamento do sistema representado pela rede(HALDER;<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 23<br>
VENKATESWARLU, 2006).<br>
Figure 9 – Rede de petri<br>
Fonte: (HALDER; VENKATESWARLU, 2006)<br>
Descrever o funcionamento da RP apresentado na IMG<br>
Descrever quais propriedades podem ser verificadas com RP e onde será utilizado no seu<br>
trabalho.<br>
2.2.5 Verificação de hardware<br>
Para a verificação de hardware diversas técnicas têm sido propostas (). Por meio da Apresentar<br>
exem-<br>
plos<br>
com<br>
refer-<br>
ências<br>
simulação, visa assegurar que uma implemetação, descrição do hardware em qualquer qualquer<br>
nível de abstração da hierarquia de hardware, atinja suas especificações, propriedades que devem<br>
ser respeitadas para que a corretude do mesmo seja comprovada (GUPTA, 1992). A Verificação<br>
formal de hardware consiste na utilização de técnicas para corretude de circuitos lógicos, ou<br>
seja, consiste na utilização de modelos matemáticos para descrição de propriedade e/ou de<br>
comportamento de um dado sistema (KROPF, 2013).<br>
Entre as abordagens utilizadas na verificação formal de hardware consiste tanto na imple-<br>
mentação quanto a especificação estarem descritas em lógica formal, neste caso a corretude será<br>
obtida através da comprovada relação entre a implementação e a especificação (SEGER, 1992).<br>
A especificação formal consiste na descrição do comportamento, bem como, das propriedades<br>
do sistema em linguagem matemática, tornando-se crucial para o processo de verificação. Na<br>
implementação formal, o nível de abstração, tais como, Gate level e RTL são importantes infor-<br>
mações <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >para o desenvolvimento do</span> formalismo, bem como as classes, por exemplo se o circuito<br>
é sequencial ou combinacional, se utiliza pipeline, etc (KROPF, 2013).<br>
Apresentar <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >um exemplo de</span> RTL<br>
A utilização de Model Checking também se faz presente nos modelos formais de ver-<br>
ificação de hardware, onde apenas é utilizado o comportamento dos circuitos na verificação,<br>
de modo a verificar a se as propriedades presentes são satisfeitas. Para isso, são utilizados os<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 24<br>
conceitos da lógica proposicional, que por meio da utilização de fórmulas que representem as<br>
propriedades dos estados, é possível realizar as verificações necessárias (SEGER, 1992).<br>
Apresentar um exemplo com um circuito e como este pode ser verificando com model<br>
checking<br>
2.2.6 Verificação formal de software<br>
Observa-se que o uso de verificacão de software tem sido feito aplicado em muitas áreas,<br>
tais como, infraestruturas industriais de missão critica e de segurança. Logo, existe a necessidade<br>
de garantir a corretude destes sistemas. Devido a isso, a verificação formal tem sido utilizada em<br>
três principais abordagens, sendo elas (COUSOT; COUSOT, 2010; D’SILVA et al., 2008):<br>
Apresentar exemplos para os métodos apresentados abaixo<br>
• Métodos dedutivos: Produzem provas matemáticas formais de corretude usando provadores<br>
de teoremas ou assistentes de prova para execução da prova e necessitam da interação<br>
humana para prover os argumentos (COUSOT; COUSOT, 2010);<br>
• Verificação de modelos: Exploram exaustivamente modelos de execuções de programa,<br>
que podem ser sujeitos a explosão combinatória, necessário a intervenção humana para<br>
geração dos modelos (ROCHA et al., 2015b);<br>
• Analise estática: Engloba diversas técnicas para calcular automaticamente informações<br>
sobre o comportamento de um programa sem executá-lo, sendo utilizado em otimização<br>
de código e verificação em compiladres (D’SILVA et al., 2008).<br>
Segundo ROCHA et al., na verificação formal de software apresentam-se dificuldades,<br>
tais como: quais as propriedades são de interesse na verificação em tempo de execução; e<br>
impossibilidade matemática de provar a corretude de propriedades não triviais no comportamento<br>
de programas (COUSOT; COUSOT, 2010).<br>
2.2.7 Lógica proposicional<br>
A lógica proposicional é uma linguagem formal onde é definida um alfabeto e conectivos<br>
proposicionais, e um conjunto de regras gramaticais, as quais serão utilizadas para construção<br>
das proposições (SOUZA, 2017). Porém apesar de importante, ela é limitada, não podendo<br>
expressar sentenças elementares importantes, tais como a da aritmética elementar. Por exemplo:<br>
1. Todos são mortais.<br>
2. Alguém é bondoso.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 25<br>
Na lógica preposicional, não poderiam ser analisadas, pois não teria como decompor<br>
ambas em sentença e assim não teria como analisar as diferenças entre ambas(ABE, 2002).<br>
Contudo, no exemplo: Existem cavalos com patas verdes. A relação criada pela frase poderia a<br>
ser analisada pela lógica proposicional(ABE, 2002). Descrever<br>
como<br>
seria<br>
está<br>
analise<br>
Segundo SOUZA, alfabeto da lógica proposicional é formado por símbolo de pontuação,<br>
símbolos proposicionais e conectivos proposicionais, onde cada um apresenta uma função em<br>
específico, sendo:<br>
• Símbolos de pontuação: Apenas dois símbolos de pontuação são utilizados o "(" e o ")".<br>
• Símbolos proposicionais: São utilizados para representar as proposições, onde um sím-<br>
bolo P pode ser utilizado para representar uma proposição qualquer, por exemplo: P="Está<br>
chovendo". O conjunto de símbolos proposicionais é infinito e enumerável, sendo possível<br>
representar infinitos e enumerável conjunto de proposições.<br>
• Conectivos proposicionais: São os símbolos usando frequentemente na matemática. Os<br>
símbolos recebem a seguinte denominação:<br>
1. ¬: Representa a partícula de negação, ou seja, "Não".<br>
2. ?: Representa a partícula "Ou"<br>
3. ?: Representa a partícula "E"<br>
4. ?: Representa a partícula "Se então ou implica".<br>
5. ?: Representa a partícula "Se, e somente se".<br>
Ainda segundo SOUZA, existem as fórmulas que são constituídas de forma indutiva, a<br>
partir de símbolos do alfabeto conforme as regras apresentadas abaixo:<br>
• Todo o símbolo preposicional é uma fórmula<br>
• Se H é uma fórmula, então (¬H), a negação de H, é uma fórmula.<br>
• Se H e G são fórmulas, então a disjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a conjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o antecedente e G consequente da fórmula.<br>
• Se H e G são fórmulas, então a bi-implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o lado esquerdo e G o lado direito da fórmula.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 26<br>
2.2.8 Linguagem de especificação de propriedades<br>
Linguagem de especificação de propriedades, do inglês Property Specification Language<br>
- PSL, é uma notação formal para especificação de comportamento em sistemas eletrônicos,<br>
compatível com as linguagens VHDL, Verilog, SystemC e SystemVerilog. Destina-se a utilização Adicionar<br>
refer-<br>
ência<br>
a cada<br>
Ling<br>
citada<br>
para a especificação funcional, mas também para entrada de ferramentas de verificação. A<br>
especificação do PSL é a utilização de assertivas sobre propriedades <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >de um sistema</span>, sendo estas<br>
propriedades constituídas de três elementos: expressões boolenas, expressões sequenciais e<br>
operadores temporais (IEEE. . . , 2010).<br>
Corrigir a apresentação da citação IEEE... estranho<br>
Segundo (IEEE. . . , 2010), o PSL foi totalmente desenvolvida com o intuito fornecer<br>
leitura e escrita de fácil entendimento, sintaxe concisa, semântica formal e rigorosamente bem<br>
definida e ser matematicamente precisa, visto a utilização da mesma em processo de verificação.<br>
O PSL pode ser utilizado para capturar requisitos relativos ao comportamento total do projeto,<br>
bem como, sobre o modo que o mesmo deverá operar no ambiente, ms também para capturar<br>
requisitos comportamentais e os pressupostos que surgem durante o processo de design. Ambas<br>
podem ser utilizadas para verificação de sistemas.<br>
Apresentar exemplos de uso da PSL<br>
2.2.9 Verificação baseada em assertivas<br>
Verificação baseada em assertivas, do inglês Assertion-Based Verification - ABV, é um<br>
paradigma de verificação igualente adequado para verificação formal e abordagens baseadas em<br>
simulação (BOULE; ZILIC, 2005) e em conjunto com a tecnica de PSL tem ganhado aceitação<br>
como um método essencial para verificação funcional do hardware (DAHAN et al., 2005).<br>
Na ABV as assertivas são declaração adicionadas ao projeto com o intuito de especificar<br>
o comportamento do projeto (BOULE; ZILIC, 2005), podendo escritos em PSL ou em SVA<br>
(System Verilog Assertions). No caso deste projeto será utilizado a PSL, devido a mesma ser<br>
utilizada juntamente com a linguagem VHDL.<br>
Com a utilização de ABV o circuito pode ser verificado usando técnicas de simulação<br>
e/ou verificação, por exemplo, model checking, para garantir que o mesmo esteja de acordo<br>
com o pretendido projeto (DAHAN et al., 2005). Na Figura 19 apresenta o modelo de assertiva<br>
utilizada no projeto, utilizando de um modelo próprio para assertivas, unindo as funcionalidades<br>
já existentes nas assertivas do VHDL, mas também novas (serão apresentadas nas próximas<br>
seções), fornecendo assim mais propriedades a serem analisadas.<br>
Descrever qual o objetivo da assert apresentado<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 27<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 e n t i t y AND_ent i s<br>
5 p o r t ( x , y : i n b i t ;<br>
6 F : o u t b i t<br>
7 ) ;<br>
8 end AND_ent ;<br>
9<br>
10 a r c h i t e c t u r e behav1 of AND_ent i s<br>
11 b e g i n<br>
12 ??@c2vhdl : ASSERT<br>
13 ??a s s e r t n o t ( x= ’ 0 ’ and y= ’ 1 ’ )<br>
14 ?? r e p o r t " Both v a l u e s o f s i g n a l s x and y a r e e q u a l t o 1 "<br>
15 ??s e v e r i t y ERROR;<br>
16 ??@c2vhdl :END<br>
17<br>
18 p r o c e s s ( x , y )<br>
19 b e g i n<br>
20 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
21 F &lt;= ’ 1 ’ ;<br>
22 e l s e<br>
23 F &lt;= ’ 0 ’ ;<br>
24 end i f ;<br>
25 end p r o c e s s ; 4<br>
26 end behav1 ;<br>
Fonte: Própria.<br>
2.2.10 Propriedades de segurança<br>
Propriedades de segurança é um meio de validação do comportamento de um determinado<br>
sistema, de modo que se uma dada propriedade de segurança for violada, então através de<br>
uma execução finita, é possível verificar tal erro. Algumas propriedades de segurança, no<br>
entanto, podem impor requisitos em fragmentos de caminho finito e não podem ser verificadas<br>
considerando apenas os estados alcançáveis. (BAIER et al., 2008).<br>
Segundo (CLARKE et al., 2003), podemos definir uma propriedade de segurança como:<br>
dado um sistema de transições ST = (S, S0, E), seja um conjunto B ? S que especifica um<br>
conjunto de maus estados tais que S0 ?B = ?, pode-se dizer que ST é seguro com relação a B,<br>
denotado por ST |= AG¬B se não existe um caminho no sistema de transição do estado inicial<br>
S0 até o estado B, de outro modo é dito que ST não é seguro.<br>
Adicionar exemplos de propriedades de segurança em hardware<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 28<br>
2.3 Técnicas de compiladores<br>
Compiladores são sistemas de software utilizados para tradução de <span class='f1 c_26' id='c_26_1' href='#c_26_2' cs_f='.c_26' >uma linguagem de</span><br>
programação para outra, ou seja, o programa da linguagem fonte é lido e traduzido para um<br>
código equivalente na outra linguagem, ou linguagem alvo. Geralmente utilizada para transformar<br>
trechos de código em uma linguagem a ser executada pelo computador (AHO et al., 2007).<br>
Diversas técnicas podem ser utilizadas nas diversas etapas, até que o código seja traduzido,<br>
tais como LL(1) e LR na análise sintática; eliminação de código morto; propagação de constante<br>
e Peephole na otimização de código(AHO et al., 2007). Neste projeto serão focados as áreas de<br>
transformações de código e otimização de código.<br>
2.3.1 Transformações de código<br>
Transformações de código correspondem a uma complexa função que envolve analise de<br>
<span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >fluxo de dados e</span> modificação completa do programa que são parte integral da alta performance e<br>
sistemas computacionais. Podem ser classificados em transformações escalares que reduzem<br>
o número de instruções a serem executadas no programa ou transformações paralelas que<br>
maximizam o paralelismo (SRIKANT; SHANKAR, 2002).<br>
A Figura 11 representa o trecho de código apresentado na Figura 19. O trecho representa<br>
o comportamento das entradas, neste caso de um código da porta AND. E a figura Figura 12<br>
representa a tradução deste trecho em código na linguagem C. Esta tradução foi realizada pela<br>
ferramenta V2C, utilizada neste projeto. Adicionar<br>
refer-<br>
ência<br>
Figure 11 – Trecho de código em VHDL representando porta AND.<br>
1 p r o c e s s ( x , y )<br>
2 b e g i n<br>
3 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
4 F &lt;= ’ 1 ’ ;<br>
5 e l s e<br>
6 F &lt;= ’ 0 ’ ;<br>
7 end i f ;<br>
8 end p r o c e s s ;<br>
Fonte: Própria.<br>
Expandir esta seção. Apresentar propriedades de transformação e técnicas para avaliar a<br>
transformação<br>
2.3.2 Otimização de código<br>
A otimização de código consiste na melhoria do código intermediário gerado pelos<br>
algoritmos de compilação com o objetivo de obter um menor tempo de execução do programa,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 29<br>
Figure 12 – Trecho de código traduzido para linguagem C.<br>
1 /? S t a r t o f T r a n s l a t i o n ? /<br>
2 /? p0 : ? /<br>
3 i f ( chg [ x ] | | chg [ y ] ) {<br>
4 i f ( ( ( o l d [ x ]==1) && ( o l d [ y ]==1) ) ) {<br>
5 new [ f ] = 1 ;<br>
6 }<br>
7 e l s e {<br>
8 new [ f ] = 0 ;<br>
9 }<br>
10 }<br>
11 /? End o f T r a n s l a t i o n ? /<br>
Fonte: Própria.<br>
porém outros fatores podem ser introduzidos, como algoritmos menores. Este fato não implica<br>
em afirmar que o melhor código é gerado, visto que dada a complexidade, raramente pode ser<br>
obtido que o código gerado pode ser o melhor possível (AHO et al., 2007).<br>
Segundo AHO et al., otimização local de código consiste na otimização de um bloco<br>
básico de código, <span class='f1 c_19' id='c_19_1' href='#c_19_2' cs_f='.c_19' >ou seja, a</span> otimização ocorre em um trecho especifico de código. Os blocos<br>
básicos são trecho onde não ocorrem saltos ou loops, para nenhuma outra parte do código. A<br>
otimização global de código é baseado na analise do <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >fluxo de dados</span>, de modo que ocorra as<br>
elminação de instruções não necessárias ou substituição mais facil. A otimização global consite<br>
na analise completa do código. Neste sentido, nas próximas seções serão apresentadas algumas<br>
importantes técnicas de otimizações.<br>
2.3.2.1 Grafo Acliclico Direcional - GAD<br>
Grafo Aciclico Direcional é utilizado para diversos fins dentro da estrutura de compi-<br>
ladores, principalmente para geração da parse tree otimização de código. Pode ser usado na<br>
representação de instruções unicas blocos básicos de código(AHO et al., 2007). O uso de GAD<br>
permite a melhoria de de código, tais como:<br>
• Elminação de subexpressões locais comuns, ou seja, expressões que o valor já foi com-<br>
putado anteriomente;<br>
• Eliminação de código morto;<br>
• Reordernamento de declarações buscando reduzir o tempo que o valor temporário necessita<br>
ser preservado em um registro;<br>
A Figura 13 apresenta um bloco básico com algumas instruções, no caso apresentando<br>
são 4 operações entre somas e multiplicação e a partir deste bloco a Figura 14 apresenta o GDA<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 30<br>
Figure 13 – Exemplo de bloco basico de código.<br>
1 a = b + c<br>
2 b = a ? d<br>
3 c = b + c<br>
4 d = a ? d<br>
Fonte: (AHO et al., 2007)<br>
Figure 14 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
deste trecho de código. Nele apresenta cada nó como uma operação especifica e os terminais<br>
como as parcelas das operações.<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC<br>
Grafo de fluxo de controle corresponde a um grafo direcionado, no qual cada nó rep-<br>
resenta blocos básicos e cada aresta representa os caminhos de fluxo entre os blocos basi-<br>
cos (ALLEN, 1970). É importante ressaltar que saltos determinam o final de um determinado<br>
bloco básico, ou seja, saltos indicam um caminho para uma nova região de código básico (AHO<br>
et al., 2007).<br>
Apresentar <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >um exemplo de</span> como e utilizado em código<br>
2.3.2.3 Eliminção de código morto<br>
A eliminacação de código morto é uma técnica que busca a eficiência de um programa<br>
evitando a execução de instruções não necessária em tempo de execução (KNOOP et al., 1994).<br>
O código morto consiste em instruções que não serão alcançáveis durante o fluxo do programa,<br>
sendo esta técnica basicamente a retirada de qualquer variável que não será utilizada em qualquer<br>
outro nó do grafo (AHO et al., 2007).<br>
A utilização de GAD corresponde na eliminação de qualquer nó raiz, ou seja, nó sem<br>
ancestrais, as quais não esteja ativa anexada a mesma. A execução repetida desta operação<br>
removerá todos os nós correspondentes a código morto (AHO et al., 2007).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 31<br>
Figure 15 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
Na Figura 15, supondo que os nós a, <span class='f1 c_7' id='c_7_1' href='#c_7_2' cs_f='.c_7' >b e c</span> estejam ativa, porém o nó énão esteja, o último Corrigir<br>
nó é?pode ser eliminado imediatamente. Os nós restantes continuam no GDA, a menos que não tenho<br>
variáveis ativas atreladas aos nós (AHO et al., 2007).<br>
2.3.2.4 Análise do <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >fluxo de dados</span><br>
Análise de <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >fluxo de dados</span> refere-se ao conjunto de técnicas que derivam informações<br>
sobre o <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >fluxo de dados</span> ao longo dos caminhos de execução do programa. Para análise do<br>
programa, é necessário considerar todas as posiveis execuções através do grafo de fluxo de<br>
controle (AHO et al., 2007).<br>
Apresentar exemplos<br>
2.3.2.5 Gerador de código<br>
O gerador de código é responsavél pela tradução final do programa-fonte para o programa-<br>
alvo, o mesmo recebe como entrada um código intermediário juntamente com a tabela de<br>
símbolos. Faz-se necessário que o programa-fonte tenha sido analisado sintatica e lexicamente,<br>
assim evitando que erros possam ser passados para o programa-alvo, por outro lado a existência<br>
de uma nível de otimização, faz-se opicional neste caso (AHO et al., 2007).<br>
O gerador de código possui três tarefas primarias, sendo as mesmas seleção de instrução,<br>
alocação de registros e atribuições. A seleção de instruções envolve a escolha das instruções<br>
apropriadas da máquina-alvo para implementar as declarações do código intermediario. A<br>
atribuição e atribuição de registros envolve a decisão sobre os valores a serem registrados nos<br>
registros(AHO et al., 2007).<br>
Apresentar exemplo<br>
32<br>
3 TRABALHOS CORRELATOS<br>
Sugiro apenas mencionar que foi feito a revisão sistemática; o que já foi feito e os resul-<br>
tados. As outras seções sobre RS e mover para apêndice.<br>
3.1 Revisão sistemática<br>
A revisão sistemática consiste é um método de identificação, análise e interpretação de<br>
pesquisas relevantes em determinada área ou questão de pesquisa. Para execução da revisão sis-<br>
temática se requer um esforço maior, em comparação as pesquisas tradicionais, sendo necessário<br>
seguir uma sequência de passos metodológicos sobre a área ou questão de pesquisa ao qual<br>
deseja ser feita a pesquisa (KITCHENHAM, 2004).<br>
Para a execução da revisão sistemática, é necessário um esforço considerável, se com-<br>
parado a uma revisão informal a literatura. Enquanto que a revisão de literatura informal é<br>
conduzida de forma ad-hoc, sem planejamento e critérios de seleção estabelecidos a priori,<br>
a revisão sistemática requer um protocolo formal bem definido, com uma sequência de pas-<br>
sos metodológicos, para conduzir uma pesquisa sobre o tema ao qual deseja-se realizar a<br>
pesquisa (MAFRA; TRAVASSOS, 2006).<br>
A aplicação da revisão sistemática requer que seja seguido um conjunto bem definido e<br>
sequêncial de passos, seguindo um protocolo de pesquisa desenvolvido previamente. Através<br>
deste método é possível realizar uma extensa pesquisa, contemplando uma grande quantidade<br>
de informações sobre o assunto pesquisado (MAFRA; TRAVASSOS, 2006). Este protocolo é<br>
construído considerando um tema específico que representa o elemento central da investigação,<br>
onde os passos da pesquisa, as estratégias definidas para coletar as evidências e o foco das<br>
questões de pesquisa são definidas explicitamente, de tal forma que outros pesquisadores sejam<br>
capazes de reproduzir o mesmo protocolo de pesquisa (BIOLCHINI et al., 2005).<br>
Segundo MAFRA; TRAVASSOS, o processo para a condução de revisões sistemáticas<br>
envolve três etapas:<br>
1. Planejamento da Revisão: os objetivos da pesquisa são listados e o protocolo da revisão<br>
é definido.<br>
2. Condução da Revisão:nesta atividade, as fontes para a revisão sistemática são sele-<br>
cionadas, os estudos primários são identificados, selecionados e avaliados de acordo com<br>
os critérios de inclusão, exclusão, e de qualidade estabelecidos durante o protocolo da<br>
revisão.<br>
Chapter 3. TRABALHOS CORRELATOS 33<br>
3. Análise dos Resultados: os dados dos estudos são extraídos e sintetizados para análise e<br>
apresentação dos resultados.<br>
Vale ressaltar que como o objetivo deste trabalho é realizar um estudo exploratório de<br>
caracterização de área podemos dizer que esta revisão sistemática se caracteriza como uma quasi-<br>
sistemática (TRAVASSOS et al., 2008), pois segue o mesmo processo da revisão sistemática e<br>
preserva o rigor e mesmo formalismo para as fases metodológicas de elaboração de protocolo e<br>
execução da revisão, mas sem a aplicação de uma meta-análise a princípio, que pode ser aplicada<br>
posteriormente.<br>
3.1.1 Planejamento da Revisão Sistemática<br>
Objetivo: Este estudo tem o objetivo esquematizado a partir da estrutura do paradigma<br>
GQM (do ingles Goal,Question and Metric)(BASILI et al., 1994).<br>
Analisar Publicações científicas através de um estudo baseado em revisão sis-<br>
temática<br>
Com propósito de Identifica-las<br>
Com relação as <span class='f1 c_11' id='c_11_1' href='#c_11_2' cs_f='.c_11' >Vantagens e desvantagens</span> da utilização de assertiva e transformações<br>
de código na verificação do código na linguagem de descrição VHDL<br>
Do ponto de vista do Pesquisador<br>
No contexto Acadêmico ou industrial para verificação de assertivas na linguagem<br>
de descrição VHDL<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM<br>
Formulação da Pergunta: Buscamos respostas para as seguintes perguntas:<br>
• Q1: Quais são os métodos para verificação de circuitos lógicos descritos na linguagem de<br>
programação VHDL?<br>
– Q1.1: Foi desenvolvido e está disponível alguma ferramenta para aplicação do<br>
método?<br>
– Q1.2: Qual a técnica de exploração de estados para circuitos lógicos?<br>
– Q1.3: O método proposto é baseado em técnicas de verificação de software?<br>
– Q1.4: Como o método proposto valida pré e pós condições no programa?<br>
– Q1.3: Foi utilizado algum benchmark de programas em VHDL para experimentação<br>
e o mesmo encontra-se disponível?<br>
– Q1.4: Quais as perspectivas futuras para melhorar da aplicação do método proposto?<br>
Escopo da pesquisa:Na delimitação do escopo da pesquisa foram estabelecidos critérios,<br>
buscando garantir a viabilidade da execução, acessibilidade dos dados e abrangência do estudo re-<br>
alizado. A pesquisa dar-se-á a partir de bibliotecas digitais através das suas respectivas máquinas<br>
Chapter 3. TRABALHOS CORRELATOS 34<br>
de busca e, quando os dados não estiverem disponíveis eletronicamente, através de consultas<br>
manuais.<br>
Critérios de Seleção de Fontes. Para as bibliotecas digitais é desejado:<br>
• Possuir uma máquina de busca que permita o uso de expressões lógicas ou mecanismo<br>
equivalente.<br>
• Incluir em sua base, publicações de exatas ou correlatas que possuam relação direta com o<br>
tema a ser pesquisado<br>
• As máquinas de busca deverão permitir a busca no texto completo das publicações.<br>
Segundo ROCHA et al., os mecanismos de busca utilizados devem garantir resultados<br>
únicos através da busca de um mesmo conjunto de palavras-chaves (string de busca). Quando<br>
isto não for possível, deve-se estudar e documentar uma forma de minimizar os potenciais efeitos<br>
colaterais desta limitação.<br>
Métodos de Busca das Publicações. As fontes digitais foram acessadas via Web, através<br>
de expressões de busca pré-estabelecidas. A biblioteca digital consultada foi a Scopus, acessível<br>
em http://www.scopus.com. Segundo a editora ELSEVIER, a Scopus é uma das maiores bases<br>
de dados de resumos e citações da literatura de pesquisa peer-reviewed com mais de 22, 800<br>
títulos de mais de 5, 000 editoras internacionais abrangendo as áreas de tecnologia, medicina,<br>
artes, ciências sócias e com atualizações diárias. Entre as editoras podemos citar: Springer<br>
(SPRINGER, 2018); IEEE Xplore Digital Library (IEEE, 2018);ACM Digital Library (ACM,<br>
2018) ; ScienceDirect/Elsevier (B.V, 2018); Wiley Online Library (SONS, 2018); dentre outras.<br>
String de Busca. A string de busca foi definida segundo o padrão PICO (do inglês<br>
Population, Intervention, Comparison, Outcomes) (KITCHENHAM et al., 2009), conforme a<br>
estrutura abaixo:<br>
• População: Trabalhos publicados em conferências e periódicos que relacionam verificação<br>
de propriedades de circuitos lógicos em códigos para a descrição de hardware.<br>
• Intervenção: Verificação de propriedades relacionadas a verificação de circuitos para as<br>
diferentes estruturas das linguagens de descrição de hardware;<br>
• Comparação: análise de cobertura e suporte das abordagens identificadas para a verificação<br>
de propriedades das linguagens de descrição de hardware;<br>
• Resultados: a partir da descrição das abordagens pretende-se verificar a cobertura que cada<br>
abordagem apresenta na manipulação das diferentes estruturas da linguagem de descrição<br>
de hardware para a verificação de propriedades baseada em assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 35<br>
Segundo ROCHA et al., como este estudo representa um estudo de mapeamento/caracteri-<br>
zação, a string de busca foi definida de acordo com dois aspectos: População e Intervenção, como<br>
é apresentado na estrutura abaixo. Posteriormente esta mesma string de busca será executada<br>
na biblioteca Scopus para busca de artigos e publicações de modo a gerar uma interseção entre<br>
população e intervenção.<br>
• População: publicações que fazem referência a verificação de propriedades de circuitos<br>
lógicos e sinônimos:<br>
– Palavras-chaves: "circuit checker" OR "circuit verification" OR "contract based<br>
verification" OR "code analysis" OR "static analysis" OR "dynamic analysis" OR<br>
"safety verification" OR "RTL analysis" OR "program analysis" OR "property veri-<br>
fication" OR "formal verification" OR "model checking" OR "model checker" OR<br>
"hardware checker" OR "hardware verification" OR "validity checker" OR "hard-<br>
ware assertion" OR "assertion checker" OR "assert verification" OR "assertion-based<br>
verification" OR "assertion based verification" OR "assertion-based design" OR "bit<br>
level verification"<br>
• Intervenção: Verificação de circuitos e sinônimos:<br>
– Palavras-chaves:"hardware statement" OR "hardware code" OR "hardware source<br>
code" OR "hardware semantics" OR "hardware property" OR "logical gates" OR<br>
"sequential circuit" OR "parallel circuit" OR "real circuits" OR "complex circuits"<br>
OR "control circuitry" OR ”software netlist” OR “hardware emulation” OR “silicon<br>
debug”<br>
3.1.1.1 Procedimentos de Seleção e Critérios<br>
A estratégia de busca será aplicada por um pesquisador para identificar as publicações<br>
em potencial. A seleção das publicações dar-se-á em 2 etapas, conforme apresentado a seguir.<br>
1. Seleção e catalogação preliminar dos dados coletados: A seleção preliminar das publi-<br>
cações será feita a partir da aplicação da string de busca na biblioteca Scopus, o resultado<br>
desta busca corresponde a seleção preliminar. Todas as publicações serão armazenadas<br>
para análise posterior;<br>
2. Seleção dos dados relevantes - [1 filtro]: A seleção preliminar <span class='f1 c_13' id='c_13_1' href='#c_13_2' cs_f='.c_13' >com o uso</span> da expressão<br>
de busca não garante que todo o material coletado seja útil no contexto da pesquisa, pois a<br>
aplicação das expressões de busca é restrita ao aspecto sintático. Por isso, é necessário a<br>
criação de filtros de exclusão e inclusão, de modo a classificar os artigos e publicações que<br>
se enquadram no contexto da pesquisa realizada. Nesta epata apenas serão lidos o título,<br>
abstracts, e palavras-chaves e classificar de acordo com os filtros, ou seja, se será aceito ou<br>
excluído. Devem ser excluídas as publicações contidas no conjunto preliminar que:<br>
Chapter 3. TRABALHOS CORRELATOS 36<br>
• CE1-01: Não serão selecionadas publicações em que as palavras-chave da busca<br>
não apareçam no título, resumo e/ou texto da publicação (excluem-se os seguintes<br>
campos: as seções de agradecimentos, biografia dos autores, referências bibliográficas<br>
e anexas).<br>
• CE1-02: Não serão selecionadas publicações em que descrevam e/ou apresentam<br>
‘keynote speeches’, tutoriais, cursos e similares.<br>
• CE1-03: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação/validação de códigos para descrição de hardware.<br>
• CE1-04: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação de código de descrição de hardware baseado em assertivas ou propriedades<br>
de verificação de hardware.<br>
Podem ser incluídas apenas as publicações contidas no conjunto preliminar que:<br>
• CI1-01:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita uma abordagem para verificação<br>
de código de descrição de hardware baseado em assertivas ou propriedades de<br>
verificação de hardware.<br>
• CI1-02:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita recomendações de melhoria<br>
na utilização de abordagens para verificação de código de descrição de hardware<br>
baseado em assertivas ou propriedades de verificação de hardware.<br>
3. Seleção dos dados relevantes - [2 filtro]: Apesar do 1o filtro limitar o universo de busca,<br>
infelizmente não há garantias de que todo material selecionado no filtro anterior seja útil<br>
no contexto da pesquisa. Neste caso, novos filtros são gerados, buscando, da mesma forma<br>
que o primeiro filtro, classificar os artigos e publicações que se enquadram no contexto<br>
da pesquisa. Para este filtro é necessário a leitura na integras dos artigos selecionados<br>
anteriormente. O objetivo é identificar que relacionam assertivas e/ou propriedade de<br>
verificação de hardware.<br>
• CS2 -ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware e não citam assertivas<br>
• CS2 +ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware, mas citam assertivas<br>
• CS2 -ASS +VER_HARD: Não devem ser selecionadas publicações que contextual-<br>
izam verificação de hardware, mas citam assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 37<br>
Dessa forma, todas as publicações devem respeitar o critério abaixo:<br>
• CS3 +ASS +VER_HARD: Serão selecionadas publicações que contextualizam<br>
verificação de hardware e citam assertivas em seu contexto.<br>
Devido ao tempo necessário <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >para o desenvolvimento</span> execução dos filtros da revisão<br>
sistemática serem extensos, apenas o primeiro filtro foi executado neste projeto, mesmo que<br>
os parâmetros para o segundo filtro já tenho sido desenvolvidos. Em contra partida foram<br>
selecionados 6 artigos que serviram como ferramentas de estudo <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >para o desenvolvimento</span> da<br>
metodologia que será apesentada no Capítulo 4.<br>
3.2 Revisão da literatura<br>
Nesta sessão serão apresentados trabalho relevantes <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >para o desenvolvimento do</span> método<br>
proposto que foram identificados utlizando a revisão sistemática mencionado anteriormente.<br>
Os artigos apresentam técnicas de transformações de código, utilização de Assertion-Based<br>
Verification e PSL para verificação de hardware.<br>
3.2.1 V2c-A verilog to C translator<br>
O artigo de MUKHERJEE et al. apresenta uma ferramenta implementada em C++<br>
chamada v2c para transformação de código da linguagem de descrição Verilog para linguagem<br>
de programação C. A ferramenta é executada a nível de palavra, visto que esta abordagem garante<br>
uma aumento na escalabilidade, mas também proporionando que técnicas, como interpolaçãoe adicionar<br>
refer-<br>
ência<br>
aceleração de looppossam ser utilizadas para verificação, algo inviavél, caso a tradução fosse<br>
adicionar<br>
refer-<br>
ência<br>
executada a nível de bit. O sistema recebe como entrada um código em Verilg, onde são aplicadas<br>
regras semânticas e mapeando os bit de operação, chamado software netlist. Após isso, o código<br>
intermediário é convertido para C.<br>
A contribuição deste trabalhoconsiste na utilização de transformações de código como<br>
Qual<br>
tra-<br>
balho?<br>
base principal e partindo deste pressuposto torna-se vantajoso devido a utilização de outras<br>
ferramentas que não apresente suporte a certas linguagens, tais com a ferramenta ESBMC,<br>
utilizada neste trabalho, não apresenta suporte a VHDL, porém apresenta suporte as linguagens<br>
C/C++. Em outras palavras, a contribuição deste trabalhofoi a utilização de traduções de códigos<br>
Qual<br>
tra-<br>
balho?<br>
e utilizado este conceito como modelo de entrada para analise de circuitos.<br>
3.2.2 Unbounded safety verification for hardware using software ana-<br>
lyzers<br>
No artigo de MUKHERJEE et al. foi apresentado uma metodologia que aborda a utiliza-<br>
ção de técnicas e analisadores de software, com o objetivo de de abordar a análise de circuitos e<br>
Chapter 3. TRABALHOS CORRELATOS 38<br>
com isso trançar um paralelo entre as abordagens. Para testes foram utilizadas três metodologias<br>
de análise, usando interpolação, k-inductione tecnologias hibrídas. Como resultante dos testes, foi adicionar<br>
refer-<br>
ência<br>
adicionar<br>
refer-<br>
ência<br>
observado as principais causas de erros, por exemplo, bits não preciso e no caso das operações<br>
a bit-level ocorria perda de informações. Também foi obeservado que apesar de não serem<br>
otimizadas para análises de hardware, alguns analisadores de softaware podem, dependendo da<br>
técnica utilizada no analisador, <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >ser utilizada para</span> analise de hardware.<br>
Descrever<br>
qual<br>
o mo-<br>
tivo.<br>
A utilização de técnicas de análise de software <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >para o desenvolvimento</span> de análise de<br>
hardware é o foco a ser abordado neste neste trabalho de maneira prática, utilizando os princípio<br>
analisados por (MUKHERJEE et al., 2016a). Neste contexto, o objetivo deste trabalho é a<br>
utilização de técnicas de software para análise de circuitos, diferente do artigo apresentado acima<br>
que busca utilização uma abordagem mais complexa provando a possibilidade da utilização de<br>
técnicas de analise de software no contexto da verificação de hardware.<br>
A última frase está confusa, no meu entedimento é o mesmo sentido.<br>
3.2.3 Formal verification of timed VHDL programs<br>
No trabalho apresentado por BARA et al. é proposto uma abordagem para a análise<br>
de tempo relacionado a cada porta lógica dentro de um dado circuito analisado. A abordagem<br>
apresenta a tradução de um circuito lógico codificado em VHDL para um formalismo baseado<br>
em automato de tempo. Tal formalismo é representado por uma automato de estados finitos referência<br>
com relogios simbólicos que evoluem em taxa uniforme. A tradução é executada de modo<br>
automatico, baseado na emulação da propagação de cada transação ao longo de cada sinal, o<br>
seja, são automatos programados e cronometrados do circuito. Após a tradução para automato, a<br>
analise é feita pela ferramenta UPPALque é um model checking de verificação de propriedades referência<br>
de tempo. Seguindo esta metodologia a análise pode ser extraida de modo independente de cada<br>
bloco, desta forma a análise é feita de forma mais precisa, podendo ser analisado inumeros<br>
fatores, tais como limites de intervalo e sinal de correlação.<br>
O artigo apresenta uma abordagem de tempo, que torna-se interessante adição ao método.<br>
Porém até o momento a função não foi implementada ficando a trabalho futuros.<br>
Expandir o texto acima, exemplo, descrever como o método poderia ser incluindo no seu<br>
TCC.<br>
3.2.4 On the use of assertions for embedded-software dynamic verifica-<br>
tion<br>
Em GUGLIELMO et al. é apresentado uma metodologia para a integração dinamica de<br>
Assertion-Based Verification para várias fases da análise da verificação de fluxo em sistemas<br>
embarcados, por exemplo, emulação, diagnosticos e Debug, mas também um ferramenta chamada<br>
Chapter 3. TRABALHOS CORRELATOS 39<br>
RadCheck. O metodo de aplicação, chamado V-model é dividido em fases de verificação em<br>
paralelo com as fases de design do circuito. Com base no V-model, o método é aplicado, iniciando<br>
com o nível de sistema e as especificação do sistema, neste caso especificado usando PSL.<br>
Neste nível é especificado todas as funcionalidades gerais da aplicação. No nível de integração<br>
visa investigar problemas de interação que possam ocorrer, definindo propriedades que cobrem<br>
incrementalmente as unidades estruturais interativas de aplicação. No nível de unidade descrevem<br>
comportamentos internos e são definidas através de parâmetros de entrada/saída das unidade e<br>
estruturas de dados internas.<br>
A contribuição deste projeto está relacionado a utilização de assertivas no contexto da<br>
verificação de software. As assertivas são o principal meio de análise proposto neste projeto,<br>
visto que estas mesma assertivas serão analisadas pelo ESBMC. Aliado a isso em GUGLIELMO<br>
et al. é apresentado modelos de utilização de assertivas no processo de verificação de hardware,<br>
e tais assertivas foram adaptadas para um modelo proposto neste trabalho.<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation<br>
No trabalho de BOULE; ZILIC é apresentado uma ferramenta de geração de assertivas<br>
no contexto da emulação de circuitos, de modo que estas assertivas descrita em PSL possam<br>
transformadas para o modelo de linguagem de descrição de hardware. Inicialmente é realizada<br>
toda análise de cada assertiva e a mesma é traduzida em partes, levando em consideração os<br>
operadores e cada estrutura, por exemplo if-else, utilizado na declaração da assertiva.<br>
Apresentar um exemplo para explicar o texto acima<br>
trabalho de BOULE; ZILIC consolida e apresenta aspectos importantes, tais como a<br>
utilização de uma ferramenta para geração de assertivas, o que torna-se no contexto deste projeto,<br>
extremamente importante, visto que o modelo adotado atualmente consiste tanto na geração<br>
automática das assertivas, bem como a inserção manual por parte do usuário.<br>
40<br>
4 MÉTODO PROPOSTO<br>
Este Capítulo descreve o método proposto neste trabalho, baseado transformações de<br>
código para análise de circuitos lógicos descritos em VHDL utilizando Bounded Model Checking,<br>
neste caso o model checker ESBMC.<br>
4.1 Visão geral do método<br>
O método proposto consiste inicialmente em receber como entrada um circuito lógico<br>
descrito em VHDL, onde uma dada propriedade representada em uma assertiva será analisada,<br>
as assertivas serão inseridas de automaticamente pelo método ou pelo próprio usuário do método.<br>
O código VHDL analisado posteriomente é traduzido para linguagem C e recebe uma instrumen-<br>
tação de código (com funções especificas suportadas pelo método) para a posterior validação do<br>
mesmo. O Código em C automaticamente gerado, já instrumentado, será processado e analisado<br>
pelo ESBMC de acordo com as assertivas inseridas e ao final é apresentado o resultado. Caso<br>
alguma das assertivas seja violada, um contra-exemplo é apresentado ao usuário. Uma visão<br>
geral do método proposto é apresentado na Figura 16 e nas sessões a seguir serão apresentados<br>
cada etapa do método proposto neste trabalho.<br>
Figure 16 – Ciclo da ferramenta<br>
Fonte: Própria<br>
Com o intuito de auxiliar nas explicações apresentadas nas próximas sessões, o código<br>
na Figura 17 será utilizado nas explanações, bem como será apresentado todas as alterações do<br>
mesmo, conforme cada etapa do método.<br>
Chapter 4. MÉTODO PROPOSTO 41<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 ENTITY U l a _ t c c IS<br>
5 PORT(A, B , B i n v e r t i d o , Op1 , Op2 : IN BIT ;<br>
6 R e s u l t a d o :OUT BIT ) ;<br>
7 END U l a _ t c c ;<br>
8<br>
9 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
10 SIGNAL a n d _ p o r t : b i t ;<br>
11 SIGNAL o r _ p o r t : b i t ;<br>
12 SIGNAL x o r _ p o r t : b i t ;<br>
13 SIGNAL mux2x1 : b i t ;<br>
14 BEGIN<br>
15 PROCESS(A, B , B i n v e r t i d o , Op1 )<br>
16 BEGIN<br>
17 ??PORTA AND<br>
18 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
19 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
20 ELSE<br>
21 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
22 END IF ;<br>
23 ??PORTA OR<br>
24 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
25 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
26 ELSE<br>
27 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
28 END IF ;<br>
29 ??PORTA XOR<br>
30 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
31 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
32 ELSIF (A = ’ 1 ’ and mux2x1 = ’ 1 ’ ) THEN<br>
33 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
34 ELSE<br>
35 x o r _ p o r t &lt;= ’ 1 ’ ;<br>
36 END IF ;<br>
37 ??INVERSOR<br>
38 IF ( B i n v e r t i d o = ’ 0 ’ ) THEN<br>
39 mux2x1 &lt;= B ;<br>
40 ELSE<br>
41 mux2x1 &lt;= NOT B ;<br>
42 END IF ;<br>
43 ??MUX4X1<br>
44 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
45 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
46 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
47 R e s u l t a d o &lt;= o r _ p o r t ;<br>
48 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
49 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
50 END IF ;<br>
51 END PROCESS ;<br>
52 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 42<br>
4.2 Preprocessamento do VHDL e inserção de assertivas<br>
A fase inicial do método consiste no preprocessamento do código VHDL com as an-<br>
otações de código pelo usuário ou pelo método proposto de forma automática, incluindo as<br>
assertivas, conforme a Figura 16, na etapa A. O método não realiza qualquer tipo de verificação<br>
sobre o código VHDL, apenas utiliza o mesmo como entrada juntamente com as assertivas<br>
inseridas. Toda verificação é realizada sobre o código em linguagem C, que será traduzido a<br>
partir do código VHDL analisado, nas próximas etapas do método proposto. Vale ressaltar que<br>
mesmo a linguagem VHDL tendo um modelo de assertivas padrão, para o método tornou-se<br>
necessário a criação de um modelo (baseado em comentários) para que as funções do model<br>
checker adotado fossem suportadas, como a geração de valores não deterministicos.<br>
As assertivas manuais são adicionadas entre as tags @c2vhdl:ASSERT e @c2vhdl:END<br>
e todo trecho de código entre estas tags deve estar comentado, desta forma não apresentará<br>
erro na tradução do código em linguagem C, bem como na sintetização do código VHDL. Nas<br>
assertivas são incluidas as funções necessárias para a análise utilizando a ferramenta ESBMC. A<br>
assertiva apresenta três informações principais, sendo elas: condição, mensagem e gravidade.<br>
Ajustar está assertiva. Para quem não vê o código todo, ela não faz sentido<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR.<br>
1 ??@c2vhdl : ASSERT<br>
2 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ )<br>
3 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 "<br>
4 ??s e v e r i t y ERROR;<br>
5 ??@c2vhdl :END<br>
Fonte: Própria.<br>
A condição (na linha 2 da Figura 19) representa a assertiva propriamente dita e que será<br>
analisado pela aplicação. A condição será precedida de??assert e seguido ou não da palavra<br>
not, com isso a assertiva pode assumir valor negativo, conforme necessidade do usuário. Na<br>
Figura 19 a assertiva busca verificar se a variavél Resultado terá valor igual a 1. Qual a<br>
razão<br>
para<br>
isso,<br>
ex-<br>
plique!<br>
A mensagem (??report na linha 3 da Figura 19) é definida pelo usuário e será<br>
apresentado caso a assertiva apresente falha, assim a mensagem pode ser utilizada como um meio<br>
de depuração das propriedades validadas. A severidade (severity na linha 4 da Figura 19)<br>
pode ser definida como error, que representa um erro fatal e parada da verificação. A severidade<br>
do tipo warning que representa um erro não fatal, contabiliza as falhas das assertivas, porém<br>
não causa a parada da verificação. As mensagens futuramente pode ser integradas um framework<br>
para teste de unidade, contudo está é uma etapa ainda em planejamento neste trabalho.<br>
Juntamente com as assertivas outra função que pode ser utilizada é a função __ESBMC<br>
Chapter 4. MÉTODO PROPOSTO 43<br>
_assume() suportada pelo model checker ESBMC. Esta função utilizada em conjuto com a<br>
ferramenta ESBMC permite que durante a verificação uma variavél possa ter uma valor setado<br>
durante o tempo de execução da verificação. A importância desta função é fazer verificações onde<br>
se conhece os valores de entrada juntamente com o valor resultante, por exemplo, na verificação<br>
de portas lógicas.<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume().<br>
1 ??__ESBMC_assume (A = ’ 1 ’ )<br>
2 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
Fonte: Própria.<br>
A assertivas que serão verificadas são automáticas traduzidas a partir das entradas do<br>
código VHDL. Seja no modelo manual (assertivas escritas pelo usuário) ou automático (inferidas<br>
pelo método proposto por meio de análise estática), as entradas são mapeadas para serem<br>
utilizados na etapa de instrumentação. Desta forma, tais entradas podem ser utilizadas para gerar<br>
essas assertivas e então serem adicionadas diretamente ao código em linguagem C durante a fase<br>
de instrumentação.<br>
A Figura 20 apresenta o código juntamente com as assertivas conforme o padrão salien-<br>
tado na section 4.2. Neste exemplo foi implementado utilizado a inserção manual das assertivas<br>
e também da função __ESBMC_assume(), entretanto o objetivo é automatizar estas funções<br>
durante a execução da ferramenta.<br>
4.3 Tradução de código VHDL para a linguagem C<br>
Nesta etapa a tradução do código VHDL para linguagem C é executada, conforme<br>
apresentado na Figura 16, etapa B. A partir deste ponto, a ferramenta é executada de maneira<br>
propriamente dita, tendo todo o processo automatizado até a apresentação do resultado. Para<br>
esta etapa do método foi selecionado a ferramenta V2Cque realiza a tradução de VHDL para Adicionar<br>
refer-<br>
ência<br>
Linguagem C.<br>
A ferramenta V2C apresenta diversas vantagens em relação a equivalência de tradução<br>
de linguagens, contudo V2C apresenta certas limitação na tradução do código VHDL, em outras<br>
palavras, a mesma não reconhece algumas estruturas especificas do VHDL. A ferramenta aceita<br>
apenas entradas e saídas do tipo: bit, std_ulogic, qsim_state, std_ulogic_vector<br>
e interger. Na parte de arquitetura, a ferramenta aceita uma gama maior de estruturas, tra-<br>
balhando com expressoões do tipo: signal, variable, integers, strings e caracteres.<br>
Em expreções condicionais os operandos são AND, OR, NOT &lt;=, =&gt;,=,&lt;,&gt; e &lt;&gt;. Aceita<br>
também a estrutura de process, além da estutura block. A estrutura process é limitada<br>
Chapter 4. MÉTODO PROPOSTO 44<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 . . .<br>
4 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
5 SIGNAL a n d _ p o r t : b i t ;<br>
6 SIGNAL o r _ p o r t : b i t ;<br>
7 SIGNAL x o r _ p o r t : b i t ;<br>
8 SIGNAL mux2x1 : b i t ;<br>
9 BEGIN<br>
10 PROCESS(A, B , B i n v e r t i d o , Op1 ) IS<br>
11 BEGIN<br>
12 ??PORTA AND<br>
13 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
14 ??__ESBMC_assume (A = ’ 1 ’ )<br>
15 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
16 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
17 ELSE<br>
18 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
19 END IF ;<br>
20 . . .<br>
21 ??MUX4X1<br>
22 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
23 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
24 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
25 R e s u l t a d o &lt;= o r _ p o r t ;<br>
26 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
27 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
28 ??@c2vhdl : ASSERT<br>
29 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
30 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
31 ??s e v e r i t y ERROR;<br>
32 ??@c2vhdl :END<br>
33 END IF ;<br>
34 END PROCESS ;<br>
35 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
apenas a: if-else, case e loops. Como trabalho futuro, neste trabalho tem-se buscado<br>
novas abordagens para ampliar o suporte a estruturas não suportadas pelo V2C.<br>
Na tradução é necessário substituir os operadores originais por seus equivalentes em<br>
linguagem C. A excessão são os operadore específicos que gerenciam os valores de bit, tais<br>
como concatenação ou manipulação de partes vertoriais, para os quais são necessários construir<br>
procedimentos especificos em C.<br>
Conforme mostrado na Figura 21, na tradução são gerados vários vetores para suporte<br>
a tradução dos sinais representados no VHDL, sendo eles chg[], old[] e new[]. O vetor<br>
old[] contém o valor do sinais do passo anteriore a partir deste vetor o valor a ser usado nos Confuso<br>
issocálculo é obtido. O vetor new[] representa os novos valores a serem calculados pelos antigose<br>
Qual?<br>
Chapter 4. MÉTODO PROPOSTO 45<br>
o vetor chg[] contém um or exclusivo entre o valor novo e antigo e em caso de alteração entre<br>
os valores é copiado o valor de new[] para old[].<br>
O texto acima está muito confuso, corrigi rapidamente<br>
No código C gerado, os vetores in_data[] e out_data[] contêm os sinais de<br>
entrada e saída, respectivamente. No caso de circuitos sequênciais, o valor do status é inserido<br>
no primeiro (índice 0). A funçãoentão lerá os valores in_data[] e escreverá os resultados do qual?<br>
processamento em out_data[]. Ao final da operações os valores de estado são passado para<br>
out_data[].<br>
Conforme especificado e seguindo os parametros da ferramenta, a mesma realiza a<br>
tradução, mantendo inalterado qualquer fragmento de código que esteja comentado, neste caso,<br>
as assertivas presentes no código VHDL permanecem inalteradas, sendo utilizadas na próxima<br>
etapa do método proposto.<br>
4.4 Instrumentação de código<br>
As assertivas após a tradução permanecem comentadas, sendo necessário prepara-lás, ou<br>
seja traduzi-las, para verificação posterior do código na linguagem em C. Com isso é necessário<br>
uma instrumentação do código para prover suporte as assertivas traduzidas para análise, conforme<br>
apresentado na Figura 16, etapa C.<br>
Todas as etapas da instrumentação são realizados sobre o código C já traduzido. O passo<br>
inicial da instrumentação é a adição da macros no inicio do código C com as definição das<br>
assertivas a serem utilizadas. Na Figura 22 são apresentados os macros utilizadas no código C. A<br>
Linha 1 da figura corresponde a mensagem de erro a ser apresentada e a Linha 2 corresponde<br>
ao modelo da assertiva e a chamanda da macro definida na Linha 1 em caso de falha. Estas<br>
definições para as assertivas também podem ser utilizadas no código C traduzidos sem <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >o uso do</span><br>
ESBMC.<br>
Figure 22 – Macros das assertivas implementadas em linguagem C<br>
1 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r ,M, __FILE__ , __LINE__ , # # __VA_ARGS__ )<br>
2 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
Fonte: Própria.<br>
O passo seguinte é a identificação das assertivas comentadas ao longo do corpo do<br>
código traduzido, utilizando o exemplo da Figura 23. As assertivas são identificadas através<br>
das tags @c2vhdl:ASSERT e @c2vhdl:END e a busca é realizado através destas tags. Ao<br>
ser encontrado a tag @c2vhdl:ASSERT, é realizado um loop até que seja encontrada a tag<br>
Chapter 4. MÉTODO PROPOSTO 46<br>
@c2vhdl:END e com isso toda a assertiva inserida possa ser passada a função de busca das<br>
informações da assertiva contidas entre as tags apresentadas.<br>
Com os dados das assertivas obtidos é realizado a busca da condição, mensagem e<br>
severidade através dos comandos ??assert, ??report e ??severity respectivamente.<br>
Estas informações são encontradas através do uso e uma Regex no código e que são adicionadas<br>
ao código C seguindo o modelo definido na macro. Este processo é repetido até outra assertiva<br>
ser encontrada ou caso chegue ao fina do código C.<br>
Com a função __ESBMC_assume() ocorre processo semelhante ao das assertivas.<br>
Utilizando novamente uma regex que realiza a busca por esta função no código e é retirado o<br>
comentário da mesma, desta forma a mesma passa a esta acessivél para o ESBMC, visto que a<br>
declaração da mesma já segue o modelo padrão a ser utilizado pelo ESBMC.<br>
Durante a instrumentação de código também é realizado a entrada de sinais não de-<br>
terministicos para variaveis não inicializadas ou argumentos de funções do código C gerado<br>
da tradução, utilizando a função __VERIFIER_nondet_int(). Esta função é utilizada em<br>
todas as variaveis de entrada e também nos sinais criados ao longo da arquitetura. Desta forma,<br>
todas as variavéis necessárias são inicializadas para verificação.<br>
Explicar o funcionamento do nondet com o ESBMC<br>
Em outras palavras, na instrumentação de código é realizado a traduçao das assertivas do<br>
modelo utilizado no código VHDL para para o modelo utilizado em linguagem C, além como de<br>
outras funções que possam ser utilizados pelo VHDL. Ao final da instrumentação o código C<br>
fica disponivel para que possa ser dado como entrada para outras ferramentas de verificação de<br>
código e não apenas o ESBMC.<br>
4.5 Verificação de assertivas usando Model Checker<br>
O model checker adotado no desenvolvimento de método é o ESBMCna versão 3.0.0 referência<br>
e conforme explicado na subsection 2.2.3, esta ferramenta recebe como entrada um código C<br>
ou C++ e devido a isso foi escolhida neste projeto. Nesta seção será apresentado a etapa D do apresentar<br>
outras<br>
vanta-<br>
gens<br>
métod proposto na Figura 16.<br>
Para a verificação, a primeira etapa é a identificação das assertivas no código C analisado,<br>
para isso é utilizado uma opção do ESBMC (??show-claims), mais especificamente as<br>
assertivas instrumentadas no código C analisado. Cada assertiva é identificada através de uma<br>
numeração de acordo com a ordem de busca do código analisado. Cada assertiva encontrada é<br>
armazenada para que seja realizada uma análise individual de cada claim, ou seja, assertiva.<br>
Chapter 4. MÉTODO PROPOSTO 47<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas.<br>
1 VAR<br>
2 c o n t a d o r : i n t e i r o<br>
3 c l a i m : l i s t a<br>
4 c l a i m _ s t r i n g : s t r i n g<br>
5<br>
6 FUNCAO c a l l _ e s b m c : a r q u i v o<br>
7 c o n t a d o r &lt;?0<br>
8 INICIO<br>
9 s a i d a &lt;?f un ca o de g e r a c a o das c l a i m s p e l o ESBMC<br>
10 ENQUANTO c o n t a d o r &lt; s a i d a FACA<br>
11 c o n t a d o r +=2<br>
12 r e g e x p a r a p r o c u r a r c l a i m e numeracao da c l a i m<br>
13 SE e n c o n t r a r c l a i m ENTAO<br>
14 r e g e x p a r a p r o c u r a r a p a l a v r a " a s s e r t i o n "<br>
15 SE e n c o n t r a r a p a l a v r a " a s s e r t i o n " ENTAO<br>
16 c o n t a d o r +=1<br>
17 A d i c i o n a a numeracao da c l a i m na l i s t a<br>
18 FIM?SE<br>
19 FIM?SE<br>
20 FIM?ENQUANTO<br>
21 FIM?FUNCAO<br>
Fonte: Própria.<br>
Na Linha 9 da Figura 24 é apresentado a chamada da ferramenta ESBMC que ocorre e<br>
através da opção ??show-claims lista todas as claims presentes no texto, como apresentado<br>
na Figura 25. Como o ESBMC infere de forma automatica assertivas a serem verificadas no<br>
código. Visando isolar somente as assertivas instrumentadas pelo método proposto, juntamente<br>
com a opção –show-claims é utilizado as opções:<br>
• ??no-pointer-check: para não realizar a checagem de ponteiros no código;<br>
• ??no-div-by-zero-check: para não realizar a checagem de divisões por zero no<br>
código; e<br>
• ??no-bounds-check: para não realizar a checagem de array bounds no código.<br>
Chapter 4. MÉTODO PROPOSTO 48<br>
Figure 25 – Imagem de claims contendo assertivas.<br>
Fonte:Própria<br>
Após a listagem das claims com assertivas ser gerada, outra função, indicada na Figura 26,<br>
é chamada para verificação de cada claim individualmente. Para cada claim, ocorre a chamada do<br>
ESBMC, utilizando as opções ??no-pointer-check, ??no-div-by-zero-check e<br>
??no-bounds-check, juntamente com a opção ??unwind em que realiza o número de<br>
desdobramentos dos laços no código analisado.<br>
Contudo, dependendo da complexidade da assertiva, faz-se necessário aumentar o número<br>
de desdobramentos que, por padrão são dez, conforme análise experimentais. A função é chamada<br>
na Linha 11 da Figura 26 e após a analise da claim é realizado a busca do resultado e exibição<br>
caso seja uma propriedade violada.<br>
Desta forma o ESBMC realiza apenas a checagem necessária dentro da assertiva, evitando<br>
que outros parâmetros sejam verificados, sem a devida necessidade do mesmo. Ao final de todos<br>
os desdobramentos é apresentado o resultado, apresentado na Figura 27, sendo positiva (sem<br>
erros) ou negativa (com violação de propriedades), dependendo da assertiva e do código analisado.<br>
Este processo se repete até a lista de assertivas ser finalizada.<br>
Chapter 4. MÉTODO PROPOSTO 49<br>
Figure 26 – Pseudocódigo da função de análise das claims.<br>
1 VAR<br>
2 c o n t a d o r 1 : i n t e i r o<br>
3 c o n t a d o r 2 : i n t e i r o<br>
4 r e s u l t a d o : l i s t a<br>
5<br>
6 FUNCAO esbmc_c la ims : l i s t a , a r q u i v o<br>
7 c o n t a d o r 1 &lt;?0<br>
8 c o n t a d o r 2 &lt;?0<br>
9 busca p e l o nome da fu nc a o no a r q u i v o<br>
10 ENQUANTO c o n t a d o r &lt; l i s t a FACA<br>
11 s a i d a &lt;?Execu ta comando de a n a l i s e da c l a i m<br>
numerada na l i s t a<br>
12 ENQUANTO c o n t a d o r 2 &lt; s a i d a<br>
13 Regex busca se a p r o p r i e d a d e f o i v i o l a d a<br>
14 SE p r o p r i e d a d e f o i v i o l a d a ENTAO<br>
15 Pu la p a r a l i n h a da v i o l a ç ã o<br>
16 A d i c i o n a o e r r o ao r e s u l t a d o<br>
17 FIM?SE<br>
18 FIM?ENQUANTO<br>
19 FIM?ENQUANTO<br>
20 FIM?FUNCAO<br>
Fonte: Própria.<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta.<br>
Fonte:Própria<br>
Ajustar os códigos, alguns estao muito grandes e com trechos desnecessário, não foi<br>
citado o link do repo da ferramenta<br>
Chapter 4. MÉTODO PROPOSTO 50<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C.<br>
1 void u l a _ t c c ( i n t i n _ d a t a [ ] , i n t o u t _ d a t a [ ] )<br>
2 {<br>
3 i n t _ i _ =0;<br>
4 i n t _c on t_ ;<br>
5 enum s e g n a l e {A, B , B i n v e r t i d o , Op1 , Op2 , R e s u l t a d o , and_po r t , o r _ p o r t ,<br>
6 x o r _ p o r t , mux2x1 , _MAX_} ;<br>
7 i n t o l d [_MAX_ ] ;<br>
8 i n t new [_MAX_ ] ;<br>
9 i n t chg [_MAX_ ] ;<br>
10 new [A] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
11 new [B] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
12 new [ B i n v e r t i d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
13 new [ Op1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
14 new [ Op2 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
15 new [ R e s u l t a d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
16 new [ a n d _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
17 new [ o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
18 new [ x o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
19 new [ mux2x1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
20<br>
21 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
22 {<br>
23 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
24 }<br>
25 new [A] = i n _ d a t a [ 1 ] ;<br>
26 new [B] = i n _ d a t a [ 2 ] ;<br>
27 new [ B i n v e r t i d o ] = i n _ d a t a [ 3 ] ;<br>
28 new [ Op1 ] = i n _ d a t a [ 4 ] ;<br>
29 new [ Op2 ] = i n _ d a t a [ 5 ] ;<br>
30<br>
31 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
32 {<br>
33 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
34 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
35 }<br>
36<br>
37 do {<br>
38 _ co n t _ =0;<br>
39 /? S t a r t o f T r a n s l a t i o n ? /<br>
40<br>
41 /? p0 : ? /<br>
42 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
43 /?PORTA AND ? /<br>
44 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
45 \ \ __ESBMC_assume ( o l d [A] = 1) ;<br>
46 \ \ __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
47 new [ a n d _ p o r t ] = 1 ;<br>
48 }<br>
49 e l s e {<br>
50 new [ a n d _ p o r t ] = 0 ;<br>
51 }<br>
52 /?PORTA OR ? /<br>
53 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
54 new [ a n d _ p o r t ] = 0 ;<br>
55 }<br>
56 e l s e {<br>
57 new [ a n d _ p o r t ] = 1 ;<br>
58 }<br>
59 /?PORTA XOR ? /<br>
60 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
61 new [ x o r _ p o r t ] = 0 ;<br>
62 }<br>
63 e l s e i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==1) ) {<br>
64 new [ x o r _ p o r t ] = 0 ;<br>
65 }<br>
66 e l s e {<br>
67 new [ x o r _ p o r t ] = 1 ;<br>
68 }<br>
69 /? INVERSOR ? /<br>
70 i f ( ( o l d [ B i n v e r t i d o ]==0) ) {<br>
71 i f ( chg [B ] ) {<br>
72 new [ mux2x1 ]= o l d [B ] ;<br>
73 }<br>
74 }<br>
75 e l s e {<br>
76 i f ( chg [B ] ) {<br>
77 new [ mux2x1 ]=~ o l d [B ] ;<br>
78 }<br>
79 }<br>
80 /?MUX4X1 ? /<br>
81 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
82 i f ( chg [ a n d _ p o r t ] ) {<br>
83 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
84 \ \ @c2vhdl : ASSERT<br>
85 \ \ a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
86 \ \ r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
87 \ \ s e v e r i t y ERROR;<br>
88 \ \ @c2vhdl :END<br>
89 }<br>
90 }<br>
91 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
92 i f ( chg [ o r _ p o r t ] ) {<br>
93 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
94 }<br>
95 }<br>
96 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
97 i f ( chg [ x o r _ p o r t ] ) {<br>
98 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
99 }<br>
100 }<br>
101 }<br>
102<br>
103 /? End o f T r a n s l a t i o n ? /<br>
104 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
105 {<br>
106 i f ( new [ _ i _ ] ! = o l d [ _ i _ ] ) _ con t_ =1;<br>
107 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
108 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
109 }<br>
110 } whi le ( _c on t_ ) ;<br>
111<br>
112 new [A] &= 0X01 ;<br>
113 new [B] &= 0X01 ;<br>
114 new [ B i n v e r t i d o ] &= 0X01 ;<br>
115 new [ Op1 ] &= 0X01 ;<br>
116 new [ Op2 ] &= 0X01 ;<br>
117 new [ R e s u l t a d o ] &= 0X01 ;<br>
118 new [ a n d _ p o r t ] &= 0X01 ;<br>
119 new [ o r _ p o r t ] &= 0X01 ;<br>
120 new [ x o r _ p o r t ] &= 0X01 ;<br>
121 new [ mux2x1 ] &= 0X01 ;<br>
122<br>
123 o u t _ d a t a [ 0 ] = 0 ; _ i _ =0;<br>
124 o u t _ d a t a [ 0 ] | = new [A] &lt;&lt; _ i _ ; _ i _ +=1;<br>
125 o u t _ d a t a [ 0 ] | = new [B] &lt;&lt; _ i _ ; _ i _ +=1;<br>
126 o u t _ d a t a [ 0 ] | = new [ B i n v e r t i d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
127 o u t _ d a t a [ 0 ] | = new [ Op1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
128 o u t _ d a t a [ 0 ] | = new [ Op2 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
129 o u t _ d a t a [ 0 ] | = new [ R e s u l t a d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
130 o u t _ d a t a [ 0 ] | = new [ a n d _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
131 o u t _ d a t a [ 0 ] | = new [ o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
132 o u t _ d a t a [ 0 ] | = new [ x o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
133 o u t _ d a t a [ 0 ] | = new [ mux2x1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
134<br>
135 o u t _ d a t a [ 1 ] = new [ R e s u l t a d o ] ;<br>
136 }<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 51<br>
Figure 23 – Código com assertivas traduzida para linguagem C<br>
1 # inc lude &lt; s t d i o . h&gt;<br>
2 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r , M , __FILE__ , __LINE__ , ##<br>
__VA_ARGS__ ) / / Update t o p r i n t t h e t r a c e<br>
3 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
4<br>
5 . . .<br>
6<br>
7 do {<br>
8 _co n t _ =0;<br>
9 /? S t a r t o f T r a n s l a t i o n ? /<br>
10 chg [A] = __VERIFIER_nondet_int ( ) ;<br>
11 chg [B] = __VERIFIER_nondet_int ( ) ;<br>
12 chg [ B i n v e r t i d o ] = __VERIFIER_nondet_int ( ) ;<br>
13 chg [ Op1 ] = __VERIFIER_nondet_int ( ) ;<br>
14 chg [ a n d _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
15 chg [ R e s u l t a d o ] = __VERIFIER_nondet_int ( ) ;<br>
16 chg [ o r _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
17 chg [ mux2x1 ] = __VERIFIER_nondet_int ( ) ;<br>
18<br>
19 /? p0 : ? /<br>
20 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
21 /?PORTA AND ? /<br>
22 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
23 __ESBMC_assume ( o l d [A] = 1) ;<br>
24 __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
25 new [ a n d _ p o r t ] = 1 ;<br>
26 }<br>
27 e l s e {<br>
28 new [ a n d _ p o r t ] = 0 ;<br>
29 }<br>
30<br>
31 . . .<br>
32<br>
33 /?MUX4X1 ? /<br>
34 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
35 i f ( chg [ a n d _ p o r t ] ) {<br>
36 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
37 __MY_asser t ( new [ R e s u l t a d o ] == 1 , "O r e s u l t a d o é d i f e r e n t e de 0 " ) ;<br>
38 }<br>
39 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
40 i f ( chg [ o r _ p o r t ] ) {<br>
41 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
42 }<br>
43 }<br>
44 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
45 i f ( chg [ x o r _ p o r t ] ) {<br>
46 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
47 }<br>
48 }<br>
49 }<br>
50<br>
51 /? End o f T r a n s l a t i o n ? /<br>
52 . . .<br>
Fonte: Própria.<br>
52<br>
5 CRONOGRAMA<br>
53<br>
6 CONSIDERAÇÕES PARCIAIS E<br>
TRABALHOS FUTUROS<br>
O trabalho aborda o desenvolvimento de um método para análise de circuitos lógicos de-<br>
scrito em VHDL através da aplicação de técnica de transformação de código e a técnica Bounded<br>
Model Cheking. Este método tem como objetivo de explorar os estados alcanç alcançáveis no<br>
circuito, e dessa forma identificar erros que possam resutar em mal funcionamento do sistema.<br>
Entre as dificuldade encontradas, a principal esta ligada a etapa de tradução de código.<br>
Devido a ferramenta utilizada inicialmente conter diversas limitações, a mesma diminui a eficácia<br>
da ferramenta, pois a quantidade de estruturas que podem ser utilizadas é limitada e com isso<br>
limitando também o processo de criação de protótipos.<br>
Os trabalhos futuros é necessário buscar uma nova ferramenta ou método de tradução<br>
que tenha uma gama maior de tradução, seja em estruturas ou palavras reservadas,deste forma<br>
o método desenvlvido torna-se mais eficiente e gerando uma menor intervenção do usuário no<br>
código VHDL. A melhoria na tradução de código também beneficia ageração das assertivas<br>
automáticamente, pois com uma gama maior de estruturas suportadas, mais assertivas podem ser<br>
geradas.<br>
Além disso a geração automática das assertivas é Outro ponto abordado, já sitado anterior-<br>
mente, é a geração automática das assertivas, visto que na estapa atual ainda nõ foi implementado.<br>
Este recuros visa da liberdade ao desenvolvedor promovendo de maneira automática os teste<br>
sobre o código, não necessitando que uma intervenção, tornando a inserção manual apenas em<br>
casos especificos de testes.<br>
54<br>
BIBLIOGRAPHY<br>
ABE, J. Introducao a Logica Para a Ciencia Da Computacao. Arte & Ciência, 2002. ISBN<br>
9788574730455. Disponível em: &lt;https://books.google.com.br/books?id=AgBJdjoNPwUC&gt;.<br>
ACM. 2018. Acessado em: 01 de março de 2018. Disponível em: &lt;http://dl.acm.org/&gt;.<br>
AHO, A. V.; SETHI, R.; ULLMAN, J. D. Compilers: principles, techniques, and tools. [S.l.]:<br>
Addison-wesley Reading, 2007. v. 2.<br>
ALLEN, F. E. Control flow analysis. In: ACM. ACM Sigplan Notices. [S.l.], 1970. v. 5, n. 7, p.<br>
1–19.<br>
BAIER, C.; KATOEN, J.-P.; LARSEN, K. G. Principles of model checking. [S.l.]: MIT press,<br>
2008.<br>
BARA, A. et al. Formal verification of timed vhdl programs. In: IET. FDL. [S.l.], 2010. p.<br>
80–85.<br>
BASILI, V. R.; CALDIERA, G.; ROMBACH, H. D. Experience factory. Encyclopedia of<br>
software engineering, Wiley Online Library, 1994.<br>
BENSALEM, S.; LAKHNECH, Y. Automatic generation of invariants. Formal Methods in<br>
System Design, Springer, v. 15, n. 1, p. 75–92, 1999.<br>
BIERE, A. The aiger and-inverter graph (aig) format. Available at http://fmv.jku.at/aiger, 2016.<br>
BIOLCHINI, J. et al. Systematic review in software engineering. System Engineering and<br>
Computer Science Department COPPE/UFRJ, Technical Report ES, v. 679, n. 05, p. 45, 2005.<br>
BOULE, M.; ZILIC, Z. Incorporating efficient assertion checkers into hardware emulation. In:<br>
IEEE. Computer Design: VLSI in Computers and Processors, 2005. ICCD 2005. Proceedings.<br>
2005 IEEE International Conference on. [S.l.], 2005. p. 221–228.<br>
BOULE, M.; ZILIC, Z. Efficient automata-based assertion-checker synthesis of seres for<br>
hardware emulation. In: IEEE COMPUTER SOCIETY. Proceedings of the 2007 Asia and South<br>
Pacific Design Automation Conference. [S.l.], 2007. p. 324–329.<br>
BRAYTON, R.; MISHCHENKO, A. Abc: An academic industrial-strength verification tool. In:<br>
SPRINGER. Computer Aided Verification. [S.l.], 2010. p. 24–40.<br>
B.V. 2018. Acessado em 1 de março de 2018. Disponível em: &lt;http://www.sciencedirect.com/&gt;.<br>
CABODI, G. et al. Hardware model checking competition 2014: an analysis and comparison of<br>
solvers and benchmarks. Journal on Satisfiability, Boolean Modeling and Computation, v. 9, p.<br>
135–172, 2016.<br>
CAPPELATTI, D. Praticando VHDL. Editora Feevale, 2010. ISBN 9788577171200. Disponível<br>
em: &lt;https://books.google.com.br/books?id=z4\_CYog\_UskC&gt;.<br>
Bibliography 55<br>
CHRISTEN, E.; BAKALAR, K. Vhdl-ams-a <span class='f1 c_9' id='c_9_1' href='#c_9_2' cs_f='.c_9' >hardware description language</span> for analog and<br>
mixed-signal applications. IEEE Transactions on Circuits and Systems II: Analog and Digital<br>
Signal Processing, IEEE, v. 46, n. 10, p. 1263–1272, 1999.<br>
CHU, P. P. RTL hardware design using VHDL: coding for efficiency, portability, and scalability.<br>
[S.l.]: John Wiley & Sons, 2006.<br>
CLARKE, E. et al. Verification of hybrid systems based on counterexample-guided abstraction<br>
refinement. In: SPRINGER. TACAS. [S.l.], 2003. v. 3, p. 192–207.<br>
CLARKE, E. M. The birth of model checking. In: 25 Years of Model Checking. [S.l.]: Springer,<br>
2008. p. 1–26.<br>
CLARKE, E. M.; GRUMBERG, O.; LONG, D. E. Model checking and abstraction. ACM<br>
transactions on Programming Languages and Systems (TOPLAS), ACM, v. 16, n. 5, p.<br>
1512–1542, 1994.<br>
CORDEIRO, L.; FISCHER, B.; MARQUES-SILVA, J. Smt-based bounded model checking for<br>
embedded ansi-c software. IEEE Transactions on Software Engineering, IEEE, v. 38, n. 4, p.<br>
957–974, 2012.<br>
COUSOT, P.; COUSOT, R. A gentle introduction to formal verification of computer systems by<br>
abstract interpretation. [S.l.]: IOS Press, 2010.<br>
DAHAN, A. et al. Combining system level modeling with assertion based verification. In: Sixth<br>
international symposium on quality electronic design (isqed’05). [S.l.: s.n.], 2005. p. 310–315.<br>
ISSN 1948-3287.<br>
D’SILVA, V.; KROENING, D.; WEISSENBACHER, G. A survey of automated techniques<br>
for formal software verification. IEEE Transactions on Computer-Aided Design of Integrated<br>
Circuits and Systems, IEEE, v. 27, n. 7, p. 1165–1178, 2008.<br>
ELSEVIER. 2017. Acessado em: 01 março 2018. Disponível<br>
em: &lt;https://www.elsevier.com/__data/assets/pdf_file/0007/69451/<br>
0597-Scopus-Content-Coverage-Guide-US-LETTER-v4-HI-singles-no-ticks.pdf&gt;.<br>
G1. Acidente foi provocado por falha em circuito eletrônico, diz se-<br>
cretário. 2012. Disponível em: &lt;http://g1.globo.com/sao-paulo/noticia/2012/05/<br>
acidente-foi-provocado-por-falha-em-circuito-eletronico-diz-secretario.html&gt;.<br>
GUGLIELMO, G. D. et al. On the use of assertions for embedded-software dynamic verification.<br>
In: IEEE. Design and Diagnostics of Electronic Circuits & Systems (DDECS), 2012 IEEE 15th<br>
International Symposium on. [S.l.], 2012. p. 330–335.<br>
GUPTA, A. Formal hardware verification methods: A survey. In: SPRINGER. Computer-Aided<br>
Verification. [S.l.], 1992. p. 5–92.<br>
HALDER, A.; VENKATESWARLU, A. A study of petri nets modeling analysis and simulation.<br>
Department of Aerospace Engineering Indian Institute of Technology Kharagpur, India, 2006.<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Interpolation and symbol elimination in vampire.<br>
Automated Reasoning, Springer, p. 188–195, 2010.<br>
Bibliography 56<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Case studies on invariant generation using a<br>
saturation theorem prover. Advances in Artificial Intelligence, Springer, p. 1–15, 2011.<br>
IDOETA, I. V.; CAPUANO, F. G. Elementos de eletrônica digital. [S.l.]: Livros Erica, 1982.<br>
IEC/IEEE International Standard - Behavioural languages - Part 1-1: VHDL Language<br>
Reference Manual. IEC 61691-1-1:2011(E) IEEE Std 1076-2008, p. 1–648, May 2011.<br>
IEEE. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http://ieeexplore.ieee.org/<br>
Xplore/home.jsp&gt;.<br>
IEEE Standard for Property Specification Language (PSL). IEEE Std 1850-2010 (Revision of<br>
IEEE Std 1850-2005), p. 1–182, April 2010.<br>
IEEE Standard for Verilog <span class='f1 c_9' id='c_9_1' href='#c_9_2' cs_f='.c_9' >Hardware Description Language</span>. IEEE Std 1364-2005 (Revision of<br>
IEEE Std 1364-2001), p. 1–560, 2006.<br>
KITCHENHAM, B. Procedures for performing systematic reviews. Keele, UK, Keele University,<br>
v. 33, n. 2004, p. 1–26, 2004.<br>
KITCHENHAM, B. et al. Systematic literature reviews in software engineering–a systematic<br>
literature review. Information and software technology, Elsevier, v. 51, n. 1, p. 7–15, 2009.<br>
KNOOP, J.; RÜTHING, O.; STEFFEN, B. Partial dead code elimination. [S.l.]: ACM, 1994.<br>
v. 29.<br>
KOSCIANSKI, A.; SOARES, M. dos S. Qualidade de Software - 2a Edição: Aprenda as<br>
metodologias e técnicas mais modernas <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >para o desenvolvimento</span> de software. Novatec,<br>
2007. ISBN 9788575221129. Disponível em: &lt;https://books.google.com.br/books?id=<br>
O9aWoUq6L88C&gt;.<br>
KROPF, T. Introduction to Formal Hardware Verification. Springer Berlin Heidelberg,<br>
2013. ISBN 9783662038093. Disponível em: &lt;https://books.google.com.br/books?id=<br>
7ImrCAAAQBAJ&gt;.<br>
MAFRA, S. N.; TRAVASSOS, G. H. Estudos primarios e secundarios apoiando a busca por<br>
evidencia em engenharia de software. Relatorio Tecnico, RT-ES, v. 687, n. 06, 2006.<br>
MUKHERJEE, R. et al. Unbounded safety verification for hardware using software analyzers.<br>
In: EDA CONSORTIUM. Proceedings of the 2016 Conference on Design, Automation & Test in<br>
Europe. [S.l.], 2016. p. 1152–1155.<br>
MUKHERJEE, R.; TAUTSCHNIG, M.; KROENING, D. v2c–a verilog to c translator. In:<br>
SPRINGER. International Conference on Tools and Algorithms for the Construction and<br>
Analysis of Systems. [S.l.], 2016. p. 580–586.<br>
MURATA, T. Petri nets: Properties, analysis and applications. Proceedings of the IEEE, IEEE,<br>
v. 77, n. 4, p. 541–580, 1989.<br>
RAMESH, U. B. K.; SENTILLES, S.; CRNKOVIC, I. Energy management in embedded<br>
systems: Towards a taxonomy. In: IEEE PRESS. Proceedings of the First International<br>
Workshop on Green and Sustainable Software. [S.l.], 2012. p. 41–44.<br>
ROCHA, H. et al. Exploiting safety properties in bounded model checking for test cases<br>
generation of c programs. 2010.<br>
Bibliography 57<br>
ROCHA, H. et al. Model checking embedded c software using k-induction and invariants<br>
(extended version). arXiv preprint arXiv:1509.02471, 2015.<br>
ROCHA, H. O. et al. Verificacao de sistemas de software baseada em transformacoes de codigo<br>
usando bounded model checking. Universidade Federal do Amazonas, 2015.<br>
SARGENT, R. G. Verification and validation of simulation models. In: WINTER SIMULATION<br>
CONFERENCE. Proceedings of the 37th conference on Winter simulation. [S.l.], 2005. p.<br>
130–143.<br>
SEGER, C.-J. An introduction to formal hardware verification. [S.l.]: University of British<br>
Columbia, Department of Computer Science, 1992.<br>
SOMMERVILLE, I. Engenharia de software. PEARSON BRASIL, 2011. ISBN 9788579361081.<br>
Disponível em: &lt;https://books.google.com.br/books?id=H4u5ygAACAAJ&gt;.<br>
SONS, J. W. . 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http:<br>
//onlinelibrary.wiley.com/&gt;.<br>
SOUZA, J. Lógica para Ciência da Computação. Elsevier Brasil, 2017. ISBN 9788535278255.<br>
Disponível em: &lt;https://books.google.com.br/books?id=Ds2sCQAAQBAJ&gt;.<br>
SPRINGER. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;https:<br>
//link.springer.com/&gt;.<br>
SRIKANT, Y.; SHANKAR, P. The Compiler Design Handbook: Optimizations and<br>
Machine Code Generation. CRC Press, 2002. ISBN 9781420040579. Disponível em:<br>
&lt;https://books.google.com.br/books?id=0K\_jIsgyNpoC&gt;.<br>
THOMAS, D.; MOORBY, P. The Verilog R© <span class='f1 c_9' id='c_9_1' href='#c_9_2' cs_f='.c_9' >Hardware Description Language</span>. Springer<br>
US, 2008. ISBN 9780387853444. Disponível em: &lt;https://books.google.com.br/books?id=<br>
DxQGrz7q-SwC&gt;.<br>
TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L. Sistemas digitais: princípios e aplicações. [S.l.]:<br>
Prentice Hall, 2003. v. 8.<br>
TRAVASSOS, G. H. et al. An environment to support large scale experimentation in software<br>
engineering. In: IEEE. Engineering of Complex Computer Systems, 2008. ICECCS 2008. 13th<br>
IEEE International Conference on. [S.l.], 2008. p</div>
<!-- DIVISOR_DIV_CANDIDATE -->

<div class='divisor divisor-texto' id="cand__file5"><hr class='text-separator'><br>Input file: <a href='#'>main.pdf</a> (12773 chunks)<br>File found: <a href='https://ufrr.br/pic/index.php/component/phocadownload/category/24-editais-pibic.html?download=508:resultado-preliminar-pibic-2017-2018' target='_blank'>https://ufrr.br/pic/index.php/component/phocadownload/category/24-editais-pibic.html?download=508:resultado-preliminar-pibic-2017-2018</a> (2710 chunks)<br><br>Chunks in common: 33<br>Similarity: 0.21%<br><br><div class='textInfo'>The following is the content of the document <br>&nbsp;"<b>main.pdf</b>". <br>The terms in red were found in the document <br>&nbsp;"<b>https://ufrr.br/pic/index.php/component/phocadownload/category/24-editais-pibic.html?download=508:resultado-preliminar-pibic-2017-2018</b>".<br><hr class='text-separator'></div>  <span class='f1 c_32' id='c_32_1' href='#c_32_2' cs_f='.c_32' >UNIVERSIDADE FEDERAL DE RORAIMA</span><br>
PRÓ-REITORIA DE ENSINO E EXTENSÃO<br>
DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação <span class='f1 c_11' id='c_11_1' href='#c_11_2' cs_f='.c_11' >formal de circuitos</span> lógicos baseado em transformação de código <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >com<br>
Bounded Model Checking</span><br>
<span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >Boa Vista - RR</span><br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação <span class='f1 c_11' id='c_11_1' href='#c_11_2' cs_f='.c_11' >formal de circuitos</span> lógicos baseado em transformação de código<br>
<span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >com Bounded Model Checking</span><br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
<span class='f1 c_6' id='c_6_1' href='#c_6_2' cs_f='.c_6' >da Universidade Federal de Roraima</span> como<br>
requisito parcial para a obtenção do grau<br>
de Bacharel em Ciência da Computação.<br>
Orientador: Dr. <span class='f1 c_10' id='c_10_1' href='#c_10_2' cs_f='.c_10' >Herbert Oliveira Rocha</span><br>
<span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >Boa Vista - RR</span><br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação <span class='f1 c_11' id='c_11_1' href='#c_11_2' cs_f='.c_11' >formal de circuitos</span> lógicos baseado em transformação de código <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >com<br>
Bounded Model Checking</span><br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
<span class='f1 c_6' id='c_6_1' href='#c_6_2' cs_f='.c_6' >da Universidade Federal de Roraima</span> como<br>
requisito parcial para a obtenção do grau de<br>
Bacharel em Ciência da Computação.<br>
Defendido em 06 de março de 2017 e<br>
aprovado pela seguinte banca examinadora:<br>
Prof. Dr. <span class='f1 c_10' id='c_10_1' href='#c_10_2' cs_f='.c_10' >Herbert Oliveira Rocha</span><br>
Orientador / Curso de Ciência da Computação -<br>
UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Fazer dedicatória<br>
ACKNOWLEDGEMENTS<br>
Fazer agradecimentos!!<br>
Procurar frase massa!!<br>
ABSTRACT<br>
Fazer resumo!!<br>
Palavras-chaves: ??<br>
ABSTRACT<br>
Fazer Abstract!!<br>
Key-words: ??<br>
LISTA DE FIGURAS<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog. . . . . . . . . . . . . . . . 15<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL. . . . . . . . . . . . . . . . . 16<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade. . . . . . . . . . . . . . . 17<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL. . . . . . . . . . . . . . . . 17<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1. . . . . . . . . . 18<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas. . . . . . . . . 18<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas. . . . . . . . . . 19<br>
Figure 8 – Arvore de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
Figure 9 – Rede de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL. . . . . . . . . . . . . . . . . 27<br>
Figure 11 – Trecho de código em VHDL representando porta AND. . . . . . . . . . . . 28<br>
Figure 12 – Trecho de código traduzido para linguagem C. . . . . . . . . . . . . . . . . 29<br>
Figure 13 – Exemplo de bloco basico de código. . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 14 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 15 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 31<br>
Figure 16 – Ciclo da ferramenta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR. . . . . . . 41<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR. . . . . . . . . . . . . . 42<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume(). . . . . . . . . . . 43<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19. . . . . . . . . . . . . . . 44<br>
Figure 22 – Macros das assertivas implementadas em linguagem C . . . . . . . . . . . . 45<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas. . . . . . . 47<br>
Figure 25 – Imagem de claims contendo assertivas. . . . . . . . . . . . . . . . . . . . . 48<br>
Figure 26 – Pseudocódigo da função de análise das claims. . . . . . . . . . . . . . . . . 49<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta. . . . . . . . . . . . . . 49<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C. . . . . . . . . . . . . 50<br>
Figure 23 – Código com assertivas traduzida para linguagem C . . . . . . . . . . . . . . 51<br>
LISTA DE TABELAS<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM . . . . . . . . . . . . . . . 33<br>
SUMÁRIO<br>
1 INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11<br>
1.1 Definição do problema . . . . . . . . . . . . . . . . . . . . . . . . . . . 12<br>
1.2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13<br>
1.3 Organização do trabalho . . . . . . . . . . . . . . . . . . . . . . . . . 14<br>
2 CONCEITOS E DEFINIÇÕES . . . . . . . . . . . . . . . . . . . . . . 15<br>
2.1 Linguagens de descrição de hardware . . . . . . . . . . . . . . . . . 15<br>
2.1.1 VHSIC Hardware Description Language - VHDL . . . . . . . . . . . . . 16<br>
2.1.2 Portas lógicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18<br>
2.2 Verificação de sistemas . . . . . . . . . . . . . . . . . . . . . . . . . . 19<br>
2.2.1 Diagrama de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.2 Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.3 <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >Bounded Model Checking</span> . . . . . . . . . . . . . . . . . . . . . . . . . . 21<br>
2.2.4 Redes de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22<br>
2.2.5 Verificação de hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
2.2.6 Verificação formal de software . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.7 Lógica proposicional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.8 Linguagem de especificação de propriedades . . . . . . . . . . . . . . 26<br>
2.2.9 Verificação baseada em assertivas . . . . . . . . . . . . . . . . . . . . 26<br>
2.2.10 Propriedades de segurança . . . . . . . . . . . . . . . . . . . . . . . . 27<br>
2.3 Técnicas de compiladores . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.1 Transformações de código . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2 Otimização de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2.1 Grafo Acliclico Direcional - GAD . . . . . . . . . . . . . . . . . . . . . . . . 29<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.3 Eliminção de código morto . . . . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.4 Análise do fluxo de dados . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
2.3.2.5 Gerador de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
3 TRABALHOS CORRELATOS . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1 Revisão sistemática . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1.1 Planejamento da Revisão Sistemática . . . . . . . . . . . . . . . . . . 33<br>
3.1.1.1 Procedimentos de Seleção e Critérios . . . . . . . . . . . . . . . . . . . . 35<br>
3.2 Revisão da literatura . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.1 V2c-A verilog to C translator . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.2 Unbounded safety verification for hardware using software analyzers . 37<br>
3.2.3 Formal verification of timed VHDL programs . . . . . . . . . . . . . . . 38<br>
3.2.4 On the use of assertions for embedded-software dynamic verification 38<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation . . 39<br>
4 MÉTODO PROPOSTO . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.1 Visão geral do método . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.2 Preprocessamento do VHDL e inserção de assertivas . . . . . . . 42<br>
4.3 Tradução de código VHDL para a linguagem C . . . . . . . . . . . . 43<br>
4.4 Instrumentação de código . . . . . . . . . . . . . . . . . . . . . . . . 45<br>
4.5 Verificação de assertivas usando Model Checker . . . . . . . . . . 46<br>
5 CRONOGRAMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52<br>
6 CONSIDERAÇÕES PARCIAIS E TRABALHOS FUTUROS . . . . . 53<br>
BIBLIOGRAPHY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54<br>
11<br>
1 INTRODUÇÃO<br>
A complexidade de sistemas computacionais cresce exponencialmente. Muitas compan- Exemplificar<br>
este<br>
cresci-<br>
mento.<br>
hias e organizações estão rotineiramente lidando com software que contém milhares de linhas<br>
de código, escritos por diferentes pessoas, que usam linguagens distintas, ferramentas, estilos e<br>
hardware projetados de diversas formas e combinações (HODER et al., 2011).<br>
No contexto de sistemas compostos de hardware e software, tem-se os sistemas embarca-<br>
dos (SE) que são dispositivos semicondutores com software integrados, os quais se conectam<br>
a outros dispositivos. Usualmente, o principal propósito dos SE é o controle e provimento de<br>
informações para uma função específica (RAMESH et al., 2012).<br>
Os SE são extremamente interativos com seu ambiente, operam geralmente em tempo real<br>
e estão disponíveis continuamente. No entanto, estes sistemas, por possuírem um curto espaço<br>
de tempo para a liberação do produto ao mercado, precisam ser desenvolvidos rapidamente e<br>
atingir um alto nível de qualidade, mas, devido a esta necessidade, os programadores podem<br>
cometer enganos durante a fase de desenvolvimento destes sistemas.<br>
Os SE têm se proliferado em partes consideráveis das atividades do nosso cotidiano,<br>
com a característica de possuir grande quantidade de complexidade e diversidade. Devido a esta<br>
complexidade, erros podem passar despercebidos, causando não apenas penalidades econômicas<br>
e/ou fracassos do produto no mercado, mas principalmente o risco de perda de vidas humanas<br>
(CABODI et al., 2016). Como, por exemplo, o acidente noticiado no (G1, 2012), no qual, de<br>
acordo com o secretário de transportes, uma falha na placa do circuito eletrônico responsável<br>
pelo controle de velocidade dos trens ocasionou a colisão entre duas composições na estação de<br>
metrô de São Paulo.<br>
Segundo ROCHA et al.2015b, para se obter um alto nível de qualidade no desenvolvi-<br>
mento dos sistemas de hardware e software, a execução desses sistemas deve ser controlada e da<br>
mesma forma deve-se buscar meios de garantir que as propriedades definidas sejam atingidas. Por<br>
exemplo, a partir do conhecimento prévio do modo de implementação de determinado hardware,<br>
é possível utilizá-lo de forma mais eficiente. Neste sentido, diversas estratégias de verificação e<br>
de teste estão sendo pesquisadas e aplicadas para garantir a qualidade do software e hardware<br>
(HODER et al., 2010; ROCHA et al., 2010; BRAYTON; MISHCHENKO, 2010; CORDEIRO et<br>
al., 2012; CABODI et al., 2016).<br>
Por este motivo, com o intuito de analisar e otimizar a descrição dos circuitos digitais,<br>
tem-se utilizado as linguagens de descrição de hardware (HDL). Estas se diferem das linguagens<br>
de programação por conseguirem gerar execuções não apenas sequenciais, como também con-<br>
correntes ou paralelas (CHU, 2006). Neste contexto, a VHSIC Hardware Description Language<br>
Chapter 1. INTRODUÇÃO 12<br>
(VHDL) é uma das linguagens de descrição de hardware mais utilizadas atualmente. A descrição<br>
em VHDL pode ser em vários níveis de abstração, sendo o mais alto o nível comportamen-<br>
tal que permite a descrição do circuito através de loops e processos, definido-o <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >na forma de</span><br>
algoritmo. Como características das linguagens de descrição, o VHDL permite declarações se-<br>
quenciais ou concorrentes onde as declarações continuam ativas e sua ordem torna-se irrelevante<br>
(CAPPELATTI, 2010).<br>
Aliada à linguagem de descrição de hardware, a verificação formal de sistemas computa-<br>
cionais tem desempenhado um papel importante para assegurar a previsibilidade e a confiabili-<br>
dade na concepção de aplicações críticas. E, para isso, tem-se utilizado a técnica denominada<br>
model checking, que é baseada em formalismos matemáticos para provar propriedades de pro-<br>
gramas reativos (BENSALEM; LAKHNECH, 1999). Esta técnica gera uma busca exaustiva no<br>
espaço de estados do modelo para determinar se uma dada propriedade é válida ou não (BAIER<br>
et al., 2008), tendo como principal razão para o seu sucesso o funcionamento completamente<br>
automático, ou seja, sem qualquer intervenção do usuário.<br>
Visando contribuir com a verificação de sistemas embarcados no âmbito de sistemas<br>
computacionais, o contexto deste trabalho está situado <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >no uso de</span> metodologias e técnicas de<br>
verificação formal para programas escritos em VHDL (BIERE, 2016), focando principalmente<br>
no <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >Bounded Model Checking</span> (CORDEIRO et al., 2012; ROCHA et al., 2015a). Este trabalho está<br>
interessado especificamente na parte de: verificação de modelos de hardware descritos em níveis<br>
de circuitos de bits na linguagem VHDL, via transformações de código para gerar modelos (com<br>
assertivas) já suportados por model checkers, como o ESBMC (CORDEIRO et al., 2012).<br>
Dessa forma, o trabalho almeja analisar as propriedades de alcançabilidade para a<br>
identificação de localizações de erro, bem como, assertivas contendo propriedades de segurança.<br>
A propriedade de alcançabilidade ou propriedade <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >do estado de</span> erro é satisfatória (SAT), se um<br>
estado de erro é alcançável. Caso contrário, a propriedade é considerada insatisfatória (UNSAT).<br>
No caso SAT, o model checking também gera um rastreio da validação da propriedade (contra-<br>
exemplo), ou seja, uma sequência de estados que mostra como chegar ao erro <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >a partir de</span> um<br>
ponto inicial.<br>
1.1 Definição do problema<br>
O avanço da tecnologia, principalmente nas áreas de design e fabricação de eletrônicos,<br>
aumentou a importância do hardware nos dias atuais. Cada vez com mais funcionalidades<br>
integradas, aliada a velocidade e circuitos menores, faz com que a complexidade dos sistemas<br>
de hardware aumente. Entretanto, devido à complexidade cada vez maior, a detecção tardia<br>
de erros no sistema pode resultar em perda de produção, mas também custos <span class='f1 c_1' id='c_1_1' href='#c_1_2' cs_f='.c_1' >associados ao<br>
desenvolvimento</span> do sistema(GUPTA, 1992). Devido a isso, a verificação de hardware visa<br>
assegurar que o circuito atinja as especificações para o qual foi projetado, através de técnicas<br>
Chapter 1. INTRODUÇÃO 13<br>
formais ou dinâmicas (BOULE; ZILIC, 2007).<br>
Por esta razão, a utilização de métodos formais tornou-se uma abordagem atraente<br>
para superar as limitações inerentes à validação baseada em simulação. Portanto, a maioria<br>
das empresas de semicondutores têm investigado a sua aplicabilidade. Escolhas individuais de<br>
métodos, ferramentas e áreas de aplicação das empresas têm variado, assim como o seu nível<br>
de sucesso (CABODI et al., 2016). Com os recentes avanços na escalabilidade de automação<br>
dos model checkers e nas equivalências sequenciais de verificação, a maioria das empresas têm<br>
crescido ao contar com essas técnicas(CLARKE, 2008).<br>
O problema considerado neste trabalho é expresso na seguinte questão: Como comple-<br>
mentar e aprimorar a verificação de propriedades de segurança em circuitos lógicos, de tal<br>
forma que uma propriedade possa ser mapeada em um problema de alcançabilidade sim-<br>
bólica, ou seja, se é possível alcançar um estado específico (para uma dada propriedade) a<br>
partir do estado inicial?<br>
1.2 Objetivos<br>
O objetivo principal deste trabalho é projetar e avaliar um método para efetuar verificação<br>
de circuitos, de forma automática, descritos em VHDL com portas lógicas em nível de bit<br>
pela utilização de técnicas de transformação de códigos combinado com a técnica <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >Bounded<br>
Model Checking</span> para exploração de estados alcançáveis no circuito, visando identificar erros ou<br>
comportamentos indevidos ou inesperados que podem resultar no funcionamento incorreto de<br>
um dado sistema.<br>
Os objetivos específicos são:<br>
1. Propor um método para especificar pré e pós-condições de circuitos digitais em nível de<br>
portas lógicas descritos em VHDL;<br>
2. Analisar ferramentas de verificação de modelos que utilizam a técnica <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >Bounded Model<br>
Checking</span>;<br>
3. Especificar uma técnica de conversão de circuitos em linguagem de descrição de hardware<br>
VHDL para um modelo a ser verificado usando a técnica <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >Bounded Model Checking</span>;<br>
4. Desenvolver um método para identificação de estados de erros ou ocorrências indevidas,<br>
de um dado circuito analisado, em modelos de hardware descritos em nível de bit na<br>
linguagem de descrição VHDL.<br>
5. Validar a aplicação do método proposto sobre benchmarks públicos de programas em<br>
VHDL, a fim de examinar a sua eficácia e aplicabilidade.<br>
Chapter 1. INTRODUÇÃO 14<br>
1.3 Organização do trabalho<br>
A introdução deste trabalho apresentou: o contexto, definição do problema, e objetivos<br>
deste trabalho. Os próximos capítulos estão organizados da seguinte forma:<br>
No Capítulo 2 Conceitos e Definições, são apresentados os conceitos abordados neste<br>
trabalho, especificamente: Linguagens de descrição de hardware; Verificação e validação de<br>
sistemas; e Técnicas de compiladores.<br>
No Capítulo 3 Trabalhos Correlatos, serão apresentados o método de pesquisa bibli-<br>
ográfica utilizado, sendo ele a revisão sistemática, seguido do resultado encontrado com esta<br>
pesquisa e, por fim, a contribuição dos artigos utilizados no desenvolvimento do projeto.<br>
No Capítulo 4 Método Proposto, são descritas as etapas de execução do novo método<br>
proposto que consiste na transformação do código, instrumentação de assertivas e verificação de<br>
código utilizando um model checker.<br>
No Capítulo 5, será apresentado o cronograma de atividades a ser realizado na elaboração<br>
do método durante o desenvolvimento do projeto.<br>
E, por fim, no Capítulo 6 Considerações parciais e trabalhos futuros, serão apresentas<br>
as considerações parciais e as sugestões de trabalhos futuros que podem ser desenvolvidos.<br>
15<br>
2 CONCEITOS E DEFINIÇÕES<br>
Este capítulo tem apresenta os principais conceitos e definições abordados neste tra-<br>
balho, tais como: Linguagens de descrição de hardware, Verificação de sistemas e Técnicas de<br>
Compiladores.<br>
2.1 Linguagens de descrição de hardware<br>
As linguagens de descrição de hardware (HDL) foram desenvolvidas com o intuito de<br>
auxiliar a criação de circuitos lógicos com grande número de elementos e com uma gama de<br>
abstrações lógicas e eletrônicas (THOMAS; MOORBY, 2008). Entre os exemplos, podemos<br>
citar: VDHL (IEC/IEEE. . . , 2011), Verilog (IEEE. . . , 2006) e SystemC (??).<br>
Segundo CHRISTEN; BAKALAR,1999, linguagens de descrição de hardware são lingua-<br>
gens de programação utilizadas com o intuito de descrever o comportamento de um determinado<br>
circuito, técnica conhecida como modelagem. Os modelos descritos em HDL são utilizados<br>
como entrada para um simulador, onde o mesmo pode ter seu comportamento analisado.<br>
As HDL’s trazem consigo diversas vantagens, entre elas códigos independentes de tec-<br>
nologia e fabricante, podendo ser portáteis e reutilizáveis (CAPPELATTI, 2010). As linguagens<br>
mais modernas, tais como VHDL e Verilog, possuem suporte tanto a descrição do circuito pro-<br>
priamente dito, quanto ao comportamento que o mesmo deve exercer (CHRISTEN; BAKALAR,<br>
1999).<br>
A Verilog, como já citado, é uma linguagem de descrição de hardware que fornece<br>
diversos níveis de abstração para desenvolvimento de sistemas digitais(THOMAS; MOORBY,<br>
2008). A linguagem foi desenvolvida para ser simples e efetiva nos diversos níveis de abstração<br>
incluindo o <span class='f1 c_3' id='c_3_1' href='#c_3_2' cs_f='.c_3' >suporte ao desenvolvimento</span>, verificação, síntese e testes de software (IEEE. . . , 2006).<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog.<br>
1 p r i m i t i v e m u l t i p l e x e r ( mux , c o n t r o l , dataA , da taB ) ;<br>
2 o u t p u t mux ;<br>
3 i n p u t c o n t r o l , dataA , da taB ;<br>
4 e n d p r i m i t i v e<br>
Fonte: Adaptado de (IEEE. . . , 2006).<br>
Na Figura 1 apresenta um exemplo de multiplexador descrito em Verilog utilizando a<br>
estrutura de modelagem, chamada UDP que permite a criação de novos primitivas para serem<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 16<br>
utilizada. Apresenta uma saída apenas(mux) e três entradas sendo uma de controle(control) e<br>
duas de dados(dataA e dataB).<br>
A VHDL é uma linguagem de descrição de hardware amplamente utilizada, concebida<br>
na década de 80, devido uma necessidade do Departamento de Defesa dos Estados Unidos<br>
da América (CAPPELATTI, 2010). Assim como a Verilog, esta linguagem também suporta o<br>
desenvolvimento, a verificação, a síntese, e os testes de hardware (IEC/IEEE. . . , 2011).<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL.<br>
1 l i b r a r y IEEE ;<br>
2 use IEEE . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 use IEEE . s t d _ l o g i c _ u n s i g n e d . a l l ;<br>
4 e n t i t y mux2x1 i s<br>
5 p o r t ( s e l : i n STD_LOGIC ;<br>
6 a , b : i n STD_LOGIC ;<br>
7 y : o u t STD_LOGIC ) ;<br>
8 end mux2x1 ;<br>
9<br>
10 a r c h i t e c t u r e d a t a f l o w of mux2x1 i s b e g i n<br>
11 y &lt;= ( a AND NOT s e l ) OR ( b AND s e l ) ;<br>
12 end d a t a f l o w .<br>
Fonte: (CAPPELATTI, 2010).<br>
Na Figura 2 está descrito um multiplexador de duas entradas descrito em VHDL, apre-<br>
sentando na parte inicial as bibliotecas e na entidade(entity) a declaração das variáveis utilizadas.<br>
Na arquitetura(architecture) apresenta o funcionamento do multiplexador, relacionando en-<br>
tradas e saídas conforme tenham sido declarados. Este conceitos serão melhor apresentados na<br>
subsection 2.1.1.<br>
Conforme apresentado nas Figura 1 e Figura 2, ambas as linguagens apresentam difer-<br>
enças no modelos de declaração e utilização para descrição de hardware. Para este trabalho foi<br>
escolhido a VHDL devido a linguagem apresentar um melhor escopo para análise, facilitando o<br>
trabalho de análise proposto para este projeto.<br>
2.1.1 VHSIC Hardware Description Language - VHDL<br>
Revisar textos e verificar a necessidade de mais exemplo<br>
VHDL é uma linguagem de descrição de hardware destinada a ser utilizada em todas<br>
as etapas da criação de sistemas eletrônicos, sendo elas: desenvolvimento; verificação; síntese;<br>
e, teste de circuitos (IEC/IEEE. . . , 2011). Segundo (CAPPELATTI, 2010), a VHDL apresenta<br>
três principais pilares: abstração, que consiste na descrição com diferentes níveis de detalhes;<br>
modularidade, que permite a divisão do projeto em vários blocos ou módulos para posterior<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 17<br>
interconexão; e hierarquia, permite que módulos possam ser compostos por submódulos e, os<br>
mesmos tenham níveis de abstração diferentes, dependendo da necessidade do projeto. Devido a<br>
esta versatilidade que a linguagem VHDL foi selecionada para o trabalho proposto.<br>
Segundo IEC/IEEE. . . ,2011, é necessário um padrão para formatação da descrição em<br>
VHDL: Entity (Pinos de entrada/saída) e Architecture (Arquitetura). A Entity ou entidade repre-<br>
senta o bloco onde são declaradas as entradas e as saídas do circuito utilizadas em todo o sistema,<br>
conforme apresentado na Figura 3. A Architecture ou arquitetura, apresentado na Figura 4, define<br>
a relação entre entradas e saídas declaradas na entidade, podendo tais especificações serem<br>
completas ou parciais. Assim como em outras linguagens, bibliotecas podem ser adicionadas,<br>
para que novas funções e atributos possam ser utilizados no projeto.<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade.<br>
1 l i b r a r y i e e e ;<br>
2 use IEEE . STD_LOGIC_1164 . ALL<br>
3<br>
4 ENTITY f u l l _ a d d e r IS PORT(<br>
5 x1 , x2 , c i n : i n s t d _ l o g i c ;<br>
6 S , c o u n t : o u t s t d _ l o g i c ) ;<br>
7 END f u l l _ a d d e r ;<br>
Fonte: Própria.<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL.<br>
1 ARCHITECTURE b e h a v i o r a l OF f u l l _ a d d e r IS<br>
2 BEGIN<br>
3 s &lt;=x1 XOR x2 XOR c i n ;<br>
4 cout &lt;=( x1 AND x2 ) OR ( x1 AND c i n ) OR ( b<br>
AND c i n ) ;<br>
5 END b e h a v i o r a l ;<br>
Fonte: Própria.<br>
Segundo CAPPELATTI,2010 uma descrição em VHDL pode conter diferentes níveis de<br>
abstração:<br>
• Comportamental: Permite descrever o circuito através de laços e processos. O circuito<br>
é definido em forma de um algoritmo, utilizando construção similares as utilizadas em<br>
linguagem de programação.<br>
• Transferência de registradores: Englobando a representação do dispositivo em nível de<br>
transferência entre registradores, que consiste na utilização de funções lógicas combina-<br>
cionais e de registradores.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 18<br>
• Estrutural: O circuito é descrito mais próximo da implementação real, podendo ser<br>
definidas portas lógicas com atrasos unitários ou com atrasos detalhados.<br>
2.1.2 Portas lógicas<br>
Segundo (IDOETA; CAPUANO, 1982), o conceito de portas lógicas é baseado na<br>
conhecida álgebra de Boole ou álgebra booleana, desenvolvida pelo matemático inglês George<br>
Boole em 1854. A álgebra booleana é representada por apenas dois valores, sendo eles o 0 e 1 e,<br>
através disso, expressa a relação entre entrada e saída dentro de um circuito. As portas lógicas<br>
podem ser construídas <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >a partir de</span> diodos, transistores e resistores interconectados de modo que a<br>
saída seja o resultante de uma operação lógica básica realizada sobre as entradas (TOCCI et al.,<br>
2003). A Figura 5 apresenta um exemplo de álgebra booleana sem a utilização de diagramas.<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1.<br>
Fonte: (TOCCI et al., 2003)<br>
Ainda segundo TOCCI et al.,2003, devido a esta característica, a álgebra booleana possui<br>
três operações básicas, OR (ou), AND (e) e NOT (não). Tal conjunto de operações também é<br>
denominado de operações booleanas e, por meio da utilização de tabelas verdade é possível<br>
descrever as saídas baseando-se nas entradas e na operação aplicada. Cada operação booleana<br>
possui sua tabela verdade ( Figura 6), bem como sua representação em forma de diagrama.<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas.<br>
Fonte: (TOCCI et al., 2003)<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 19<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas.<br>
Fonte: (TOCCI et al., 2003)<br>
A Figura 7 apresenta um circuito lógico formado pelas portas básicas da álgebra booleana.<br>
O circuito apresenta três entradas representadas pelas letras A, B e C, mas também formada<br>
por duas portas AND, uma porta NOT e uma porta OR. Cada uma destas portas representando<br>
operações a serem realizadas, podendo receber como entrada um valor inicial ou resultante de<br>
outra porta, como no exemplo ocorre com a última porta AND.<br>
Entetanto, segundo (KROPF, 2013), a análise de circuitos é extremamente complexa,<br>
resultando em um problema NP-Completo, algoritmos possuem tempo de execução exponencial.<br>
Contudo, este tempo de execução exponencial é uma complexidade exponencial para o pior caso,<br>
resultando crescimento exponencial da execução a medida que o tamanho do problema aumenta.<br>
Ainda, segundo (KROPF, 2013) a avaliação das funções booleanas podem ser ver-<br>
dadeiras(True) ou falso(False), com isso, para um função com n variáveis, apresenta 2n possibili-<br>
dades de avaliação. Utilizando o exemplo da Figura 7 que apresenta 3 entradas, logo apresenta 8<br>
possibilidade de avaliação ao final e este número aumenta à medida que o número de variáveis<br>
tambe aumenta<br>
2.2 Verificação de sistemas<br>
No contexto de verificação de sistemas, faz-se necessário a diferenciação entre verificação<br>
e validação. Verificação e validação possuem o intuíto de mostrar que determinado sistema fun-<br>
cione conforme o especificado, além de satisfazer as especificações do cliente (SOMMERVILLE,<br>
2011).<br>
Segundo (SARGENT, 2005), verificação é o processo de determinar se um modelo<br>
computacional obtido por discretização de um modelo matemático de um evento físico e o<br>
código que implementa o modelo computacional pode ser usado para representar o modelo<br>
matemático do evento com precisão suficiente e validação é o processo de determinar se um<br>
modelo matemático de um evento físico representa o evento físico real com precisão suficiente.<br>
A verificação consite identificação de erros e provavéis problemas que um componente<br>
pronto possa apresentar, enquanto a validação busca analisar se tal componete esta seguindo<br>
os requisitos pré-definidos para sua construção (KOSCIANSKI; SOARES, 2007). O teste de<br>
programa, na qual o software é executado com dados de teste é a principal forma de validação,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 20<br>
porém, tecnicas de verificação, tais como, inspeção e revisões também podem integrar a etapa de<br>
validação (SOMMERVILLE, 2011).<br>
2.2.1 Diagrama de decisão binária<br>
Um diagrama de decisão binária(DDB) pode ser definido como um grafo aciclico para<br>
representação de funcões boolenas. Existe uma ordem rigorosa na ocorrência de variáveis à me-<br>
dida que se percorre o grafo da raiz para a folha. Dado como exemplo a formula f=(a?b)?(c?d)<br>
e utilizando a ordenação de variavél a &lt; b &lt; c &lt; d, na Figura 8. Dada a atribuição de valores<br>
booleanos as variaveis a, b, c e d, pode-se decidir se a atribuição torna a fórmula verdadeira<br>
atravessando o início do gráfico na raiz e ramificação em cada nó. Definindo a, c e d = 1 e c = 0<br>
leva a folha de rótulo 1, portanto, a fórmula é verdadeira para essa tarefa (CLARKE et al., 1994).<br>
Figure 8 – Arvore de decisão binária<br>
Fonte: (CLARKE et al., 1994)<br>
Adicionar mais detalhes e descrever onde DDB é utilizado.<br>
O DDB permite o teste eficiente de satisfabilidade, validade e eficiência (KROPF, 2013).<br>
O uso e DDB em conjunto com Model Checking e técnicas de abstração permitiu o aumento na<br>
capacidade de verificação, de modo que sistemas mais realistas podessem ser verificados(??)<br>
2.2.2 Model Checking<br>
Model checking é uma técnica de verificação formal que explora todos os possíveis<br>
estados do sistema, de modo a provar se um modelo satisfaz determinada propriedade. Pode ser<br>
aplicada em uma ampla gama de aplicações, tais como sistema embarcados, design de hardware<br>
e engenharia de software (BAIER et al., 2008).<br>
Entre as vantagens da utilização de Model Checking estão:<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 21<br>
• Possuem suporte a verificação parcial, em outras palavras, a verificação individual de<br>
propriedades, permitido foco primeiro as propriedades essenciais(BAIER et al., 2008).<br>
• Não requer qualquer interação do usuário, nem um alto grau de especialização para <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >o uso<br>
de</span> model checking(BAIER et al., 2008).<br>
• Possui como base a teoria de grafos, estruturas de dados e lógica no desenvolvimento da<br>
solução(BAIER et al., 2008).<br>
• Útil para fins de depuração, pois formece informações em caso de uma propriedade seja<br>
invalidada(BAIER et al., 2008).<br>
Por outro lado, apresenta também algumas desvantagens:<br>
• Sofre do problema de explosão de espaço de estados, ou seja, a quantidade de estados<br>
necessários pode ser maior que a memória disponivel pelo sistema(BAIER et al., 2008).<br>
• Faz a verificação apenas dos requisios declarados, logo, não a garantia de integridade.<br>
Baseado nisso, a validade de propriedades não verificadas não pode ser julgada(BAIER et<br>
al., 2008).<br>
• A verificação de modelos geralmente não é computável, isso deve-se a questões de decidi-<br>
bilidade utilizada (BAIER et al., 2008).<br>
Outras técnicas foram implementadas em conjuntos com Model checkings com o intuito<br>
de aumentas a capacidade de verificação, como a técnica SAT na qual não sofre do problema de<br>
explosão de estados existente usando DDB. A técnica SAT em conjuto com Model Checking é<br>
conhecida como <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >Bounded Model Checking</span> (??).<br>
2.2.3 <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >Bounded Model Checking</span><br>
Segundo ROCHA et al., <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >Bounded Model Checking</span> (BMC) é um tipo especial de Model<br>
Checking que usualmente adota o método de satisfabilidade booleana, o qual tem sido introduzido<br>
como uma técnica complementar para diagrama de decisão binaria para aliviar o problema da<br>
explosão de estados, visto que a técnica de Model Checking busca todos os estados possíveis<br>
para verificação.<br>
<span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >Bounded Model Checking</span> é uma técnica para a verificação de uma dada propriedade<br>
em uma determinada profundidade do sistema analisado. Logo, dado um sistema de transições<br>
M, uma propriedade ?, e um limite (bound) k, o BMC desenrola o sistema k vezes e traduz o<br>
sistema em uma condição de verificação(CV) ? tal que ? é satisfeito se e somente se ? tem um<br>
contra-exemplo de profundidade menor ou igual a k (ROCHA et al., 2015b).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 22<br>
O Extended SMT-Based Bounded Model Checker (ESBMC) é um <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >Bounded Model<br>
Checking</span> baseado em satisfabilidade booleana (SAT) que permite verificação aritmética de Já tem<br>
su-<br>
porte<br>
a<br>
SMT<br>
adi-<br>
cionar<br>
ao<br>
texto<br>
overflow e undeflow, segurança de ponteiros, limite de array, de gerar propriedades de segurança<br>
em programas em C/C++. ESBMC utiliza uma versão modificada do CBMC no front-end para<br>
analisar o código ANSI-C e para gerar as condições de verificação através de execução simbólica<br>
(CORDEIRO et al., 2012; ROCHA et al., 2015b).<br>
No ESBMC, o programa analisado é modelado em um sistema de transição de estados,<br>
conforme a trupla: M = (S,R, S0), o qual é gerado um grafo <span class='f1 c_16' id='c_16_1' href='#c_16_2' cs_f='.c_16' >de controle de</span> fluxo (GFC), onde<br>
S representa o conjunto de estados, R ? SxS representa as transições e S ? S representa<br>
o conjuto de estados iniciais. Um estado s ? S consiste no valor do contador de programa<br>
(PC) e os valores de todas as variáveis dos programas. O estado inicial S0 atribui o inicio do<br>
programa GFC ao PC, desta forma o ESBMC identifica as transições, conforme a formula lógica,<br>
?=(Si,Si+1) que captura as retrições sobre os valores correspondntes do PC e das variáveis do<br>
programa (CORDEIRO et al., 2012).<br>
Segundo o site do ESBMC(??), a ferramenta permite ao usuário indicar propriedades<br>
adicionaisusando assertivas que também são verificadas. O ESBMC converte as condições Descrever<br>
quais<br>
pro-<br>
priedades<br>
o<br>
esbmc<br>
su-<br>
porta<br>
usando diferentes técnicas de backgroundpara posteriormente passar para verificador SMT. Outra<br>
apresentar<br>
exem-<br>
plo<br>
vantagem é a ferramenta permitir verificação de software single-thread e multi-thread.<br>
Descrever qual a razão da escolha para o trabalho, apresentar resultados do SV-COMP<br>
dos últimos 3 anos<br>
2.2.4 Redes de petri<br>
Apresentar definição formal para RP<br>
corrigir o texto abaixo RP não é uma ferramenta e sim um método de modelagem<br>
Redes de petri são utilizadas como ferramentas de modelagem gráfica com propriedades<br>
matemática. Como ferramenta gráfica são utilizadas como comunicação visual, como fluxogra-<br>
mas, por exemplo, e como ferramenta matemática podem configurar modelos matemáticos que<br>
regem o comportamento dos sistemas. A grade premissa desta ferramenta é descrever sistemas<br>
de processamento de informações caracterizados como concorrentes, assíncronos, distribuídos,<br>
paralelos, não deterministas e/ou estocásticos (MURATA, 1989).<br>
As redes de petri são representados como grafos direcionais compostos por nós e arcos,<br>
conforme apresentado na Figura 9. Os nós representam as transições e eventos e os arcos<br>
representam os pesos. Dentro desta representação, os arcos e eventos são componentes passivos<br>
enquanto as transições são ativos. A principal vantagem da utilização das redes de petri esta<br>
relacionado ao chamado "Token game" que consiste no comportamento da rede de petri, em<br>
outras palavras, representa o funcionamento do sistema representado pela rede(HALDER;<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 23<br>
VENKATESWARLU, 2006).<br>
Figure 9 – Rede de petri<br>
Fonte: (HALDER; VENKATESWARLU, 2006)<br>
Descrever o funcionamento da RP apresentado na IMG<br>
Descrever quais propriedades podem ser verificadas com RP e onde será utilizado no seu<br>
trabalho.<br>
2.2.5 Verificação de hardware<br>
Para a verificação de hardware diversas técnicas têm sido propostas (). Por meio da Apresentar<br>
exem-<br>
plos<br>
com<br>
refer-<br>
ências<br>
simulação, visa assegurar que uma implemetação, descrição do hardware em qualquer qualquer<br>
nível de abstração da hierarquia de hardware, atinja suas especificações, propriedades que devem<br>
ser respeitadas para que a corretude do mesmo seja comprovada (GUPTA, 1992). A Verificação<br>
formal de hardware consiste na utilização de técnicas para corretude de circuitos lógicos, ou<br>
seja, consiste na utilização de modelos matemáticos para descrição de propriedade e/ou de<br>
comportamento de um dado sistema (KROPF, 2013).<br>
Entre as abordagens utilizadas na verificação formal de hardware consiste tanto na imple-<br>
mentação quanto a especificação estarem descritas em lógica formal, neste caso a corretude será<br>
obtida através da comprovada relação entre a implementação e a especificação (SEGER, 1992).<br>
A especificação formal consiste na descrição do comportamento, bem como, das propriedades<br>
do sistema em linguagem matemática, tornando-se crucial para o processo de verificação. Na<br>
implementação formal, o nível de abstração, tais como, Gate level e RTL são importantes infor-<br>
mações <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento</span> do formalismo, bem como as classes, por exemplo se o circuito<br>
é sequencial ou combinacional, se utiliza pipeline, etc (KROPF, 2013).<br>
Apresentar um exemplo de RTL<br>
A utilização de Model Checking também se faz presente nos modelos formais de ver-<br>
ificação de hardware, onde apenas é utilizado o comportamento dos circuitos na verificação,<br>
de modo a verificar a se as propriedades presentes são satisfeitas. Para isso, são utilizados os<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 24<br>
conceitos da lógica proposicional, que por meio da utilização de fórmulas que representem as<br>
propriedades dos estados, é possível realizar as verificações necessárias (SEGER, 1992).<br>
Apresentar um exemplo com um circuito e como este pode ser verificando com model<br>
checking<br>
2.2.6 Verificação formal de software<br>
Observa-se que <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >o uso de</span> verificacão de software tem sido feito aplicado em muitas áreas,<br>
tais como, infraestruturas industriais de missão critica e de segurança. Logo, existe a necessidade<br>
de garantir a corretude destes sistemas. Devido a isso, a verificação formal tem sido utilizada em<br>
três principais abordagens, sendo elas (COUSOT; COUSOT, 2010; D’SILVA et al., 2008):<br>
Apresentar exemplos para os métodos apresentados abaixo<br>
• Métodos dedutivos: Produzem provas matemáticas formais de corretude usando provadores<br>
de teoremas ou assistentes de prova para execução da prova e necessitam da interação<br>
humana para prover os argumentos (COUSOT; COUSOT, 2010);<br>
• Verificação de modelos: Exploram exaustivamente modelos de execuções de programa,<br>
que podem ser sujeitos a explosão combinatória, necessário a intervenção humana para<br>
geração dos modelos (ROCHA et al., 2015b);<br>
• Analise estática: Engloba diversas técnicas para calcular automaticamente informações<br>
sobre o comportamento de um programa sem executá-lo, sendo utilizado em otimização<br>
de código e verificação em compiladres (D’SILVA et al., 2008).<br>
Segundo ROCHA et al., na verificação formal de software apresentam-se dificuldades,<br>
tais como: quais as propriedades são de interesse na verificação em tempo de execução; e<br>
impossibilidade matemática de provar a corretude de propriedades não triviais no comportamento<br>
de programas (COUSOT; COUSOT, 2010).<br>
2.2.7 Lógica proposicional<br>
A lógica proposicional é uma linguagem formal onde é definida um alfabeto e conectivos<br>
proposicionais, e um conjunto de regras gramaticais, as quais serão utilizadas para construção<br>
das proposições (SOUZA, 2017). Porém apesar de importante, ela é limitada, não podendo<br>
expressar sentenças elementares importantes, tais como a da aritmética elementar. Por exemplo:<br>
1. Todos são mortais.<br>
2. Alguém é bondoso.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 25<br>
Na lógica preposicional, não poderiam ser analisadas, pois não teria como decompor<br>
ambas em sentença e assim não teria como analisar as diferenças entre ambas(ABE, 2002).<br>
Contudo, no exemplo: Existem cavalos com patas verdes. A relação criada pela frase poderia a<br>
ser analisada pela lógica proposicional(ABE, 2002). Descrever<br>
como<br>
seria<br>
está<br>
analise<br>
Segundo SOUZA, alfabeto da lógica proposicional é formado por símbolo de pontuação,<br>
símbolos proposicionais e conectivos proposicionais, onde cada um apresenta uma função em<br>
específico, sendo:<br>
• Símbolos de pontuação: Apenas dois símbolos de pontuação são utilizados o "(" e o ")".<br>
• Símbolos proposicionais: São utilizados para representar as proposições, onde um sím-<br>
bolo P pode ser utilizado para representar uma proposição qualquer, por exemplo: P="Está<br>
chovendo". O conjunto de símbolos proposicionais é infinito e enumerável, sendo possível<br>
representar infinitos e enumerável conjunto de proposições.<br>
• Conectivos proposicionais: São os símbolos usando frequentemente na matemática. Os<br>
símbolos recebem a seguinte denominação:<br>
1. ¬: Representa a partícula de negação, ou seja, "Não".<br>
2. ?: Representa a partícula "Ou"<br>
3. ?: Representa a partícula "E"<br>
4. ?: Representa a partícula "Se então ou implica".<br>
5. ?: Representa a partícula "Se, e somente se".<br>
Ainda segundo SOUZA, existem as fórmulas que são constituídas de forma indutiva, <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >a<br>
partir de</span> símbolos do alfabeto conforme as regras apresentadas abaixo:<br>
• Todo o símbolo preposicional é uma fórmula<br>
• Se H é uma fórmula, então (¬H), a negação de H, é uma fórmula.<br>
• Se H e G são fórmulas, então a disjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a conjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o antecedente e G consequente da fórmula.<br>
• Se H e G são fórmulas, então a bi-implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o lado esquerdo e G o lado direito da fórmula.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 26<br>
2.2.8 Linguagem de especificação de propriedades<br>
Linguagem de especificação de propriedades, do inglês Property Specification Language<br>
- PSL, é uma notação formal para especificação de comportamento em sistemas eletrônicos,<br>
compatível com as linguagens VHDL, Verilog, SystemC e SystemVerilog. Destina-se a utilização Adicionar<br>
refer-<br>
ência<br>
a cada<br>
Ling<br>
citada<br>
para a especificação funcional, mas também para entrada de ferramentas de verificação. A<br>
especificação do PSL é a utilização de assertivas sobre propriedades de um sistema, sendo estas<br>
propriedades constituídas de três elementos: expressões boolenas, expressões sequenciais e<br>
operadores temporais (IEEE. . . , 2010).<br>
Corrigir a apresentação da citação IEEE... estranho<br>
Segundo (IEEE. . . , 2010), o PSL foi totalmente desenvolvida com o intuito fornecer<br>
leitura e escrita de fácil entendimento, sintaxe concisa, semântica formal e rigorosamente bem<br>
definida e ser matematicamente precisa, visto a utilização da mesma em processo de verificação.<br>
O PSL pode ser utilizado para capturar requisitos relativos ao comportamento total do projeto,<br>
bem como, sobre o modo que o mesmo deverá operar no ambiente, ms também para capturar<br>
requisitos comportamentais e os pressupostos que surgem durante o processo de design. Ambas<br>
podem ser utilizadas para verificação de sistemas.<br>
Apresentar exemplos de uso da PSL<br>
2.2.9 Verificação baseada em assertivas<br>
Verificação baseada em assertivas, do inglês Assertion-Based Verification - ABV, é um<br>
paradigma de verificação igualente adequado para verificação formal e abordagens baseadas em<br>
simulação (BOULE; ZILIC, 2005) e em conjunto com a tecnica de PSL tem ganhado aceitação<br>
como um método essencial para verificação funcional do hardware (DAHAN et al., 2005).<br>
Na ABV as assertivas são declaração adicionadas ao projeto com o intuito de especificar<br>
o comportamento do projeto (BOULE; ZILIC, 2005), podendo escritos em PSL ou em SVA<br>
(System Verilog Assertions). No caso deste projeto será utilizado a PSL, devido a mesma ser<br>
utilizada juntamente com a linguagem VHDL.<br>
Com a utilização de ABV o circuito pode ser verificado usando técnicas de simulação<br>
e/ou verificação, por exemplo, model checking, para garantir que o mesmo esteja de acordo<br>
com o pretendido projeto (DAHAN et al., 2005). Na Figura 19 apresenta o modelo de assertiva<br>
utilizada no projeto, utilizando de um modelo próprio para assertivas, unindo as funcionalidades<br>
já existentes nas assertivas do VHDL, mas também novas (serão apresentadas nas próximas<br>
seções), fornecendo assim mais propriedades a serem analisadas.<br>
Descrever qual o objetivo da assert apresentado<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 27<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 e n t i t y AND_ent i s<br>
5 p o r t ( x , y : i n b i t ;<br>
6 F : o u t b i t<br>
7 ) ;<br>
8 end AND_ent ;<br>
9<br>
10 a r c h i t e c t u r e behav1 of AND_ent i s<br>
11 b e g i n<br>
12 ??@c2vhdl : ASSERT<br>
13 ??a s s e r t n o t ( x= ’ 0 ’ and y= ’ 1 ’ )<br>
14 ?? r e p o r t " Both v a l u e s o f s i g n a l s x and y a r e e q u a l t o 1 "<br>
15 ??s e v e r i t y ERROR;<br>
16 ??@c2vhdl :END<br>
17<br>
18 p r o c e s s ( x , y )<br>
19 b e g i n<br>
20 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
21 F &lt;= ’ 1 ’ ;<br>
22 e l s e<br>
23 F &lt;= ’ 0 ’ ;<br>
24 end i f ;<br>
25 end p r o c e s s ; 4<br>
26 end behav1 ;<br>
Fonte: Própria.<br>
2.2.10 Propriedades de segurança<br>
Propriedades de segurança é um meio de validação do comportamento de um determinado<br>
sistema, de modo que se uma dada propriedade de segurança for violada, então através de<br>
uma execução finita, é possível verificar tal erro. Algumas propriedades de segurança, no<br>
entanto, podem impor requisitos em fragmentos de caminho finito e não podem ser verificadas<br>
considerando apenas os estados alcançáveis. (BAIER et al., 2008).<br>
Segundo (CLARKE et al., 2003), podemos definir uma propriedade de segurança como:<br>
dado um sistema de transições ST = (S, S0, E), seja um conjunto B ? S que especifica um<br>
conjunto de maus estados tais que S0 ?B = ?, pode-se dizer que ST é seguro com relação a B,<br>
denotado por ST |= AG¬B se não existe um caminho no sistema de transição do estado inicial<br>
S0 até o estado B, de outro modo é dito que ST não é seguro.<br>
Adicionar exemplos de propriedades de segurança em hardware<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 28<br>
2.3 Técnicas de compiladores<br>
Compiladores são sistemas de software utilizados para tradução de uma linguagem de<br>
programação para outra, ou seja, o programa da linguagem fonte é lido e traduzido para um<br>
código equivalente na outra linguagem, ou linguagem alvo. Geralmente utilizada para transformar<br>
trechos de código em uma linguagem a ser executada pelo computador (AHO et al., 2007).<br>
Diversas técnicas podem ser utilizadas nas diversas etapas, até que o código seja traduzido,<br>
tais como LL(1) e LR na análise sintática; eliminação de código morto; propagação de constante<br>
e Peephole na otimização de código(AHO et al., 2007). Neste projeto serão focados as áreas de<br>
transformações de código e otimização de código.<br>
2.3.1 Transformações de código<br>
Transformações de código correspondem a uma complexa função que envolve analise de<br>
fluxo de dados e modificação completa do programa que são parte integral da alta performance e<br>
sistemas computacionais. Podem ser classificados em transformações escalares que reduzem<br>
o número de instruções a serem executadas no programa ou transformações paralelas que<br>
maximizam o paralelismo (SRIKANT; SHANKAR, 2002).<br>
A Figura 11 representa o trecho de código apresentado na Figura 19. O trecho representa<br>
o comportamento das entradas, neste caso de um código da porta AND. E a figura Figura 12<br>
representa a tradução deste trecho em código na linguagem C. Esta tradução foi realizada pela<br>
ferramenta V2C, utilizada neste projeto. Adicionar<br>
refer-<br>
ência<br>
Figure 11 – Trecho de código em VHDL representando porta AND.<br>
1 p r o c e s s ( x , y )<br>
2 b e g i n<br>
3 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
4 F &lt;= ’ 1 ’ ;<br>
5 e l s e<br>
6 F &lt;= ’ 0 ’ ;<br>
7 end i f ;<br>
8 end p r o c e s s ;<br>
Fonte: Própria.<br>
Expandir esta seção. Apresentar propriedades de transformação e técnicas para avaliar a<br>
transformação<br>
2.3.2 Otimização de código<br>
A otimização de código consiste na melhoria do código intermediário gerado pelos<br>
algoritmos de compilação com o objetivo de obter um menor tempo de execução do programa,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 29<br>
Figure 12 – Trecho de código traduzido para linguagem C.<br>
1 /? S t a r t o f T r a n s l a t i o n ? /<br>
2 /? p0 : ? /<br>
3 i f ( chg [ x ] | | chg [ y ] ) {<br>
4 i f ( ( ( o l d [ x ]==1) && ( o l d [ y ]==1) ) ) {<br>
5 new [ f ] = 1 ;<br>
6 }<br>
7 e l s e {<br>
8 new [ f ] = 0 ;<br>
9 }<br>
10 }<br>
11 /? End o f T r a n s l a t i o n ? /<br>
Fonte: Própria.<br>
porém outros fatores podem ser introduzidos, como algoritmos menores. Este fato não implica<br>
em afirmar que o melhor código é gerado, visto que dada a complexidade, raramente pode ser<br>
obtido que o código gerado pode ser o melhor possível (AHO et al., 2007).<br>
Segundo AHO et al., otimização local de código consiste na otimização de um bloco<br>
básico de código, ou seja, a otimização ocorre em um trecho especifico de código. Os blocos<br>
básicos são trecho onde não ocorrem saltos ou loops, para nenhuma outra parte do código. A<br>
otimização global de código é baseado na analise do fluxo de dados, de modo que ocorra as<br>
elminação de instruções não necessárias ou substituição mais facil. A otimização global consite<br>
na analise completa do código. Neste sentido, nas próximas seções serão apresentadas algumas<br>
importantes técnicas de otimizações.<br>
2.3.2.1 Grafo Acliclico Direcional - GAD<br>
Grafo Aciclico Direcional é utilizado para diversos fins dentro da estrutura de compi-<br>
ladores, principalmente para geração da parse tree otimização de código. Pode ser usado na<br>
representação de instruções unicas blocos básicos de código(AHO et al., 2007). <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >O uso de</span> GAD<br>
permite a melhoria de de código, tais como:<br>
• Elminação de subexpressões locais comuns, ou seja, expressões que o valor já foi com-<br>
putado anteriomente;<br>
• Eliminação de código morto;<br>
• Reordernamento de declarações buscando reduzir o tempo que o valor temporário necessita<br>
ser preservado em um registro;<br>
A Figura 13 apresenta um bloco básico com algumas instruções, no caso apresentando<br>
são 4 operações entre somas e multiplicação e a partir deste bloco a Figura 14 apresenta o GDA<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 30<br>
Figure 13 – Exemplo de bloco basico de código.<br>
1 a = b + c<br>
2 b = a ? d<br>
3 c = b + c<br>
4 d = a ? d<br>
Fonte: (AHO et al., 2007)<br>
Figure 14 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
deste trecho de código. Nele apresenta cada nó como uma operação especifica e os terminais<br>
como as parcelas das operações.<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC<br>
Grafo de fluxo de controle corresponde a um grafo direcionado, no qual cada nó rep-<br>
resenta blocos básicos e cada aresta representa os caminhos de fluxo entre os blocos basi-<br>
cos (ALLEN, 1970). É importante ressaltar que saltos determinam o final de um determinado<br>
bloco básico, ou seja, saltos indicam um caminho para uma nova região de código básico (AHO<br>
et al., 2007).<br>
Apresentar um exemplo de como e utilizado em código<br>
2.3.2.3 Eliminção de código morto<br>
A eliminacação de código morto é uma técnica que busca a eficiência de um programa<br>
evitando a execução de instruções não necessária em tempo de execução (KNOOP et al., 1994).<br>
O código morto consiste em instruções que não serão alcançáveis durante o fluxo do programa,<br>
sendo esta técnica basicamente a retirada de qualquer variável que não será utilizada em qualquer<br>
outro nó do grafo (AHO et al., 2007).<br>
A utilização de GAD corresponde na eliminação de qualquer nó raiz, ou seja, nó sem<br>
ancestrais, as quais não esteja ativa anexada a mesma. A execução repetida desta operação<br>
removerá todos os nós correspondentes a código morto (AHO et al., 2007).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 31<br>
Figure 15 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
Na Figura 15, supondo que os nós a, b e c estejam ativa, porém o nó énão esteja, o último Corrigir<br>
nó é?pode ser eliminado imediatamente. Os nós restantes continuam no GDA, a menos que não tenho<br>
variáveis ativas atreladas aos nós (AHO et al., 2007).<br>
2.3.2.4 Análise do fluxo de dados<br>
Análise de fluxo de dados refere-se ao conjunto de técnicas que derivam informações<br>
sobre o fluxo de dados ao longo dos caminhos de execução do programa. Para análise do<br>
programa, é necessário considerar todas as posiveis execuções através do grafo de fluxo de<br>
controle (AHO et al., 2007).<br>
Apresentar exemplos<br>
2.3.2.5 Gerador de código<br>
O gerador de código é responsavél pela tradução final do programa-fonte <span class='f1 c_13' id='c_13_1' href='#c_13_2' cs_f='.c_13' >para o programa</span>-<br>
alvo, o mesmo recebe como entrada um código intermediário juntamente com a tabela de<br>
símbolos. Faz-se necessário que o programa-fonte tenha sido analisado sintatica e lexicamente,<br>
assim evitando que erros possam ser passados <span class='f1 c_13' id='c_13_1' href='#c_13_2' cs_f='.c_13' >para o programa</span>-alvo, por outro lado a existência<br>
de uma nível de otimização, faz-se opicional neste caso (AHO et al., 2007).<br>
O gerador de código possui três tarefas primarias, sendo as mesmas seleção de instrução,<br>
alocação de registros e atribuições. A seleção de instruções envolve a escolha das instruções<br>
apropriadas da máquina-alvo para implementar as declarações do código intermediario. A<br>
atribuição e atribuição de registros envolve a decisão sobre os valores a serem registrados nos<br>
registros(AHO et al., 2007).<br>
Apresentar exemplo<br>
32<br>
3 TRABALHOS CORRELATOS<br>
Sugiro apenas mencionar que foi feito a revisão sistemática; o que já foi feito e os resul-<br>
tados. As outras seções sobre RS e mover para apêndice.<br>
3.1 Revisão sistemática<br>
A revisão sistemática consiste é um método de identificação, análise e interpretação de<br>
pesquisas relevantes em determinada área ou questão de pesquisa. Para execução da revisão sis-<br>
temática se requer um esforço maior, em comparação as pesquisas tradicionais, sendo necessário<br>
seguir uma sequência de passos metodológicos sobre a área ou questão de pesquisa ao qual<br>
deseja ser feita a pesquisa (KITCHENHAM, 2004).<br>
Para a execução da revisão sistemática, é necessário um esforço considerável, se com-<br>
parado a uma revisão informal a literatura. Enquanto que a revisão de literatura informal é<br>
conduzida de forma ad-hoc, sem planejamento e critérios de seleção estabelecidos a priori,<br>
a revisão sistemática requer um protocolo formal bem definido, com uma sequência de pas-<br>
sos metodológicos, para conduzir uma pesquisa sobre o tema ao qual deseja-se realizar a<br>
pesquisa (MAFRA; TRAVASSOS, 2006).<br>
A aplicação da revisão sistemática requer que seja seguido um conjunto bem definido e<br>
sequêncial de passos, seguindo um protocolo de pesquisa desenvolvido previamente. Através<br>
deste método é possível realizar uma extensa pesquisa, contemplando uma grande quantidade<br>
de informações sobre o assunto pesquisado (MAFRA; TRAVASSOS, 2006). Este protocolo é<br>
construído considerando um tema específico que representa o elemento central da investigação,<br>
onde os passos da pesquisa, as estratégias definidas para coletar as evidências e o foco das<br>
questões de pesquisa são definidas explicitamente, de tal forma que outros pesquisadores sejam<br>
capazes de reproduzir o mesmo protocolo de pesquisa (BIOLCHINI et al., 2005).<br>
Segundo MAFRA; TRAVASSOS, o processo para a condução de revisões sistemáticas<br>
envolve três etapas:<br>
1. Planejamento da Revisão: os objetivos da pesquisa são listados e o protocolo da revisão<br>
é definido.<br>
2. Condução da Revisão:nesta atividade, as fontes para a revisão sistemática são sele-<br>
cionadas, os estudos primários são identificados, selecionados e avaliados de acordo com<br>
os critérios de inclusão, exclusão, e de qualidade estabelecidos durante o protocolo da<br>
revisão.<br>
Chapter 3. TRABALHOS CORRELATOS 33<br>
3. Análise dos Resultados: os dados dos estudos são extraídos e sintetizados para análise e<br>
apresentação dos resultados.<br>
Vale ressaltar que como o objetivo deste trabalho é realizar um estudo exploratório de<br>
caracterização de área podemos dizer que esta revisão sistemática se caracteriza como uma quasi-<br>
sistemática (TRAVASSOS et al., 2008), pois segue o mesmo processo da revisão sistemática e<br>
preserva o rigor e mesmo formalismo para as fases metodológicas de elaboração de protocolo e<br>
execução da revisão, mas sem a aplicação de uma meta-análise a princípio, que pode ser aplicada<br>
posteriormente.<br>
3.1.1 Planejamento da Revisão Sistemática<br>
Objetivo: Este estudo tem o objetivo esquematizado a partir da estrutura do paradigma<br>
GQM (do ingles Goal,Question and Metric)(BASILI et al., 1994).<br>
Analisar Publicações científicas através de um estudo baseado em revisão sis-<br>
temática<br>
Com propósito de Identifica-las<br>
Com relação as Vantagens e desvantagens da utilização de assertiva e transformações<br>
de código na verificação do código na linguagem de descrição VHDL<br>
Do ponto de vista do Pesquisador<br>
No contexto Acadêmico ou industrial para verificação de assertivas na linguagem<br>
de descrição VHDL<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM<br>
Formulação da Pergunta: Buscamos respostas para as seguintes perguntas:<br>
• Q1: Quais são os métodos para verificação de circuitos lógicos descritos na linguagem de<br>
programação VHDL?<br>
– Q1.1: Foi desenvolvido e está disponível alguma ferramenta para aplicação do<br>
método?<br>
– Q1.2: Qual a técnica de exploração de estados para circuitos lógicos?<br>
– Q1.3: O método proposto é baseado em técnicas de verificação de software?<br>
– Q1.4: Como o método proposto valida pré e pós condições no programa?<br>
– Q1.3: Foi utilizado algum benchmark de programas em VHDL para experimentação<br>
e o mesmo encontra-se disponível?<br>
– Q1.4: Quais as perspectivas futuras para melhorar da aplicação do método proposto?<br>
Escopo da pesquisa:Na delimitação do escopo da pesquisa foram estabelecidos critérios,<br>
buscando garantir a viabilidade da execução, acessibilidade dos dados e abrangência do estudo re-<br>
alizado. A pesquisa dar-se-á <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >a partir de</span> bibliotecas digitais através das suas respectivas máquinas<br>
Chapter 3. TRABALHOS CORRELATOS 34<br>
de busca e, quando os dados não estiverem disponíveis eletronicamente, através de consultas<br>
manuais.<br>
Critérios de Seleção de Fontes. Para as bibliotecas digitais é desejado:<br>
• Possuir uma máquina de busca que permita <span class='f1 c_20' id='c_20_1' href='#c_20_2' cs_f='.c_20' >o uso de</span> expressões lógicas ou mecanismo<br>
equivalente.<br>
• Incluir em sua base, publicações de exatas ou correlatas que possuam relação direta com o<br>
tema a ser pesquisado<br>
• As máquinas de busca deverão permitir a busca no texto completo das publicações.<br>
Segundo ROCHA et al., os mecanismos de busca utilizados devem garantir resultados<br>
únicos através da busca de um mesmo conjunto de palavras-chaves (string de busca). Quando<br>
isto não for possível, deve-se estudar e documentar uma forma de minimizar os potenciais efeitos<br>
colaterais desta limitação.<br>
Métodos de Busca das Publicações. As fontes digitais foram acessadas via Web, através<br>
de expressões de busca pré-estabelecidas. A biblioteca digital consultada foi a Scopus, acessível<br>
em http://www.scopus.com. Segundo a editora ELSEVIER, a Scopus é uma das maiores bases<br>
de dados de resumos e citações da literatura de pesquisa peer-reviewed com mais de 22, 800<br>
títulos de mais de 5, 000 editoras internacionais abrangendo as áreas de tecnologia, medicina,<br>
artes, ciências sócias e com atualizações diárias. Entre as editoras podemos citar: Springer<br>
(SPRINGER, 2018); IEEE Xplore Digital Library (IEEE, 2018);ACM Digital Library (ACM,<br>
2018) ; ScienceDirect/Elsevier (B.V, 2018); Wiley Online Library (SONS, 2018); dentre outras.<br>
String de Busca. A string de busca foi definida segundo o padrão PICO (do inglês<br>
Population, Intervention, Comparison, Outcomes) (KITCHENHAM et al., 2009), conforme a<br>
estrutura abaixo:<br>
• População: Trabalhos publicados em conferências e periódicos que relacionam verificação<br>
de propriedades de circuitos lógicos em códigos para a descrição de hardware.<br>
• Intervenção: Verificação de propriedades relacionadas a verificação de circuitos para as<br>
diferentes estruturas das linguagens de descrição de hardware;<br>
• Comparação: análise de cobertura e suporte das abordagens identificadas para a verificação<br>
de propriedades das linguagens de descrição de hardware;<br>
• Resultados: a partir da descrição das abordagens pretende-se verificar a cobertura que cada<br>
abordagem apresenta na manipulação das diferentes estruturas da linguagem de descrição<br>
de hardware para a verificação de propriedades baseada em assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 35<br>
Segundo ROCHA et al., como este estudo representa <span class='f1 c_4' id='c_4_1' href='#c_4_2' cs_f='.c_4' >um estudo de</span> mapeamento/caracteri-<br>
zação, a string de busca foi definida de acordo com dois aspectos: População e Intervenção, como<br>
é apresentado na estrutura abaixo. Posteriormente esta mesma string de busca será executada<br>
na biblioteca Scopus para busca de artigos e publicações de modo a gerar uma interseção entre<br>
população e intervenção.<br>
• População: publicações que fazem referência a verificação de propriedades de circuitos<br>
lógicos e sinônimos:<br>
– Palavras-chaves: "circuit checker" OR "circuit verification" OR "contract based<br>
verification" OR "code analysis" OR "static analysis" OR "dynamic analysis" OR<br>
"safety verification" OR "RTL analysis" OR "program analysis" OR "property veri-<br>
fication" OR "formal verification" OR "model checking" OR "model checker" OR<br>
"hardware checker" OR "hardware verification" OR "validity checker" OR "hard-<br>
ware assertion" OR "assertion checker" OR "assert verification" OR "assertion-based<br>
verification" OR "assertion based verification" OR "assertion-based design" OR "bit<br>
level verification"<br>
• Intervenção: Verificação de circuitos e sinônimos:<br>
– Palavras-chaves:"hardware statement" OR "hardware code" OR "hardware source<br>
code" OR "hardware semantics" OR "hardware property" OR "logical gates" OR<br>
"sequential circuit" OR "parallel circuit" OR "real circuits" OR "complex circuits"<br>
OR "control circuitry" OR ”software netlist” OR “hardware emulation” OR “silicon<br>
debug”<br>
3.1.1.1 Procedimentos de Seleção e Critérios<br>
A estratégia de busca será aplicada por um pesquisador para identificar as publicações<br>
em potencial. A seleção das publicações dar-se-á em 2 etapas, conforme apresentado a seguir.<br>
1. Seleção e catalogação preliminar dos dados coletados: A seleção preliminar das publi-<br>
cações será feita a partir da aplicação da string de busca na biblioteca Scopus, o resultado<br>
desta busca corresponde a seleção preliminar. Todas as publicações serão armazenadas<br>
para análise posterior;<br>
2. Seleção dos dados relevantes - [1 filtro]: A seleção preliminar com <span class='f1 c_18' id='c_18_1' href='#c_18_2' cs_f='.c_18' >o uso da</span> expressão<br>
de busca não garante que todo o material coletado seja útil no contexto da pesquisa, pois a<br>
aplicação das expressões de busca é restrita ao aspecto sintático. Por isso, é necessário a<br>
criação de filtros de exclusão e inclusão, de modo a classificar os artigos e publicações que<br>
se enquadram no contexto da pesquisa realizada. Nesta epata apenas serão lidos o título,<br>
abstracts, e palavras-chaves e classificar de acordo com os filtros, ou seja, se será aceito ou<br>
excluído. Devem ser excluídas as publicações contidas no conjunto preliminar que:<br>
Chapter 3. TRABALHOS CORRELATOS 36<br>
• CE1-01: Não serão selecionadas publicações em que as palavras-chave da busca<br>
não apareçam no título, resumo e/ou texto da publicação (excluem-se os seguintes<br>
campos: as seções de agradecimentos, biografia dos autores, referências bibliográficas<br>
e anexas).<br>
• CE1-02: Não serão selecionadas publicações em que descrevam e/ou apresentam<br>
‘keynote speeches’, tutoriais, cursos e similares.<br>
• CE1-03: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação/validação de códigos para descrição de hardware.<br>
• CE1-04: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação de código de descrição de hardware baseado em assertivas ou propriedades<br>
de verificação de hardware.<br>
Podem ser incluídas apenas as publicações contidas no conjunto preliminar que:<br>
• CI1-01:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita uma abordagem para verificação<br>
de código de descrição de hardware baseado em assertivas ou propriedades de<br>
verificação de hardware.<br>
• CI1-02:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita recomendações de melhoria<br>
na utilização de abordagens para verificação de código de descrição de hardware<br>
baseado em assertivas ou propriedades de verificação de hardware.<br>
3. Seleção dos dados relevantes - [2 filtro]: Apesar do 1o filtro limitar o universo de busca,<br>
infelizmente não há garantias de que todo material selecionado no filtro anterior seja útil<br>
no contexto da pesquisa. Neste caso, novos filtros são gerados, buscando, da mesma forma<br>
que o primeiro filtro, classificar os artigos e publicações que se enquadram no contexto<br>
da pesquisa. Para este filtro é necessário a leitura na integras dos artigos selecionados<br>
anteriormente. O objetivo é identificar que relacionam assertivas e/ou propriedade de<br>
verificação de hardware.<br>
• CS2 -ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware e não citam assertivas<br>
• CS2 +ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware, mas citam assertivas<br>
• CS2 -ASS +VER_HARD: Não devem ser selecionadas publicações que contextual-<br>
izam verificação de hardware, mas citam assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 37<br>
Dessa forma, todas as publicações devem respeitar o critério abaixo:<br>
• CS3 +ASS +VER_HARD: Serão selecionadas publicações que contextualizam<br>
verificação de hardware e citam assertivas em seu contexto.<br>
Devido ao tempo necessário <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento</span> execução dos filtros da revisão<br>
sistemática serem extensos, apenas o primeiro filtro foi executado neste projeto, mesmo que<br>
os parâmetros para o segundo filtro já tenho sido desenvolvidos. Em contra partida foram<br>
selecionados 6 artigos que serviram como ferramentas de estudo <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento</span> da<br>
metodologia que será apesentada no Capítulo 4.<br>
3.2 Revisão da literatura<br>
Nesta sessão serão apresentados trabalho relevantes <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento</span> do método<br>
proposto que foram identificados utlizando a revisão sistemática mencionado anteriormente.<br>
Os artigos apresentam técnicas de transformações de código, utilização de Assertion-Based<br>
Verification e PSL para verificação de hardware.<br>
3.2.1 V2c-A verilog to C translator<br>
O artigo de MUKHERJEE et al. apresenta uma ferramenta implementada em C++<br>
chamada v2c para transformação de código da linguagem de descrição Verilog para linguagem<br>
de programação C. A ferramenta é executada a nível de palavra, visto que esta abordagem garante<br>
uma aumento na escalabilidade, mas também proporionando que técnicas, como interpolaçãoe adicionar<br>
refer-<br>
ência<br>
aceleração de looppossam ser utilizadas para verificação, algo inviavél, caso a tradução fosse<br>
adicionar<br>
refer-<br>
ência<br>
executada a nível de bit. O sistema recebe como entrada um código em Verilg, onde são aplicadas<br>
regras semânticas e mapeando os bit de operação, chamado software netlist. Após isso, o código<br>
intermediário é convertido para C.<br>
A contribuição deste trabalhoconsiste na utilização de transformações de código como<br>
Qual<br>
tra-<br>
balho?<br>
base principal e partindo deste pressuposto torna-se vantajoso devido a utilização de outras<br>
ferramentas que não apresente suporte a certas linguagens, tais com a ferramenta ESBMC,<br>
utilizada neste trabalho, não apresenta suporte a VHDL, porém apresenta suporte as linguagens<br>
C/C++. Em outras palavras, a contribuição deste trabalhofoi a utilização de traduções de códigos<br>
Qual<br>
tra-<br>
balho?<br>
e utilizado este conceito como modelo de entrada para analise de circuitos.<br>
3.2.2 Unbounded safety verification for hardware using software ana-<br>
lyzers<br>
No artigo de MUKHERJEE et al. foi apresentado uma metodologia que aborda a utiliza-<br>
ção de técnicas e analisadores de software, com o objetivo de de abordar a análise de circuitos e<br>
Chapter 3. TRABALHOS CORRELATOS 38<br>
com isso trançar um paralelo entre as abordagens. Para testes foram utilizadas três metodologias<br>
de análise, usando interpolação, k-inductione tecnologias hibrídas. Como resultante dos testes, foi adicionar<br>
refer-<br>
ência<br>
adicionar<br>
refer-<br>
ência<br>
observado as principais causas de erros, por exemplo, bits não preciso e no caso das operações<br>
a bit-level ocorria perda de informações. Também foi obeservado que apesar de não serem<br>
otimizadas para análises de hardware, alguns analisadores de softaware podem, dependendo da<br>
técnica utilizada no analisador, ser utilizada para analise de hardware.<br>
Descrever<br>
qual<br>
o mo-<br>
tivo.<br>
A utilização de técnicas de análise de software <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento de</span> análise de<br>
hardware é o foco a ser abordado neste neste trabalho de maneira prática, utilizando os princípio<br>
analisados por (MUKHERJEE et al., 2016a). Neste contexto, o objetivo deste trabalho é a<br>
utilização de técnicas de software para análise de circuitos, diferente do artigo apresentado acima<br>
que busca utilização uma abordagem mais complexa provando a possibilidade da utilização de<br>
técnicas de analise de software no contexto da verificação de hardware.<br>
A última frase está confusa, no meu entedimento é o mesmo sentido.<br>
3.2.3 Formal verification of timed VHDL programs<br>
No trabalho apresentado por BARA et al. é proposto uma abordagem para a análise<br>
de tempo relacionado a cada porta lógica dentro de um dado circuito analisado. A abordagem<br>
apresenta a tradução de um circuito lógico codificado em VHDL para um formalismo baseado<br>
em automato de tempo. Tal formalismo é representado por uma automato de estados finitos referência<br>
com relogios simbólicos que evoluem em taxa uniforme. A tradução é executada de modo<br>
automatico, baseado na emulação da propagação de cada transação ao longo de cada sinal, o<br>
seja, são automatos programados e cronometrados do circuito. Após a tradução para automato, a<br>
analise é feita pela ferramenta UPPALque é um model checking de verificação de propriedades referência<br>
de tempo. Seguindo esta metodologia a análise pode ser extraida de modo independente de cada<br>
bloco, desta forma a análise é feita de forma mais precisa, podendo ser analisado inumeros<br>
fatores, tais como limites de intervalo e sinal de correlação.<br>
O artigo apresenta uma abordagem de tempo, que torna-se interessante adição ao método.<br>
Porém até o momento a função não foi implementada ficando a trabalho futuros.<br>
Expandir o texto acima, exemplo, descrever como o método poderia ser incluindo no seu<br>
TCC.<br>
3.2.4 On the use of assertions for embedded-software dynamic verifica-<br>
tion<br>
Em GUGLIELMO et al. é apresentado uma metodologia para a integração dinamica de<br>
Assertion-Based Verification para várias fases da análise da verificação de fluxo em sistemas<br>
embarcados, por exemplo, emulação, diagnosticos e Debug, mas também um ferramenta chamada<br>
Chapter 3. TRABALHOS CORRELATOS 39<br>
RadCheck. O metodo de aplicação, chamado V-model é dividido em fases de verificação em<br>
paralelo com as fases de design do circuito. Com base no V-model, o método é aplicado, iniciando<br>
com o nível de sistema e as especificação do sistema, neste caso especificado usando PSL.<br>
Neste nível é especificado todas as funcionalidades gerais da aplicação. No nível de integração<br>
visa investigar problemas de interação que possam ocorrer, definindo propriedades que cobrem<br>
incrementalmente as unidades estruturais interativas de aplicação. No nível de unidade descrevem<br>
comportamentos internos e são definidas através de parâmetros de entrada/saída das unidade e<br>
estruturas de dados internas.<br>
A contribuição deste projeto está relacionado a utilização de assertivas no contexto da<br>
verificação de software. As assertivas são o principal meio de análise proposto neste projeto,<br>
visto que estas mesma assertivas serão analisadas pelo ESBMC. Aliado a isso em GUGLIELMO<br>
et al. é apresentado modelos de utilização de assertivas no processo de verificação de hardware,<br>
e tais assertivas foram adaptadas para um modelo proposto neste trabalho.<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation<br>
No trabalho de BOULE; ZILIC é apresentado uma ferramenta de geração de assertivas<br>
no contexto da emulação de circuitos, de modo que estas assertivas descrita em PSL possam<br>
transformadas para o modelo de linguagem de descrição de hardware. Inicialmente é realizada<br>
toda análise de cada assertiva e a mesma é traduzida em partes, levando em consideração os<br>
operadores e cada estrutura, por exemplo if-else, utilizado na declaração da assertiva.<br>
Apresentar um exemplo para explicar o texto acima<br>
trabalho de BOULE; ZILIC consolida e apresenta aspectos importantes, tais como a<br>
utilização de uma ferramenta para geração de assertivas, o que torna-se no contexto deste projeto,<br>
extremamente importante, visto que o modelo adotado atualmente consiste tanto na geração<br>
automática das assertivas, bem como a inserção manual por parte do usuário.<br>
40<br>
4 MÉTODO PROPOSTO<br>
Este Capítulo descreve o método proposto neste trabalho, baseado transformações de<br>
código para análise de circuitos lógicos descritos em VHDL utilizando <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >Bounded Model Checking</span>,<br>
neste caso o model checker ESBMC.<br>
4.1 Visão geral do método<br>
O método proposto consiste inicialmente em receber como entrada um circuito lógico<br>
descrito em VHDL, onde uma dada propriedade representada em uma assertiva será analisada,<br>
as assertivas serão inseridas de automaticamente pelo método ou pelo próprio usuário do método.<br>
O código VHDL analisado posteriomente é traduzido para linguagem C e recebe uma instrumen-<br>
tação de código (com funções especificas suportadas pelo método) para a posterior validação do<br>
mesmo. O Código em C automaticamente gerado, já instrumentado, será processado e analisado<br>
pelo ESBMC de acordo com as assertivas inseridas e ao final é apresentado o resultado. Caso<br>
alguma das assertivas seja violada, um contra-exemplo é apresentado ao usuário. Uma visão<br>
geral do método proposto é apresentado na Figura 16 e nas sessões a seguir serão apresentados<br>
cada etapa do método proposto neste trabalho.<br>
Figure 16 – Ciclo da ferramenta<br>
Fonte: Própria<br>
Com o intuito de auxiliar nas explicações apresentadas nas próximas sessões, o código<br>
na Figura 17 será utilizado nas explanações, bem como será apresentado todas as alterações do<br>
mesmo, conforme cada etapa do método.<br>
Chapter 4. MÉTODO PROPOSTO 41<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 ENTITY U l a _ t c c IS<br>
5 PORT(A, B , B i n v e r t i d o , Op1 , Op2 : IN BIT ;<br>
6 R e s u l t a d o :OUT BIT ) ;<br>
7 END U l a _ t c c ;<br>
8<br>
9 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
10 SIGNAL a n d _ p o r t : b i t ;<br>
11 SIGNAL o r _ p o r t : b i t ;<br>
12 SIGNAL x o r _ p o r t : b i t ;<br>
13 SIGNAL mux2x1 : b i t ;<br>
14 BEGIN<br>
15 PROCESS(A, B , B i n v e r t i d o , Op1 )<br>
16 BEGIN<br>
17 ??PORTA AND<br>
18 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
19 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
20 ELSE<br>
21 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
22 END IF ;<br>
23 ??PORTA OR<br>
24 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
25 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
26 ELSE<br>
27 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
28 END IF ;<br>
29 ??PORTA XOR<br>
30 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
31 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
32 ELSIF (A = ’ 1 ’ and mux2x1 = ’ 1 ’ ) THEN<br>
33 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
34 ELSE<br>
35 x o r _ p o r t &lt;= ’ 1 ’ ;<br>
36 END IF ;<br>
37 ??INVERSOR<br>
38 IF ( B i n v e r t i d o = ’ 0 ’ ) THEN<br>
39 mux2x1 &lt;= B ;<br>
40 ELSE<br>
41 mux2x1 &lt;= NOT B ;<br>
42 END IF ;<br>
43 ??MUX4X1<br>
44 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
45 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
46 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
47 R e s u l t a d o &lt;= o r _ p o r t ;<br>
48 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
49 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
50 END IF ;<br>
51 END PROCESS ;<br>
52 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 42<br>
4.2 Preprocessamento do VHDL e inserção de assertivas<br>
A fase inicial do método consiste no preprocessamento do código VHDL com as an-<br>
otações de código pelo usuário ou pelo método proposto de forma automática, incluindo as<br>
assertivas, conforme a Figura 16, na etapa A. O método não realiza qualquer tipo de verificação<br>
sobre o código VHDL, apenas utiliza o mesmo como entrada juntamente com as assertivas<br>
inseridas. Toda verificação é realizada sobre o código em linguagem C, que será traduzido a<br>
partir do código VHDL analisado, nas próximas etapas do método proposto. Vale ressaltar que<br>
mesmo a linguagem VHDL tendo um modelo de assertivas padrão, para o método tornou-se<br>
necessário a criação de um modelo (baseado em comentários) para que as funções do model<br>
checker adotado fossem suportadas, como a geração de valores não deterministicos.<br>
As assertivas manuais são adicionadas entre as tags @c2vhdl:ASSERT e @c2vhdl:END<br>
e todo trecho de código entre estas tags deve estar comentado, desta forma não apresentará<br>
erro na tradução do código em linguagem C, bem como na sintetização do código VHDL. Nas<br>
assertivas são incluidas as funções necessárias para a análise utilizando a ferramenta ESBMC. A<br>
assertiva apresenta três informações principais, sendo elas: condição, mensagem e gravidade.<br>
Ajustar está assertiva. Para quem não vê o código todo, ela não faz sentido<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR.<br>
1 ??@c2vhdl : ASSERT<br>
2 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ )<br>
3 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 "<br>
4 ??s e v e r i t y ERROR;<br>
5 ??@c2vhdl :END<br>
Fonte: Própria.<br>
A condição (na linha 2 da Figura 19) representa a assertiva propriamente dita e que será<br>
analisado pela aplicação. A condição será precedida de??assert e seguido ou não da palavra<br>
not, com isso a assertiva pode assumir valor negativo, conforme necessidade do usuário. Na<br>
Figura 19 a assertiva busca verificar se a variavél Resultado terá valor igual a 1. Qual a<br>
razão<br>
para<br>
isso,<br>
ex-<br>
plique!<br>
A mensagem (??report na linha 3 da Figura 19) é definida pelo usuário e será<br>
apresentado caso a assertiva apresente falha, assim a mensagem pode ser utilizada como um meio<br>
de depuração das propriedades validadas. A severidade (severity na linha 4 da Figura 19)<br>
pode ser definida como error, que representa um erro fatal e parada da verificação. A severidade<br>
do tipo warning que representa um erro não fatal, contabiliza as falhas das assertivas, porém<br>
não causa a parada da verificação. As mensagens futuramente pode ser integradas um framework<br>
para teste de unidade, contudo está é uma etapa ainda em planejamento neste trabalho.<br>
Juntamente com as assertivas outra função que pode ser utilizada é a função __ESBMC<br>
Chapter 4. MÉTODO PROPOSTO 43<br>
_assume() suportada pelo model checker ESBMC. Esta função utilizada em conjuto com a<br>
ferramenta ESBMC permite que durante a verificação uma variavél possa ter uma valor setado<br>
durante o tempo de execução da verificação. A importância desta função é fazer verificações onde<br>
se conhece os valores de entrada juntamente com o valor resultante, por exemplo, na verificação<br>
de portas lógicas.<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume().<br>
1 ??__ESBMC_assume (A = ’ 1 ’ )<br>
2 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
Fonte: Própria.<br>
A assertivas que serão verificadas são automáticas traduzidas a partir das entradas do<br>
código VHDL. Seja no modelo manual (assertivas escritas pelo usuário) ou automático (inferidas<br>
pelo método proposto por meio de análise estática), as entradas são mapeadas para serem<br>
utilizados na etapa de instrumentação. Desta forma, tais entradas podem ser utilizadas para gerar<br>
essas assertivas e então serem adicionadas diretamente ao código em linguagem C durante a fase<br>
de instrumentação.<br>
A Figura 20 apresenta o código juntamente com as assertivas conforme o padrão salien-<br>
tado na section 4.2. Neste exemplo foi implementado utilizado a inserção manual das assertivas<br>
e também da função __ESBMC_assume(), entretanto o objetivo é automatizar estas funções<br>
durante a execução da ferramenta.<br>
4.3 Tradução de código VHDL para a linguagem C<br>
Nesta etapa a tradução do código VHDL para linguagem C é executada, conforme<br>
apresentado na Figura 16, etapa B. A partir deste ponto, a ferramenta é executada de maneira<br>
propriamente dita, tendo todo o processo automatizado até a apresentação do resultado. Para<br>
esta etapa do método foi selecionado a ferramenta V2Cque realiza a tradução de VHDL para Adicionar<br>
refer-<br>
ência<br>
Linguagem C.<br>
A ferramenta V2C apresenta diversas vantagens em relação a equivalência de tradução<br>
de linguagens, contudo V2C apresenta certas limitação na tradução do código VHDL, em outras<br>
palavras, a mesma não reconhece algumas estruturas especificas do VHDL. A ferramenta aceita<br>
apenas entradas e saídas do tipo: bit, std_ulogic, qsim_state, std_ulogic_vector<br>
e interger. Na parte de arquitetura, a ferramenta aceita uma gama maior de estruturas, tra-<br>
balhando com expressoões do tipo: signal, variable, integers, strings e caracteres.<br>
Em expreções condicionais os operandos são AND, OR, NOT &lt;=, =&gt;,=,&lt;,&gt; e &lt;&gt;. Aceita<br>
também a estrutura de process, além da estutura block. A estrutura process é limitada<br>
Chapter 4. MÉTODO PROPOSTO 44<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 . . .<br>
4 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
5 SIGNAL a n d _ p o r t : b i t ;<br>
6 SIGNAL o r _ p o r t : b i t ;<br>
7 SIGNAL x o r _ p o r t : b i t ;<br>
8 SIGNAL mux2x1 : b i t ;<br>
9 BEGIN<br>
10 PROCESS(A, B , B i n v e r t i d o , Op1 ) IS<br>
11 BEGIN<br>
12 ??PORTA AND<br>
13 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
14 ??__ESBMC_assume (A = ’ 1 ’ )<br>
15 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
16 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
17 ELSE<br>
18 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
19 END IF ;<br>
20 . . .<br>
21 ??MUX4X1<br>
22 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
23 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
24 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
25 R e s u l t a d o &lt;= o r _ p o r t ;<br>
26 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
27 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
28 ??@c2vhdl : ASSERT<br>
29 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
30 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
31 ??s e v e r i t y ERROR;<br>
32 ??@c2vhdl :END<br>
33 END IF ;<br>
34 END PROCESS ;<br>
35 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
apenas a: if-else, case e loops. Como trabalho futuro, neste trabalho tem-se buscado<br>
novas abordagens para ampliar o suporte a estruturas não suportadas pelo V2C.<br>
Na tradução é necessário substituir os operadores originais por seus equivalentes em<br>
linguagem C. A excessão são os operadore específicos que gerenciam os valores de bit, tais<br>
como concatenação ou manipulação de partes vertoriais, para os quais são necessários construir<br>
procedimentos especificos em C.<br>
Conforme mostrado na Figura 21, na tradução são gerados vários vetores para suporte<br>
a tradução dos sinais representados no VHDL, sendo eles chg[], old[] e new[]. O vetor<br>
old[] contém o valor do sinais do passo anteriore a partir deste vetor o valor a ser usado nos Confuso<br>
issocálculo é obtido. O vetor new[] representa os novos valores a serem calculados pelos antigose<br>
Qual?<br>
Chapter 4. MÉTODO PROPOSTO 45<br>
o vetor chg[] contém um or exclusivo entre o valor novo e antigo e em caso de alteração entre<br>
os valores é copiado o valor de new[] para old[].<br>
O texto acima está muito confuso, corrigi rapidamente<br>
No código C gerado, os vetores in_data[] e out_data[] contêm os sinais de<br>
entrada e saída, respectivamente. No caso de circuitos sequênciais, o valor do status é inserido<br>
no primeiro (índice 0). A funçãoentão lerá os valores in_data[] e escreverá os resultados do qual?<br>
processamento em out_data[]. Ao final da operações os valores de estado são passado para<br>
out_data[].<br>
Conforme especificado e seguindo os parametros da ferramenta, a mesma realiza a<br>
tradução, mantendo inalterado qualquer fragmento de código que esteja comentado, neste caso,<br>
as assertivas presentes no código VHDL permanecem inalteradas, sendo utilizadas na próxima<br>
etapa do método proposto.<br>
4.4 Instrumentação de código<br>
As assertivas após a tradução permanecem comentadas, sendo necessário prepara-lás, ou<br>
seja traduzi-las, para verificação posterior do código na linguagem em C. Com isso é necessário<br>
uma instrumentação do código para prover suporte as assertivas traduzidas para análise, conforme<br>
apresentado na Figura 16, etapa C.<br>
Todas as etapas da instrumentação são realizados sobre o código C já traduzido. O passo<br>
inicial da instrumentação é a adição da macros no inicio do código C com as definição das<br>
assertivas a serem utilizadas. Na Figura 22 são apresentados os macros utilizadas no código C. A<br>
Linha 1 da figura corresponde a mensagem de erro a ser apresentada e a Linha 2 corresponde<br>
ao modelo da assertiva e a chamanda da macro definida na Linha 1 em caso de falha. Estas<br>
definições para as assertivas também podem ser utilizadas no código C traduzidos sem o uso do<br>
ESBMC.<br>
Figure 22 – Macros das assertivas implementadas em linguagem C<br>
1 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r ,M, __FILE__ , __LINE__ , # # __VA_ARGS__ )<br>
2 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
Fonte: Própria.<br>
O passo seguinte é a identificação das assertivas comentadas ao longo do corpo do<br>
código traduzido, utilizando o exemplo da Figura 23. As assertivas são identificadas através<br>
das tags @c2vhdl:ASSERT e @c2vhdl:END e a busca é realizado através destas tags. Ao<br>
ser encontrado a tag @c2vhdl:ASSERT, é realizado um loop até que seja encontrada a tag<br>
Chapter 4. MÉTODO PROPOSTO 46<br>
@c2vhdl:END e com isso toda a assertiva inserida possa ser passada a função de busca das<br>
informações da assertiva contidas entre as tags apresentadas.<br>
Com os dados das assertivas obtidos é realizado a busca da condição, mensagem e<br>
severidade através dos comandos ??assert, ??report e ??severity respectivamente.<br>
Estas informações são encontradas através do uso e uma Regex no código e que são adicionadas<br>
ao código C seguindo o modelo definido na macro. Este processo é repetido até outra assertiva<br>
ser encontrada ou caso chegue ao fina do código C.<br>
Com a função __ESBMC_assume() ocorre processo semelhante ao das assertivas.<br>
Utilizando novamente uma regex que realiza a busca por esta função no código e é retirado o<br>
comentário da mesma, desta forma a mesma passa a esta acessivél para o ESBMC, visto que a<br>
declaração da mesma já segue o modelo padrão a ser utilizado pelo ESBMC.<br>
Durante a instrumentação de código também é realizado a entrada de sinais não de-<br>
terministicos para variaveis não inicializadas ou argumentos de funções do código C gerado<br>
da tradução, utilizando a função __VERIFIER_nondet_int(). Esta função é utilizada em<br>
todas as variaveis de entrada e também nos sinais criados ao longo da arquitetura. Desta forma,<br>
todas as variavéis necessárias são inicializadas para verificação.<br>
Explicar o funcionamento do nondet com o ESBMC<br>
Em outras palavras, na instrumentação de código é realizado a traduçao das assertivas do<br>
modelo utilizado no código VHDL para para o modelo utilizado em linguagem C, além como de<br>
outras funções que possam ser utilizados pelo VHDL. Ao final da instrumentação o código C<br>
fica disponivel para que possa ser dado como entrada para outras ferramentas de verificação de<br>
código e não apenas o ESBMC.<br>
4.5 Verificação de assertivas usando Model Checker<br>
O model checker adotado no desenvolvimento de método é o ESBMCna versão 3.0.0 referência<br>
e conforme explicado na subsection 2.2.3, esta ferramenta recebe como entrada um código C<br>
ou C++ e devido a isso foi escolhida neste projeto. Nesta seção será apresentado a etapa D do apresentar<br>
outras<br>
vanta-<br>
gens<br>
métod proposto na Figura 16.<br>
Para a verificação, a primeira etapa é a identificação das assertivas no código C analisado,<br>
para isso é utilizado uma opção do ESBMC (??show-claims), mais especificamente as<br>
assertivas instrumentadas no código C analisado. Cada assertiva é identificada através de uma<br>
numeração de acordo com a ordem de busca do código analisado. Cada assertiva encontrada é<br>
armazenada para que seja realizada uma análise individual de cada claim, ou seja, assertiva.<br>
Chapter 4. MÉTODO PROPOSTO 47<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas.<br>
1 VAR<br>
2 c o n t a d o r : i n t e i r o<br>
3 c l a i m : l i s t a<br>
4 c l a i m _ s t r i n g : s t r i n g<br>
5<br>
6 FUNCAO c a l l _ e s b m c : a r q u i v o<br>
7 c o n t a d o r &lt;?0<br>
8 INICIO<br>
9 s a i d a &lt;?f un ca o de g e r a c a o das c l a i m s p e l o ESBMC<br>
10 ENQUANTO c o n t a d o r &lt; s a i d a FACA<br>
11 c o n t a d o r +=2<br>
12 r e g e x p a r a p r o c u r a r c l a i m e numeracao da c l a i m<br>
13 SE e n c o n t r a r c l a i m ENTAO<br>
14 r e g e x p a r a p r o c u r a r a p a l a v r a " a s s e r t i o n "<br>
15 SE e n c o n t r a r a p a l a v r a " a s s e r t i o n " ENTAO<br>
16 c o n t a d o r +=1<br>
17 A d i c i o n a a numeracao da c l a i m na l i s t a<br>
18 FIM?SE<br>
19 FIM?SE<br>
20 FIM?ENQUANTO<br>
21 FIM?FUNCAO<br>
Fonte: Própria.<br>
Na Linha 9 da Figura 24 é apresentado a chamada da ferramenta ESBMC que ocorre e<br>
através da opção ??show-claims lista todas as claims presentes no texto, como apresentado<br>
na Figura 25. Como o ESBMC infere de forma automatica assertivas a serem verificadas no<br>
código. Visando isolar somente as assertivas instrumentadas pelo método proposto, juntamente<br>
com a opção –show-claims é utilizado as opções:<br>
• ??no-pointer-check: para não realizar a checagem de ponteiros no código;<br>
• ??no-div-by-zero-check: para não realizar a checagem de divisões por zero no<br>
código; e<br>
• ??no-bounds-check: para não realizar a checagem de array bounds no código.<br>
Chapter 4. MÉTODO PROPOSTO 48<br>
Figure 25 – Imagem de claims contendo assertivas.<br>
Fonte:Própria<br>
Após a listagem das claims com assertivas ser gerada, outra função, indicada na Figura 26,<br>
é chamada para verificação de cada claim individualmente. Para cada claim, ocorre a chamada do<br>
ESBMC, utilizando as opções ??no-pointer-check, ??no-div-by-zero-check e<br>
??no-bounds-check, juntamente com a opção ??unwind em que realiza o número de<br>
desdobramentos dos laços no código analisado.<br>
Contudo, dependendo da complexidade da assertiva, faz-se necessário aumentar o número<br>
de desdobramentos que, por padrão são dez, conforme análise experimentais. A função é chamada<br>
na Linha 11 da Figura 26 e após a analise da claim é realizado a busca do resultado e exibição<br>
caso seja uma propriedade violada.<br>
Desta forma o ESBMC realiza apenas a checagem necessária dentro da assertiva, evitando<br>
que outros parâmetros sejam verificados, sem a devida necessidade do mesmo. Ao final de todos<br>
os desdobramentos é apresentado o resultado, apresentado na Figura 27, sendo positiva (sem<br>
erros) ou negativa (com violação de propriedades), dependendo da assertiva e do código analisado.<br>
Este processo se repete até a lista de assertivas ser finalizada.<br>
Chapter 4. MÉTODO PROPOSTO 49<br>
Figure 26 – Pseudocódigo da função de análise das claims.<br>
1 VAR<br>
2 c o n t a d o r 1 : i n t e i r o<br>
3 c o n t a d o r 2 : i n t e i r o<br>
4 r e s u l t a d o : l i s t a<br>
5<br>
6 FUNCAO esbmc_c la ims : l i s t a , a r q u i v o<br>
7 c o n t a d o r 1 &lt;?0<br>
8 c o n t a d o r 2 &lt;?0<br>
9 busca p e l o nome da fu nc a o no a r q u i v o<br>
10 ENQUANTO c o n t a d o r &lt; l i s t a FACA<br>
11 s a i d a &lt;?Execu ta comando de a n a l i s e da c l a i m<br>
numerada na l i s t a<br>
12 ENQUANTO c o n t a d o r 2 &lt; s a i d a<br>
13 Regex busca se a p r o p r i e d a d e f o i v i o l a d a<br>
14 SE p r o p r i e d a d e f o i v i o l a d a ENTAO<br>
15 Pu la p a r a l i n h a da v i o l a ç ã o<br>
16 A d i c i o n a o e r r o ao r e s u l t a d o<br>
17 FIM?SE<br>
18 FIM?ENQUANTO<br>
19 FIM?ENQUANTO<br>
20 FIM?FUNCAO<br>
Fonte: Própria.<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta.<br>
Fonte:Própria<br>
Ajustar os códigos, alguns estao muito grandes e com trechos desnecessário, não foi<br>
citado o link do repo da ferramenta<br>
Chapter 4. MÉTODO PROPOSTO 50<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C.<br>
1 void u l a _ t c c ( i n t i n _ d a t a [ ] , i n t o u t _ d a t a [ ] )<br>
2 {<br>
3 i n t _ i _ =0;<br>
4 i n t _c on t_ ;<br>
5 enum s e g n a l e {A, B , B i n v e r t i d o , Op1 , Op2 , R e s u l t a d o , and_po r t , o r _ p o r t ,<br>
6 x o r _ p o r t , mux2x1 , _MAX_} ;<br>
7 i n t o l d [_MAX_ ] ;<br>
8 i n t new [_MAX_ ] ;<br>
9 i n t chg [_MAX_ ] ;<br>
10 new [A] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
11 new [B] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
12 new [ B i n v e r t i d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
13 new [ Op1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
14 new [ Op2 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
15 new [ R e s u l t a d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
16 new [ a n d _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
17 new [ o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
18 new [ x o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
19 new [ mux2x1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
20<br>
21 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
22 {<br>
23 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
24 }<br>
25 new [A] = i n _ d a t a [ 1 ] ;<br>
26 new [B] = i n _ d a t a [ 2 ] ;<br>
27 new [ B i n v e r t i d o ] = i n _ d a t a [ 3 ] ;<br>
28 new [ Op1 ] = i n _ d a t a [ 4 ] ;<br>
29 new [ Op2 ] = i n _ d a t a [ 5 ] ;<br>
30<br>
31 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
32 {<br>
33 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
34 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
35 }<br>
36<br>
37 do {<br>
38 _ co n t _ =0;<br>
39 /? S t a r t o f T r a n s l a t i o n ? /<br>
40<br>
41 /? p0 : ? /<br>
42 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
43 /?PORTA AND ? /<br>
44 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
45 \ \ __ESBMC_assume ( o l d [A] = 1) ;<br>
46 \ \ __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
47 new [ a n d _ p o r t ] = 1 ;<br>
48 }<br>
49 e l s e {<br>
50 new [ a n d _ p o r t ] = 0 ;<br>
51 }<br>
52 /?PORTA OR ? /<br>
53 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
54 new [ a n d _ p o r t ] = 0 ;<br>
55 }<br>
56 e l s e {<br>
57 new [ a n d _ p o r t ] = 1 ;<br>
58 }<br>
59 /?PORTA XOR ? /<br>
60 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
61 new [ x o r _ p o r t ] = 0 ;<br>
62 }<br>
63 e l s e i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==1) ) {<br>
64 new [ x o r _ p o r t ] = 0 ;<br>
65 }<br>
66 e l s e {<br>
67 new [ x o r _ p o r t ] = 1 ;<br>
68 }<br>
69 /? INVERSOR ? /<br>
70 i f ( ( o l d [ B i n v e r t i d o ]==0) ) {<br>
71 i f ( chg [B ] ) {<br>
72 new [ mux2x1 ]= o l d [B ] ;<br>
73 }<br>
74 }<br>
75 e l s e {<br>
76 i f ( chg [B ] ) {<br>
77 new [ mux2x1 ]=~ o l d [B ] ;<br>
78 }<br>
79 }<br>
80 /?MUX4X1 ? /<br>
81 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
82 i f ( chg [ a n d _ p o r t ] ) {<br>
83 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
84 \ \ @c2vhdl : ASSERT<br>
85 \ \ a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
86 \ \ r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
87 \ \ s e v e r i t y ERROR;<br>
88 \ \ @c2vhdl :END<br>
89 }<br>
90 }<br>
91 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
92 i f ( chg [ o r _ p o r t ] ) {<br>
93 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
94 }<br>
95 }<br>
96 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
97 i f ( chg [ x o r _ p o r t ] ) {<br>
98 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
99 }<br>
100 }<br>
101 }<br>
102<br>
103 /? End o f T r a n s l a t i o n ? /<br>
104 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
105 {<br>
106 i f ( new [ _ i _ ] ! = o l d [ _ i _ ] ) _ con t_ =1;<br>
107 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
108 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
109 }<br>
110 } whi le ( _c on t_ ) ;<br>
111<br>
112 new [A] &= 0X01 ;<br>
113 new [B] &= 0X01 ;<br>
114 new [ B i n v e r t i d o ] &= 0X01 ;<br>
115 new [ Op1 ] &= 0X01 ;<br>
116 new [ Op2 ] &= 0X01 ;<br>
117 new [ R e s u l t a d o ] &= 0X01 ;<br>
118 new [ a n d _ p o r t ] &= 0X01 ;<br>
119 new [ o r _ p o r t ] &= 0X01 ;<br>
120 new [ x o r _ p o r t ] &= 0X01 ;<br>
121 new [ mux2x1 ] &= 0X01 ;<br>
122<br>
123 o u t _ d a t a [ 0 ] = 0 ; _ i _ =0;<br>
124 o u t _ d a t a [ 0 ] | = new [A] &lt;&lt; _ i _ ; _ i _ +=1;<br>
125 o u t _ d a t a [ 0 ] | = new [B] &lt;&lt; _ i _ ; _ i _ +=1;<br>
126 o u t _ d a t a [ 0 ] | = new [ B i n v e r t i d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
127 o u t _ d a t a [ 0 ] | = new [ Op1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
128 o u t _ d a t a [ 0 ] | = new [ Op2 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
129 o u t _ d a t a [ 0 ] | = new [ R e s u l t a d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
130 o u t _ d a t a [ 0 ] | = new [ a n d _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
131 o u t _ d a t a [ 0 ] | = new [ o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
132 o u t _ d a t a [ 0 ] | = new [ x o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
133 o u t _ d a t a [ 0 ] | = new [ mux2x1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
134<br>
135 o u t _ d a t a [ 1 ] = new [ R e s u l t a d o ] ;<br>
136 }<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 51<br>
Figure 23 – Código com assertivas traduzida para linguagem C<br>
1 # inc lude &lt; s t d i o . h&gt;<br>
2 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r , M , __FILE__ , __LINE__ , ##<br>
__VA_ARGS__ ) / / Update t o p r i n t t h e t r a c e<br>
3 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
4<br>
5 . . .<br>
6<br>
7 do {<br>
8 _co n t _ =0;<br>
9 /? S t a r t o f T r a n s l a t i o n ? /<br>
10 chg [A] = __VERIFIER_nondet_int ( ) ;<br>
11 chg [B] = __VERIFIER_nondet_int ( ) ;<br>
12 chg [ B i n v e r t i d o ] = __VERIFIER_nondet_int ( ) ;<br>
13 chg [ Op1 ] = __VERIFIER_nondet_int ( ) ;<br>
14 chg [ a n d _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
15 chg [ R e s u l t a d o ] = __VERIFIER_nondet_int ( ) ;<br>
16 chg [ o r _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
17 chg [ mux2x1 ] = __VERIFIER_nondet_int ( ) ;<br>
18<br>
19 /? p0 : ? /<br>
20 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
21 /?PORTA AND ? /<br>
22 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
23 __ESBMC_assume ( o l d [A] = 1) ;<br>
24 __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
25 new [ a n d _ p o r t ] = 1 ;<br>
26 }<br>
27 e l s e {<br>
28 new [ a n d _ p o r t ] = 0 ;<br>
29 }<br>
30<br>
31 . . .<br>
32<br>
33 /?MUX4X1 ? /<br>
34 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
35 i f ( chg [ a n d _ p o r t ] ) {<br>
36 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
37 __MY_asser t ( new [ R e s u l t a d o ] == 1 , "O r e s u l t a d o é d i f e r e n t e de 0 " ) ;<br>
38 }<br>
39 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
40 i f ( chg [ o r _ p o r t ] ) {<br>
41 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
42 }<br>
43 }<br>
44 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
45 i f ( chg [ x o r _ p o r t ] ) {<br>
46 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
47 }<br>
48 }<br>
49 }<br>
50<br>
51 /? End o f T r a n s l a t i o n ? /<br>
52 . . .<br>
Fonte: Própria.<br>
52<br>
5 CRONOGRAMA<br>
53<br>
6 CONSIDERAÇÕES PARCIAIS E<br>
TRABALHOS FUTUROS<br>
O trabalho aborda <span class='f1 c_30' id='c_30_1' href='#c_30_2' cs_f='.c_30' >o desenvolvimento de um</span> método para análise de circuitos lógicos de-<br>
scrito em VHDL através da aplicação de técnica de transformação de código e a técnica Bounded<br>
Model Cheking. Este método tem como objetivo de explorar os estados alcanç alcançáveis no<br>
circuito, e dessa forma identificar erros que possam resutar em mal funcionamento do sistema.<br>
Entre as dificuldade encontradas, a principal esta ligada a etapa de tradução de código.<br>
Devido a ferramenta utilizada inicialmente conter diversas limitações, a mesma diminui a eficácia<br>
da ferramenta, pois a quantidade de estruturas que podem ser utilizadas é limitada e com isso<br>
limitando também o processo de criação de protótipos.<br>
Os trabalhos futuros é necessário buscar uma nova ferramenta ou método de tradução<br>
que tenha uma gama maior de tradução, seja em estruturas ou palavras reservadas,deste forma<br>
o método desenvlvido torna-se mais eficiente e gerando uma menor intervenção do usuário no<br>
código VHDL. A melhoria na tradução de código também beneficia ageração das assertivas<br>
automáticamente, pois com uma gama maior de estruturas suportadas, mais assertivas podem ser<br>
geradas.<br>
Além disso a geração automática das assertivas é Outro ponto abordado, já sitado anterior-<br>
mente, é a geração automática das assertivas, visto que na estapa atual ainda nõ foi implementado.<br>
Este recuros visa da liberdade ao desenvolvedor promovendo de maneira automática os teste<br>
sobre o código, não necessitando que uma intervenção, tornando a inserção manual apenas em<br>
casos especificos de testes.<br>
54<br>
BIBLIOGRAPHY<br>
ABE, J. Introducao a Logica Para a Ciencia Da Computacao. Arte & Ciência, 2002. ISBN<br>
9788574730455. Disponível em: &lt;https://books.google.com.br/books?id=AgBJdjoNPwUC&gt;.<br>
ACM. 2018. Acessado em: 01 de março de 2018. Disponível em: &lt;http://dl.acm.org/&gt;.<br>
AHO, A. V.; SETHI, R.; ULLMAN, J. D. Compilers: principles, techniques, and tools. [S.l.]:<br>
Addison-wesley Reading, 2007. v. 2.<br>
ALLEN, F. E. Control flow analysis. In: ACM. ACM Sigplan Notices. [S.l.], 1970. v. 5, n. 7, p.<br>
1–19.<br>
BAIER, C.; KATOEN, J.-P.; LARSEN, K. G. Principles of model checking. [S.l.]: MIT press,<br>
2008.<br>
BARA, A. et al. Formal verification of timed vhdl programs. In: IET. FDL. [S.l.], 2010. p.<br>
80–85.<br>
BASILI, V. R.; CALDIERA, G.; ROMBACH, H. D. Experience factory. Encyclopedia of<br>
software engineering, Wiley Online Library, 1994.<br>
BENSALEM, S.; LAKHNECH, Y. Automatic generation of invariants. Formal Methods in<br>
System Design, Springer, v. 15, n. 1, p. 75–92, 1999.<br>
BIERE, A. The aiger and-inverter graph (aig) format. Available at http://fmv.jku.at/aiger, 2016.<br>
BIOLCHINI, J. et al. Systematic review in software engineering. System Engineering and<br>
Computer Science Department COPPE/UFRJ, Technical Report ES, v. 679, n. 05, p. 45, 2005.<br>
BOULE, M.; ZILIC, Z. Incorporating efficient assertion checkers into hardware emulation. In:<br>
IEEE. Computer Design: VLSI in Computers and Processors, 2005. ICCD 2005. Proceedings.<br>
2005 IEEE International Conference on. [S.l.], 2005. p. 221–228.<br>
BOULE, M.; ZILIC, Z. Efficient automata-based assertion-checker synthesis of seres for<br>
hardware emulation. In: IEEE COMPUTER SOCIETY. Proceedings of the 2007 Asia and South<br>
Pacific Design Automation Conference. [S.l.], 2007. p. 324–329.<br>
BRAYTON, R.; MISHCHENKO, A. Abc: An academic industrial-strength verification tool. In:<br>
SPRINGER. Computer Aided Verification. [S.l.], 2010. p. 24–40.<br>
B.V. 2018. Acessado em 1 de março de 2018. Disponível em: &lt;http://www.sciencedirect.com/&gt;.<br>
CABODI, G. et al. Hardware model checking competition 2014: an analysis and comparison of<br>
solvers and benchmarks. Journal on Satisfiability, Boolean Modeling and Computation, v. 9, p.<br>
135–172, 2016.<br>
CAPPELATTI, D. Praticando VHDL. Editora Feevale, 2010. ISBN 9788577171200. Disponível<br>
em: &lt;https://books.google.com.br/books?id=z4\_CYog\_UskC&gt;.<br>
Bibliography 55<br>
CHRISTEN, E.; BAKALAR, K. Vhdl-ams-a hardware description language for analog and<br>
mixed-signal applications. IEEE Transactions on Circuits and Systems II: Analog and Digital<br>
Signal Processing, IEEE, v. 46, n. 10, p. 1263–1272, 1999.<br>
CHU, P. P. RTL hardware design using VHDL: coding for efficiency, portability, and scalability.<br>
[S.l.]: John Wiley & Sons, 2006.<br>
CLARKE, E. et al. Verification of hybrid systems based on counterexample-guided abstraction<br>
refinement. In: SPRINGER. TACAS. [S.l.], 2003. v. 3, p. 192–207.<br>
CLARKE, E. M. The birth of model checking. In: 25 Years of Model Checking. [S.l.]: Springer,<br>
2008. p. 1–26.<br>
CLARKE, E. M.; GRUMBERG, O.; LONG, D. E. Model checking and abstraction. ACM<br>
transactions on Programming Languages and Systems (TOPLAS), ACM, v. 16, n. 5, p.<br>
1512–1542, 1994.<br>
CORDEIRO, L.; FISCHER, B.; MARQUES-SILVA, J. Smt-based <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >bounded model checking</span> for<br>
embedded ansi-c software. IEEE Transactions on Software Engineering, IEEE, v. 38, n. 4, p.<br>
957–974, 2012.<br>
COUSOT, P.; COUSOT, R. A gentle introduction to formal verification of computer systems by<br>
abstract interpretation. [S.l.]: IOS Press, 2010.<br>
DAHAN, A. et al. Combining system level modeling with assertion based verification. In: Sixth<br>
international symposium on quality electronic design (isqed’05). [S.l.: s.n.], 2005. p. 310–315.<br>
ISSN 1948-3287.<br>
D’SILVA, V.; KROENING, D.; WEISSENBACHER, G. A survey of automated techniques<br>
for formal software verification. IEEE Transactions on Computer-Aided Design of Integrated<br>
Circuits and Systems, IEEE, v. 27, n. 7, p. 1165–1178, 2008.<br>
ELSEVIER. 2017. Acessado em: 01 março 2018. Disponível<br>
em: &lt;https://www.elsevier.com/__data/assets/pdf_file/0007/69451/<br>
0597-Scopus-Content-Coverage-Guide-US-LETTER-v4-HI-singles-no-ticks.pdf&gt;.<br>
G1. Acidente foi provocado por falha em circuito eletrônico, diz se-<br>
cretário. 2012. Disponível em: &lt;http://g1.globo.com/sao-paulo/noticia/2012/05/<br>
acidente-foi-provocado-por-falha-em-circuito-eletronico-diz-secretario.html&gt;.<br>
GUGLIELMO, G. D. et al. On the use of assertions for embedded-software dynamic verification.<br>
In: IEEE. Design and Diagnostics of Electronic Circuits & Systems (DDECS), 2012 IEEE 15th<br>
International Symposium on. [S.l.], 2012. p. 330–335.<br>
GUPTA, A. Formal hardware verification methods: A survey. In: SPRINGER. Computer-Aided<br>
Verification. [S.l.], 1992. p. 5–92.<br>
HALDER, A.; VENKATESWARLU, A. A study of petri nets modeling analysis and simulation.<br>
Department of Aerospace Engineering Indian Institute of Technology Kharagpur, India, 2006.<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Interpolation and symbol elimination in vampire.<br>
Automated Reasoning, Springer, p. 188–195, 2010.<br>
Bibliography 56<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Case studies on invariant generation using a<br>
saturation theorem prover. Advances in Artificial Intelligence, Springer, p. 1–15, 2011.<br>
IDOETA, I. V.; CAPUANO, F. G. Elementos de eletrônica digital. [S.l.]: Livros Erica, 1982.<br>
IEC/IEEE International Standard - Behavioural languages - Part 1-1: VHDL Language<br>
Reference Manual. IEC 61691-1-1:2011(E) IEEE Std 1076-2008, p. 1–648, May 2011.<br>
IEEE. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http://ieeexplore.ieee.org/<br>
Xplore/home.jsp&gt;.<br>
IEEE Standard for Property Specification Language (PSL). IEEE Std 1850-2010 (Revision of<br>
IEEE Std 1850-2005), p. 1–182, April 2010.<br>
IEEE Standard for Verilog Hardware Description Language. IEEE Std 1364-2005 (Revision of<br>
IEEE Std 1364-2001), p. 1–560, 2006.<br>
KITCHENHAM, B. Procedures for performing systematic reviews. Keele, UK, Keele University,<br>
v. 33, n. 2004, p. 1–26, 2004.<br>
KITCHENHAM, B. et al. Systematic literature reviews in software engineering–a systematic<br>
literature review. Information and software technology, Elsevier, v. 51, n. 1, p. 7–15, 2009.<br>
KNOOP, J.; RÜTHING, O.; STEFFEN, B. Partial dead code elimination. [S.l.]: ACM, 1994.<br>
v. 29.<br>
KOSCIANSKI, A.; SOARES, M. dos S. Qualidade de Software - 2a Edição: Aprenda as<br>
metodologias e técnicas mais modernas <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >para o desenvolvimento de</span> software. Novatec,<br>
2007. ISBN 9788575221129. Disponível em: &lt;https://books.google.com.br/books?id=<br>
O9aWoUq6L88C&gt;.<br>
KROPF, T. Introduction to Formal Hardware Verification. Springer Berlin Heidelberg,<br>
2013. ISBN 9783662038093. Disponível em: &lt;https://books.google.com.br/books?id=<br>
7ImrCAAAQBAJ&gt;.<br>
MAFRA, S. N.; TRAVASSOS, G. H. Estudos primarios e secundarios apoiando a busca por<br>
evidencia em engenharia de software. Relatorio Tecnico, RT-ES, v. 687, n. 06, 2006.<br>
MUKHERJEE, R. et al. Unbounded safety verification for hardware using software analyzers.<br>
In: EDA CONSORTIUM. Proceedings of the 2016 Conference on Design, Automation & Test in<br>
Europe. [S.l.], 2016. p. 1152–1155.<br>
MUKHERJEE, R.; TAUTSCHNIG, M.; KROENING, D. v2c–a verilog to c translator. In:<br>
SPRINGER. International Conference on Tools and Algorithms for the Construction and<br>
Analysis of Systems. [S.l.], 2016. p. 580–586.<br>
MURATA, T. Petri nets: Properties, analysis and applications. Proceedings of the IEEE, IEEE,<br>
v. 77, n. 4, p. 541–580, 1989.<br>
RAMESH, U. B. K.; SENTILLES, S.; CRNKOVIC, I. Energy management in embedded<br>
systems: Towards a taxonomy. In: IEEE PRESS. Proceedings of the First International<br>
Workshop on Green and Sustainable Software. [S.l.], 2012. p. 41–44.<br>
ROCHA, H. et al. Exploiting safety properties in <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >bounded model checking</span> for test cases<br>
generation of c programs. 2010.<br>
Bibliography 57<br>
ROCHA, H. et al. Model checking embedded c software using k-induction and invariants<br>
(extended version). arXiv preprint arXiv:1509.02471, 2015.<br>
ROCHA, H. O. et al. Verificacao de sistemas de software baseada em transformacoes de codigo<br>
usando <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >bounded model checking</span>. Universidade Federal do Amazonas, 2015.<br>
SARGENT, R. G. Verification and validation of simulation models. In: WINTER SIMULATION<br>
CONFERENCE. Proceedings of the 37th conference on Winter simulation. [S.l.], 2005. p.<br>
130–143.<br>
SEGER, C.-J. An introduction to formal hardware verification. [S.l.]: University of British<br>
Columbia, Department of Computer Science, 1992.<br>
SOMMERVILLE, I. Engenharia de software. PEARSON BRASIL, 2011. ISBN 9788579361081.<br>
Disponível em: &lt;https://books.google.com.br/books?id=H4u5ygAACAAJ&gt;.<br>
SONS, J. W. . 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http:<br>
//onlinelibrary.wiley.com/&gt;.<br>
SOUZA, J. Lógica para Ciência da Computação. Elsevier Brasil, 2017. ISBN 9788535278255.<br>
Disponível em: &lt;https://books.google.com.br/books?id=Ds2sCQAAQBAJ&gt;.<br>
SPRINGER. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;https:<br>
//link.springer.com/&gt;.<br>
SRIKANT, Y.; SHANKAR, P. The Compiler Design Handbook: Optimizations and<br>
Machine Code Generation. CRC Press, 2002. ISBN 9781420040579. Disponível em:<br>
&lt;https://books.google.com.br/books?id=0K\_jIsgyNpoC&gt;.<br>
THOMAS, D.; MOORBY, P. The Verilog R© Hardware Description Language. Springer<br>
US, 2008. ISBN 9780387853444. Disponível em: &lt;https://books.google.com.br/books?id=<br>
DxQGrz7q-SwC&gt;.<br>
TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L. Sistemas digitais: princípios e aplicações. [S.l.]:<br>
Prentice Hall, 2003. v. 8.<br>
TRAVASSOS, G. H. et al. An environment to support large scale experimentation in software<br>
engineering. In: IEEE. Engineering of Complex Computer Systems, 2008. ICECCS 2008. 13th<br>
IEEE International Conference on. [S.l.], 2008. p</div>
<!-- DIVISOR_DIV_CANDIDATE -->

<div class='divisor divisor-texto' id="cand__file6"><hr class='text-separator'><br>Input file: <a href='#'>main.pdf</a> (12773 chunks)<br>File found: <a href='https://www.passeidireto.com/arquivo/2297149/modulo-06-linguagens-de-descricaode-hardware-hdl-introducao' target='_blank'>https://www.passeidireto.com/arquivo/2297149/modulo-06-linguagens-de-descricaode-hardware-hdl-introducao</a> (791 chunks)<br><br>Chunks in common: 15<br>Similarity: 0.11%<br><br><div class='textInfo'>The following is the content of the document <br>&nbsp;"<b>main.pdf</b>". <br>The terms in red were found in the document <br>&nbsp;"<b>https://www.passeidireto.com/arquivo/2297149/modulo-06-linguagens-de-descricaode-hardware-hdl-introducao</b>".<br><hr class='text-separator'></div>  UNIVERSIDADE FEDERAL DE RORAIMA<br>
PRÓ-REITORIA DE ENSINO E EXTENSÃO<br>
DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código<br>
com Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau<br>
de Bacharel em Ciência da Computação.<br>
Orientador: Dr. Herbert Oliveira Rocha<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau de<br>
Bacharel em Ciência da Computação.<br>
Defendido em 06 de março de 2017 e<br>
aprovado pela seguinte banca examinadora:<br>
Prof. Dr. Herbert Oliveira Rocha<br>
Orientador / Curso de Ciência da Computação -<br>
UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Fazer dedicatória<br>
ACKNOWLEDGEMENTS<br>
Fazer agradecimentos!!<br>
Procurar frase massa!!<br>
ABSTRACT<br>
Fazer resumo!!<br>
Palavras-chaves: ??<br>
ABSTRACT<br>
Fazer Abstract!!<br>
Key-words: ??<br>
LISTA DE FIGURAS<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog. . . . . . . . . . . . . . . . 15<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL. . . . . . . . . . . . . . . . . 16<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade. . . . . . . . . . . . . . . 17<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL. . . . . . . . . . . . . . . . 17<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1. . . . . . . . . . 18<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas. . . . . . . . . 18<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas. . . . . . . . . . 19<br>
Figure 8 – Arvore de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
Figure 9 – Rede de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL. . . . . . . . . . . . . . . . . 27<br>
Figure 11 – Trecho de código em VHDL representando porta AND. . . . . . . . . . . . 28<br>
Figure 12 – Trecho de código traduzido para linguagem C. . . . . . . . . . . . . . . . . 29<br>
Figure 13 – Exemplo de bloco basico de código. . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 14 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 15 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 31<br>
Figure 16 – Ciclo da ferramenta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR. . . . . . . 41<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR. . . . . . . . . . . . . . 42<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume(). . . . . . . . . . . 43<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19. . . . . . . . . . . . . . . 44<br>
Figure 22 – Macros das assertivas implementadas em linguagem C . . . . . . . . . . . . 45<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas. . . . . . . 47<br>
Figure 25 – Imagem de claims contendo assertivas. . . . . . . . . . . . . . . . . . . . . 48<br>
Figure 26 – Pseudocódigo da função de análise das claims. . . . . . . . . . . . . . . . . 49<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta. . . . . . . . . . . . . . 49<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C. . . . . . . . . . . . . 50<br>
Figure 23 – Código com assertivas traduzida para linguagem C . . . . . . . . . . . . . . 51<br>
LISTA DE TABELAS<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM . . . . . . . . . . . . . . . 33<br>
SUMÁRIO<br>
1 INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11<br>
1.1 Definição do problema . . . . . . . . . . . . . . . . . . . . . . . . . . . 12<br>
1.2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13<br>
1.3 Organização do trabalho . . . . . . . . . . . . . . . . . . . . . . . . . 14<br>
2 CONCEITOS E DEFINIÇÕES . . . . . . . . . . . . . . . . . . . . . . 15<br>
2.1 Linguagens de descrição de hardware . . . . . . . . . . . . . . . . . 15<br>
2.1.1 <span class='f1 c_14' id='c_14_1' href='#c_14_2' cs_f='.c_14' >VHSIC Hardware Description Language</span> - VHDL . . . . . . . . . . . . . 16<br>
2.1.2 Portas lógicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18<br>
2.2 Verificação de sistemas . . . . . . . . . . . . . . . . . . . . . . . . . . 19<br>
2.2.1 Diagrama de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.2 Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.3 Bounded Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . 21<br>
2.2.4 Redes de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22<br>
2.2.5 Verificação de hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
2.2.6 Verificação formal de software . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.7 Lógica proposicional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.8 Linguagem de especificação de propriedades . . . . . . . . . . . . . . 26<br>
2.2.9 Verificação baseada em assertivas . . . . . . . . . . . . . . . . . . . . 26<br>
2.2.10 Propriedades de segurança . . . . . . . . . . . . . . . . . . . . . . . . 27<br>
2.3 Técnicas de compiladores . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.1 Transformações de código . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2 Otimização de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2.1 Grafo Acliclico Direcional - GAD . . . . . . . . . . . . . . . . . . . . . . . . 29<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.3 Eliminção de código morto . . . . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.4 Análise do <span class='f1 c_11' id='c_11_1' href='#c_11_2' cs_f='.c_11' >fluxo de dados</span> . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
2.3.2.5 Gerador de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
3 TRABALHOS CORRELATOS . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1 Revisão sistemática . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1.1 Planejamento da Revisão Sistemática . . . . . . . . . . . . . . . . . . 33<br>
3.1.1.1 Procedimentos de Seleção e Critérios . . . . . . . . . . . . . . . . . . . . 35<br>
3.2 Revisão da literatura . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.1 V2c-A verilog to C translator . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.2 Unbounded safety verification for hardware using software analyzers . 37<br>
3.2.3 Formal verification of timed VHDL programs . . . . . . . . . . . . . . . 38<br>
3.2.4 On the use of assertions for embedded-software dynamic verification 38<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation . . 39<br>
4 MÉTODO PROPOSTO . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.1 Visão geral do método . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.2 Preprocessamento do VHDL e inserção de assertivas . . . . . . . 42<br>
4.3 Tradução de código VHDL para a linguagem C . . . . . . . . . . . . 43<br>
4.4 Instrumentação de código . . . . . . . . . . . . . . . . . . . . . . . . 45<br>
4.5 Verificação de assertivas usando Model Checker . . . . . . . . . . 46<br>
5 CRONOGRAMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52<br>
6 CONSIDERAÇÕES PARCIAIS E TRABALHOS FUTUROS . . . . . 53<br>
BIBLIOGRAPHY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54<br>
11<br>
1 INTRODUÇÃO<br>
A complexidade de sistemas computacionais cresce exponencialmente. Muitas compan- Exemplificar<br>
este<br>
cresci-<br>
mento.<br>
hias e organizações estão rotineiramente lidando com software que contém milhares de linhas<br>
de código, escritos por diferentes pessoas, que usam linguagens distintas, ferramentas, estilos e<br>
hardware projetados de diversas formas e combinações (HODER et al., 2011).<br>
No contexto de sistemas compostos de hardware e software, tem-se os sistemas embarca-<br>
dos (SE) que são dispositivos semicondutores com software integrados, os quais se conectam<br>
a outros dispositivos. Usualmente, o principal propósito dos SE é o controle e provimento de<br>
informações para uma função específica (RAMESH et al., 2012).<br>
Os SE são extremamente interativos com seu ambiente, operam geralmente em tempo real<br>
e estão disponíveis continuamente. No entanto, estes sistemas, por possuírem um curto espaço<br>
de tempo para a liberação do produto ao mercado, precisam ser desenvolvidos rapidamente e<br>
atingir um alto nível de qualidade, mas, devido a esta necessidade, os programadores podem<br>
cometer enganos durante a fase de desenvolvimento destes sistemas.<br>
Os SE têm se proliferado em partes consideráveis das atividades do nosso cotidiano,<br>
com a característica de possuir grande quantidade de complexidade e diversidade. Devido a esta<br>
complexidade, erros podem passar despercebidos, causando não apenas penalidades econômicas<br>
e/ou fracassos do produto no mercado, mas principalmente o risco de perda de vidas humanas<br>
(CABODI et al., 2016). Como, por exemplo, o acidente noticiado no (G1, 2012), no qual, de<br>
acordo com o secretário de transportes, uma falha na placa do circuito eletrônico responsável<br>
pelo controle de velocidade dos trens ocasionou a colisão entre duas composições na estação de<br>
metrô de São Paulo.<br>
Segundo ROCHA et al.2015b, para se obter um alto nível de qualidade no desenvolvi-<br>
mento dos sistemas de hardware e software, a execução desses sistemas deve ser controlada e da<br>
mesma forma deve-se buscar meios de garantir que as propriedades definidas sejam atingidas. Por<br>
exemplo, a partir do conhecimento prévio do modo de implementação de determinado hardware,<br>
é possível utilizá-lo de forma mais eficiente. Neste sentido, diversas estratégias de verificação e<br>
de teste estão sendo pesquisadas e aplicadas para garantir a qualidade do software e hardware<br>
(HODER et al., 2010; ROCHA et al., 2010; BRAYTON; MISHCHENKO, 2010; CORDEIRO et<br>
al., 2012; CABODI et al., 2016).<br>
Por este motivo, com o intuito de analisar e otimizar a descrição dos circuitos digitais,<br>
tem-se utilizado as linguagens de descrição <span class='f1 c_9' id='c_9_1' href='#c_9_2' cs_f='.c_9' >de hardware (HDL</span>). Estas se diferem das linguagens<br>
de programação por conseguirem gerar execuções não apenas sequenciais, como também con-<br>
correntes ou paralelas (CHU, 2006). Neste contexto, a <span class='f1 c_14' id='c_14_1' href='#c_14_2' cs_f='.c_14' >VHSIC Hardware Description Language</span><br>
Chapter 1. INTRODUÇÃO 12<br>
(VHDL) é uma das linguagens de descrição de hardware mais utilizadas atualmente. A descrição<br>
em VHDL pode ser em vários níveis de abstração, sendo o mais alto o nível comportamen-<br>
tal que permite a descrição do circuito através de loops e processos, definido-o na forma de<br>
algoritmo. Como características das linguagens de descrição, o VHDL permite declarações se-<br>
quenciais ou concorrentes onde as declarações continuam ativas e sua ordem torna-se irrelevante<br>
(CAPPELATTI, 2010).<br>
Aliada à linguagem de descrição de hardware, a verificação formal de sistemas computa-<br>
cionais tem desempenhado um papel importante para assegurar a previsibilidade e a confiabili-<br>
dade na concepção de aplicações críticas. E, para isso, tem-se utilizado a técnica denominada<br>
model checking, que é baseada em formalismos matemáticos para provar propriedades de pro-<br>
gramas reativos (BENSALEM; LAKHNECH, 1999). Esta técnica gera uma busca exaustiva no<br>
espaço de estados do modelo para determinar se uma dada propriedade é válida ou não (BAIER<br>
et al., 2008), tendo como principal razão para o seu sucesso o funcionamento completamente<br>
automático, ou seja, sem qualquer intervenção do usuário.<br>
Visando contribuir com a verificação de sistemas embarcados no âmbito de sistemas<br>
computacionais, o contexto deste trabalho está situado no uso de metodologias e técnicas de<br>
verificação formal para programas escritos em VHDL (BIERE, 2016), focando principalmente<br>
no Bounded Model Checking (CORDEIRO et al., 2012; ROCHA et al., 2015a). Este trabalho está<br>
interessado especificamente na parte de: verificação de modelos de hardware descritos em níveis<br>
de circuitos de bits na linguagem VHDL, via transformações de código para gerar modelos (com<br>
assertivas) já suportados por model checkers, como o ESBMC (CORDEIRO et al., 2012).<br>
Dessa forma, o trabalho almeja analisar as propriedades de alcançabilidade para a<br>
identificação de localizações de erro, bem como, assertivas contendo propriedades de segurança.<br>
A propriedade de alcançabilidade ou propriedade do estado de erro é satisfatória (SAT), se um<br>
estado de erro é alcançável. Caso contrário, a propriedade é considerada insatisfatória (UNSAT).<br>
No caso SAT, o model checking também gera um rastreio da validação da propriedade (contra-<br>
exemplo), ou seja, uma sequência de estados que mostra como chegar ao erro a partir de um<br>
ponto inicial.<br>
1.1 Definição do problema<br>
O avanço da tecnologia, principalmente nas áreas de design e fabricação de eletrônicos,<br>
aumentou a importância do hardware nos dias atuais. Cada vez com mais funcionalidades<br>
integradas, aliada a velocidade e circuitos menores, faz com que a complexidade dos sistemas<br>
de hardware aumente. Entretanto, devido à complexidade cada vez maior, a detecção tardia<br>
de erros no sistema pode resultar em perda de produção, mas também custos associados ao<br>
desenvolvimento do sistema(GUPTA, 1992). Devido a isso, a verificação de hardware visa<br>
assegurar que o circuito atinja as especificações para o qual foi projetado, através de técnicas<br>
Chapter 1. INTRODUÇÃO 13<br>
formais ou dinâmicas (BOULE; ZILIC, 2007).<br>
Por esta razão, a utilização de métodos formais tornou-se uma abordagem atraente<br>
para superar as limitações inerentes à validação baseada em simulação. Portanto, a maioria<br>
das empresas de semicondutores têm investigado a sua aplicabilidade. Escolhas individuais de<br>
métodos, ferramentas e áreas de aplicação das empresas têm variado, assim como o seu nível<br>
de sucesso (CABODI et al., 2016). Com os recentes avanços na escalabilidade de automação<br>
dos model checkers e nas equivalências sequenciais de verificação, a maioria das empresas têm<br>
crescido ao contar com essas técnicas(CLARKE, 2008).<br>
O problema considerado neste trabalho é expresso na seguinte questão: Como comple-<br>
mentar e aprimorar a verificação de propriedades de segurança em circuitos lógicos, de tal<br>
forma que uma propriedade possa ser mapeada em um problema de alcançabilidade sim-<br>
bólica, ou seja, se é possível alcançar um estado específico (para uma dada propriedade) a<br>
partir do estado inicial?<br>
1.2 Objetivos<br>
O objetivo principal deste trabalho é projetar e avaliar um método para efetuar verificação<br>
de circuitos, de forma automática, descritos em VHDL com portas lógicas em nível de bit<br>
pela utilização de técnicas de transformação de códigos combinado com a técnica Bounded<br>
Model Checking para exploração de estados alcançáveis no circuito, visando identificar erros ou<br>
comportamentos indevidos ou inesperados que podem resultar no funcionamento incorreto de<br>
um dado sistema.<br>
Os objetivos específicos são:<br>
1. Propor um método para especificar pré e pós-condições <span class='f1 c_1' id='c_1_1' href='#c_1_2' cs_f='.c_1' >de circuitos digitais</span> em nível de<br>
portas lógicas descritos em VHDL;<br>
2. Analisar ferramentas de verificação de modelos que utilizam a técnica Bounded Model<br>
Checking;<br>
3. Especificar uma técnica de conversão de circuitos em linguagem de descrição de hardware<br>
VHDL para um modelo a ser verificado usando a técnica Bounded Model Checking;<br>
4. Desenvolver um método para identificação de estados de erros ou ocorrências indevidas,<br>
de um dado circuito analisado, em modelos de hardware descritos em nível de bit na<br>
linguagem de descrição VHDL.<br>
5. Validar a aplicação do método proposto sobre benchmarks públicos de programas em<br>
VHDL, a fim de examinar a sua eficácia e aplicabilidade.<br>
Chapter 1. INTRODUÇÃO 14<br>
1.3 Organização do trabalho<br>
A introdução deste trabalho apresentou: o contexto, definição do problema, e objetivos<br>
deste trabalho. Os próximos capítulos estão organizados da seguinte forma:<br>
No Capítulo 2 Conceitos e Definições, são apresentados os conceitos abordados neste<br>
trabalho, especificamente: Linguagens de descrição de hardware; Verificação e validação de<br>
sistemas; e Técnicas de compiladores.<br>
No Capítulo 3 Trabalhos Correlatos, serão apresentados o método de pesquisa bibli-<br>
ográfica utilizado, sendo ele a revisão sistemática, seguido do resultado encontrado com esta<br>
pesquisa e, por fim, a contribuição dos artigos utilizados no desenvolvimento do projeto.<br>
No Capítulo 4 Método Proposto, são descritas as etapas de execução do novo método<br>
proposto que consiste na transformação do código, instrumentação de assertivas e verificação de<br>
código utilizando um model checker.<br>
No Capítulo 5, será apresentado o cronograma de atividades a ser realizado na elaboração<br>
do método durante o desenvolvimento do projeto.<br>
E, por fim, no Capítulo 6 Considerações parciais e trabalhos futuros, serão apresentas<br>
as considerações parciais e as sugestões de trabalhos futuros que podem ser desenvolvidos.<br>
15<br>
2 CONCEITOS E DEFINIÇÕES<br>
Este capítulo tem apresenta os principais conceitos e definições abordados neste tra-<br>
balho, tais como: Linguagens de descrição de hardware, Verificação de sistemas e Técnicas de<br>
Compiladores.<br>
2.1 Linguagens de descrição de hardware<br>
As linguagens de descrição <span class='f1 c_9' id='c_9_1' href='#c_9_2' cs_f='.c_9' >de hardware (HDL</span>) foram desenvolvidas com o intuito de<br>
auxiliar a criação de circuitos lógicos com grande número de elementos e com uma gama de<br>
abstrações lógicas e eletrônicas (THOMAS; MOORBY, 2008). Entre os exemplos, podemos<br>
citar: VDHL (IEC/IEEE. . . , 2011), Verilog (IEEE. . . , 2006) e SystemC (??).<br>
Segundo CHRISTEN; BAKALAR,1999, linguagens de descrição de hardware são lingua-<br>
gens de programação utilizadas com o intuito de descrever o comportamento de um determinado<br>
circuito, técnica conhecida como modelagem. Os modelos descritos em HDL são utilizados<br>
como entrada para um simulador, onde o mesmo pode ter seu comportamento analisado.<br>
As HDL’s trazem consigo diversas vantagens, entre elas códigos independentes de tec-<br>
nologia e fabricante, podendo ser portáteis e reutilizáveis (CAPPELATTI, 2010). As linguagens<br>
mais modernas, tais como VHDL e Verilog, possuem suporte tanto a descrição do circuito pro-<br>
priamente dito, quanto ao comportamento que o mesmo deve exercer (CHRISTEN; BAKALAR,<br>
1999).<br>
A Verilog, como já citado, é <span class='f1 c_13' id='c_13_1' href='#c_13_2' cs_f='.c_13' >uma linguagem de</span> descrição de hardware que fornece<br>
diversos níveis de abstração para desenvolvimento <span class='f1 c_5' id='c_5_1' href='#c_5_2' cs_f='.c_5' >de sistemas digitais</span>(THOMAS; MOORBY,<br>
2008). A linguagem foi desenvolvida para ser simples e efetiva nos diversos níveis de abstração<br>
incluindo o suporte ao desenvolvimento, verificação, síntese e testes de software (IEEE. . . , 2006).<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog.<br>
1 p r i m i t i v e m u l t i p l e x e r ( mux , c o n t r o l , dataA , da taB ) ;<br>
2 o u t p u t mux ;<br>
3 i n p u t c o n t r o l , dataA , da taB ;<br>
4 e n d p r i m i t i v e<br>
Fonte: Adaptado de (IEEE. . . , 2006).<br>
Na Figura 1 apresenta um exemplo de multiplexador descrito em Verilog utilizando a<br>
estrutura de modelagem, chamada UDP que permite a criação de novos primitivas para serem<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 16<br>
utilizada. Apresenta uma saída apenas(mux) e três entradas sendo uma de controle(control) e<br>
duas de dados(dataA e dataB).<br>
A VHDL é <span class='f1 c_13' id='c_13_1' href='#c_13_2' cs_f='.c_13' >uma linguagem de</span> descrição de hardware amplamente utilizada, concebida<br>
na década de 80, devido uma necessidade do Departamento de Defesa dos Estados Unidos<br>
da América (CAPPELATTI, 2010). Assim como a Verilog, esta linguagem também suporta o<br>
desenvolvimento, a verificação, a síntese, e os testes de hardware (IEC/IEEE. . . , 2011).<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL.<br>
1 l i b r a r y IEEE ;<br>
2 use IEEE . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 use IEEE . s t d _ l o g i c _ u n s i g n e d . a l l ;<br>
4 e n t i t y mux2x1 i s<br>
5 p o r t ( s e l : i n STD_LOGIC ;<br>
6 a , b : i n STD_LOGIC ;<br>
7 y : o u t STD_LOGIC ) ;<br>
8 end mux2x1 ;<br>
9<br>
10 a r c h i t e c t u r e d a t a f l o w of mux2x1 i s b e g i n<br>
11 y &lt;= ( a AND NOT s e l ) OR ( b AND s e l ) ;<br>
12 end d a t a f l o w .<br>
Fonte: (CAPPELATTI, 2010).<br>
Na Figura 2 está descrito um multiplexador de duas entradas descrito em VHDL, apre-<br>
sentando na parte inicial as bibliotecas e na entidade(entity) a declaração das variáveis utilizadas.<br>
Na arquitetura(architecture) apresenta o funcionamento do multiplexador, relacionando en-<br>
tradas e saídas conforme tenham sido declarados. Este conceitos serão melhor apresentados na<br>
subsection 2.1.1.<br>
Conforme apresentado nas Figura 1 e Figura 2, ambas as linguagens apresentam difer-<br>
enças no modelos de declaração e utilização para descrição de hardware. Para este trabalho foi<br>
escolhido a VHDL devido a linguagem apresentar um melhor escopo para análise, facilitando o<br>
trabalho de análise proposto para este projeto.<br>
2.1.1 <span class='f1 c_14' id='c_14_1' href='#c_14_2' cs_f='.c_14' >VHSIC Hardware Description Language</span> - VHDL<br>
Revisar textos e verificar a necessidade de mais exemplo<br>
VHDL é <span class='f1 c_13' id='c_13_1' href='#c_13_2' cs_f='.c_13' >uma linguagem de</span> descrição de hardware destinada a ser utilizada em todas<br>
as etapas da criação de sistemas eletrônicos, sendo elas: desenvolvimento; verificação; síntese;<br>
e, teste de circuitos (IEC/IEEE. . . , 2011). Segundo (CAPPELATTI, 2010), a VHDL apresenta<br>
três principais pilares: abstração, que consiste na descrição com diferentes níveis de detalhes;<br>
modularidade, que permite a divisão do projeto em vários blocos ou módulos para posterior<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 17<br>
interconexão; e hierarquia, permite que módulos possam ser compostos por submódulos e, os<br>
mesmos tenham níveis de abstração diferentes, dependendo da necessidade do projeto. Devido a<br>
esta versatilidade que a linguagem VHDL foi selecionada para o trabalho proposto.<br>
Segundo IEC/IEEE. . . ,2011, é necessário um padrão para formatação da descrição em<br>
VHDL: Entity (Pinos de entrada/saída) e Architecture (Arquitetura). A Entity ou entidade repre-<br>
senta o bloco onde são declaradas as entradas e as saídas do circuito utilizadas em todo o sistema,<br>
conforme apresentado na Figura 3. A Architecture ou arquitetura, apresentado na Figura 4, define<br>
a relação entre entradas e saídas declaradas na entidade, podendo tais especificações serem<br>
completas ou parciais. Assim como em outras linguagens, bibliotecas podem ser adicionadas,<br>
para que novas funções e atributos possam ser utilizados no projeto.<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade.<br>
1 l i b r a r y i e e e ;<br>
2 use IEEE . STD_LOGIC_1164 . ALL<br>
3<br>
4 ENTITY f u l l _ a d d e r IS PORT(<br>
5 x1 , x2 , c i n : i n s t d _ l o g i c ;<br>
6 S , c o u n t : o u t s t d _ l o g i c ) ;<br>
7 END f u l l _ a d d e r ;<br>
Fonte: Própria.<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL.<br>
1 ARCHITECTURE b e h a v i o r a l OF f u l l _ a d d e r IS<br>
2 BEGIN<br>
3 s &lt;=x1 XOR x2 XOR c i n ;<br>
4 cout &lt;=( x1 AND x2 ) OR ( x1 AND c i n ) OR ( b<br>
AND c i n ) ;<br>
5 END b e h a v i o r a l ;<br>
Fonte: Própria.<br>
Segundo CAPPELATTI,2010 uma descrição em VHDL pode conter diferentes níveis de<br>
abstração:<br>
• Comportamental: Permite descrever o circuito através de laços e processos. O circuito<br>
é definido em forma de um algoritmo, utilizando construção similares as utilizadas em<br>
linguagem de programação.<br>
• Transferência de registradores: Englobando a representação do dispositivo em nível de<br>
transferência entre registradores, que consiste na utilização de funções lógicas combina-<br>
cionais e de registradores.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 18<br>
• Estrutural: O circuito é descrito mais próximo da implementação real, podendo ser<br>
definidas portas lógicas com atrasos unitários ou com atrasos detalhados.<br>
2.1.2 Portas lógicas<br>
Segundo (IDOETA; CAPUANO, 1982), o conceito de portas lógicas é baseado na<br>
conhecida álgebra de Boole ou álgebra booleana, desenvolvida pelo matemático inglês George<br>
Boole em 1854. A álgebra booleana é representada por apenas dois valores, sendo eles o 0 e 1 e,<br>
através disso, expressa a relação entre entrada e saída dentro <span class='f1 c_6' id='c_6_1' href='#c_6_2' cs_f='.c_6' >de um circuito</span>. As portas lógicas<br>
podem ser construídas a partir de diodos, transistores e resistores interconectados de modo que a<br>
saída seja o resultante de uma operação lógica básica realizada sobre as entradas (TOCCI et al.,<br>
2003). A Figura 5 apresenta um exemplo de álgebra booleana sem a utilização de diagramas.<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1.<br>
Fonte: (TOCCI et al., 2003)<br>
Ainda segundo TOCCI et al.,2003, devido a esta característica, a álgebra booleana possui<br>
três operações básicas, OR (ou), AND (e) e NOT (não). Tal conjunto de operações também é<br>
denominado de operações booleanas e, por meio da utilização de tabelas verdade é possível<br>
descrever as saídas baseando-se nas entradas e na operação aplicada. Cada operação booleana<br>
possui sua tabela verdade ( Figura 6), bem como sua representação em forma de diagrama.<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas.<br>
Fonte: (TOCCI et al., 2003)<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 19<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas.<br>
Fonte: (TOCCI et al., 2003)<br>
A Figura 7 apresenta um circuito lógico formado pelas portas básicas da álgebra booleana.<br>
O circuito apresenta três entradas representadas pelas letras A, B e C, mas também formada<br>
por duas portas AND, uma porta NOT e uma porta OR. Cada uma destas portas representando<br>
operações a serem realizadas, podendo receber como entrada um valor inicial ou resultante de<br>
outra porta, como no exemplo ocorre com a última porta AND.<br>
Entetanto, segundo (KROPF, 2013), a análise de circuitos é extremamente complexa,<br>
resultando em um problema NP-Completo, algoritmos possuem tempo de execução exponencial.<br>
Contudo, este tempo de execução exponencial é uma complexidade exponencial para o pior caso,<br>
resultando crescimento exponencial da execução a medida que o tamanho do problema aumenta.<br>
Ainda, segundo (KROPF, 2013) a avaliação das funções booleanas podem ser ver-<br>
dadeiras(True) ou falso(False), com isso, para um função com n variáveis, apresenta 2n possibili-<br>
dades de avaliação. Utilizando o exemplo da Figura 7 que apresenta 3 entradas, logo apresenta 8<br>
possibilidade de avaliação ao final e este número aumenta à medida que o número de variáveis<br>
tambe aumenta<br>
2.2 Verificação de sistemas<br>
No contexto de verificação de sistemas, faz-se necessário a diferenciação entre verificação<br>
e validação. Verificação e validação possuem o intuíto de mostrar que determinado sistema fun-<br>
cione conforme o especificado, além de satisfazer as especificações do cliente (SOMMERVILLE,<br>
2011).<br>
Segundo (SARGENT, 2005), verificação é o processo de determinar se um modelo<br>
computacional obtido por discretização de um modelo matemático de um evento físico e o<br>
código que implementa o modelo computacional pode ser usado para representar o modelo<br>
matemático do evento com precisão suficiente e validação é o processo de determinar se um<br>
modelo matemático de um evento físico representa o evento físico real com precisão suficiente.<br>
A verificação consite identificação de erros e provavéis problemas que um componente<br>
pronto possa apresentar, enquanto a validação busca analisar se tal componete esta seguindo<br>
os requisitos pré-definidos para sua construção (KOSCIANSKI; SOARES, 2007). O teste de<br>
programa, na qual o software é executado com dados de teste é a principal forma de validação,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 20<br>
porém, tecnicas de verificação, tais como, inspeção e revisões também podem integrar a etapa de<br>
validação (SOMMERVILLE, 2011).<br>
2.2.1 Diagrama de decisão binária<br>
Um diagrama de decisão binária(DDB) pode ser definido como um grafo aciclico para<br>
representação de funcões boolenas. Existe uma ordem rigorosa na ocorrência de variáveis à me-<br>
dida que se percorre o grafo da raiz para a folha. Dado como exemplo a formula f=(a?b)?(c?d)<br>
e utilizando a ordenação de variavél a &lt; b &lt; c &lt; d, na Figura 8. Dada a atribuição de valores<br>
booleanos as variaveis a, b, c e d, pode-se decidir se a atribuição torna a fórmula verdadeira<br>
atravessando o início do gráfico na raiz e ramificação em cada nó. Definindo a, c e d = 1 e c = 0<br>
leva a folha de rótulo 1, portanto, a fórmula é verdadeira para essa tarefa (CLARKE et al., 1994).<br>
Figure 8 – Arvore de decisão binária<br>
Fonte: (CLARKE et al., 1994)<br>
Adicionar mais detalhes e descrever onde DDB é utilizado.<br>
O DDB permite o teste eficiente de satisfabilidade, validade e eficiência (KROPF, 2013).<br>
O uso e DDB em conjunto com Model Checking e técnicas de abstração permitiu o aumento na<br>
capacidade de verificação, de modo que sistemas mais realistas podessem ser verificados(??)<br>
2.2.2 Model Checking<br>
Model checking é uma técnica de verificação formal que explora todos os possíveis<br>
estados do sistema, de modo a provar se um modelo satisfaz determinada propriedade. Pode ser<br>
aplicada em uma ampla gama de aplicações, tais como sistema embarcados, design de hardware<br>
e engenharia de software (BAIER et al., 2008).<br>
Entre as vantagens da utilização de Model Checking estão:<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 21<br>
• Possuem suporte a verificação parcial, em outras palavras, a verificação individual de<br>
propriedades, permitido foco primeiro as propriedades essenciais(BAIER et al., 2008).<br>
• Não requer qualquer interação do usuário, nem um alto grau de especialização para o uso<br>
de model checking(BAIER et al., 2008).<br>
• Possui como base a teoria de grafos, estruturas <span class='f1 c_2' id='c_2_1' href='#c_2_2' cs_f='.c_2' >de dados e</span> lógica no desenvolvimento da<br>
solução(BAIER et al., 2008).<br>
• Útil para fins de depuração, pois formece informações em caso de uma propriedade seja<br>
invalidada(BAIER et al., 2008).<br>
Por outro lado, apresenta também algumas desvantagens:<br>
• Sofre do problema de explosão de espaço de estados, ou seja, a quantidade de estados<br>
necessários pode ser maior que a memória disponivel pelo sistema(BAIER et al., 2008).<br>
• Faz a verificação apenas dos requisios declarados, logo, não a garantia de integridade.<br>
Baseado nisso, a validade de propriedades não verificadas não pode ser julgada(BAIER et<br>
al., 2008).<br>
• A verificação de modelos geralmente não é computável, isso deve-se a questões de decidi-<br>
bilidade utilizada (BAIER et al., 2008).<br>
Outras técnicas foram implementadas em conjuntos com Model checkings com o intuito<br>
de aumentas <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >a capacidade de</span> verificação, como a técnica SAT na qual não sofre do problema de<br>
explosão de estados existente usando DDB. A técnica SAT em conjuto com Model Checking é<br>
conhecida como Bounded Model Checking (??).<br>
2.2.3 Bounded Model Checking<br>
Segundo ROCHA et al., Bounded Model Checking (BMC) é um tipo especial de Model<br>
Checking que usualmente adota o método de satisfabilidade booleana, o qual tem sido introduzido<br>
como uma técnica complementar para diagrama de decisão binaria para aliviar o problema da<br>
explosão de estados, visto que a técnica de Model Checking busca todos os estados possíveis<br>
para verificação.<br>
Bounded Model Checking é uma técnica para a verificação de uma dada propriedade<br>
em uma determinada profundidade do sistema analisado. Logo, dado um sistema de transições<br>
M, uma propriedade ?, e um limite (bound) k, o BMC desenrola o sistema k vezes e traduz o<br>
sistema em uma condição de verificação(CV) ? tal que ? é satisfeito se e somente se ? tem um<br>
contra-exemplo de profundidade menor ou igual a k (ROCHA et al., 2015b).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 22<br>
O Extended SMT-Based Bounded Model Checker (ESBMC) é um Bounded Model<br>
Checking baseado em satisfabilidade booleana (SAT) que permite verificação aritmética de Já tem<br>
su-<br>
porte<br>
a<br>
SMT<br>
adi-<br>
cionar<br>
ao<br>
texto<br>
overflow e undeflow, segurança de ponteiros, limite de array, de gerar propriedades de segurança<br>
em programas em C/C++. ESBMC utiliza uma versão modificada do CBMC no front-end para<br>
analisar o código ANSI-C e para gerar as condições de verificação através de execução simbólica<br>
(CORDEIRO et al., 2012; ROCHA et al., 2015b).<br>
No ESBMC, o programa analisado é modelado em um sistema de transição de estados,<br>
conforme a trupla: M = (S,R, S0), o qual é gerado um grafo de controle de fluxo (GFC), onde<br>
S representa o conjunto de estados, R ? SxS representa as transições e S ? S representa<br>
o conjuto de estados iniciais. Um estado s ? S consiste no valor do contador de programa<br>
(PC) e os valores <span class='f1 c_4' id='c_4_1' href='#c_4_2' cs_f='.c_4' >de todas as</span> variáveis dos programas. O estado inicial S0 atribui o inicio do<br>
programa GFC ao PC, desta forma o ESBMC identifica as transições, conforme a formula lógica,<br>
?=(Si,Si+1) que captura as retrições sobre os valores correspondntes do PC e das variáveis do<br>
programa (CORDEIRO et al., 2012).<br>
Segundo o site do ESBMC(??), a ferramenta permite ao usuário indicar propriedades<br>
adicionaisusando assertivas que também são verificadas. O ESBMC converte as condições Descrever<br>
quais<br>
pro-<br>
priedades<br>
o<br>
esbmc<br>
su-<br>
porta<br>
usando diferentes técnicas de backgroundpara posteriormente passar para verificador SMT. Outra<br>
apresentar<br>
exem-<br>
plo<br>
vantagem é a ferramenta permitir verificação de software single-thread e multi-thread.<br>
Descrever qual a razão da escolha para o trabalho, apresentar resultados do SV-COMP<br>
dos últimos 3 anos<br>
2.2.4 Redes de petri<br>
Apresentar definição formal para RP<br>
corrigir o texto abaixo RP não é uma ferramenta e sim um método de modelagem<br>
Redes de petri são utilizadas como ferramentas de modelagem gráfica com propriedades<br>
matemática. Como ferramenta gráfica são utilizadas como comunicação visual, como fluxogra-<br>
mas, por exemplo, e como ferramenta matemática podem configurar modelos matemáticos que<br>
regem o comportamento dos sistemas. A grade premissa desta ferramenta é descrever sistemas<br>
de processamento de informações caracterizados como concorrentes, assíncronos, distribuídos,<br>
paralelos, não deterministas e/ou estocásticos (MURATA, 1989).<br>
As redes de petri são representados como grafos direcionais compostos por nós e arcos,<br>
conforme apresentado na Figura 9. Os nós representam as transições e eventos e os arcos<br>
representam os pesos. Dentro desta representação, os arcos e eventos são componentes passivos<br>
enquanto as transições são ativos. A principal vantagem da utilização das redes de petri esta<br>
relacionado ao chamado "Token game" que consiste no comportamento da rede de petri, em<br>
outras palavras, representa o funcionamento do sistema representado pela rede(HALDER;<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 23<br>
VENKATESWARLU, 2006).<br>
Figure 9 – Rede de petri<br>
Fonte: (HALDER; VENKATESWARLU, 2006)<br>
Descrever o funcionamento da RP apresentado na IMG<br>
Descrever quais propriedades podem ser verificadas com RP e onde será utilizado no seu<br>
trabalho.<br>
2.2.5 Verificação de hardware<br>
Para a verificação de hardware diversas técnicas têm sido propostas (). Por meio da Apresentar<br>
exem-<br>
plos<br>
com<br>
refer-<br>
ências<br>
simulação, visa assegurar que uma implemetação, descrição do hardware em qualquer qualquer<br>
nível de abstração da hierarquia de hardware, atinja suas especificações, propriedades que devem<br>
ser respeitadas para que a corretude do mesmo seja comprovada (GUPTA, 1992). A Verificação<br>
formal de hardware consiste na utilização de técnicas para corretude de circuitos lógicos, ou<br>
seja, consiste na utilização de modelos matemáticos para descrição de propriedade e/ou de<br>
comportamento de um dado sistema (KROPF, 2013).<br>
Entre as abordagens utilizadas na verificação formal de hardware consiste tanto na imple-<br>
mentação quanto a especificação estarem descritas em lógica formal, neste caso a corretude será<br>
obtida através da comprovada relação entre a implementação e a especificação (SEGER, 1992).<br>
A especificação formal consiste na descrição do comportamento, bem como, das propriedades<br>
do sistema em linguagem matemática, tornando-se crucial para o processo de verificação. Na<br>
implementação formal, o nível de abstração, tais como, Gate level e RTL são importantes infor-<br>
mações para o desenvolvimento do formalismo, bem como as classes, por exemplo se o circuito<br>
é sequencial ou combinacional, se utiliza pipeline, etc (KROPF, 2013).<br>
Apresentar um exemplo de RTL<br>
A utilização de Model Checking também se faz presente nos modelos formais de ver-<br>
ificação de hardware, onde apenas é utilizado o comportamento dos circuitos na verificação,<br>
de modo a verificar a se as propriedades presentes são satisfeitas. Para isso, são utilizados os<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 24<br>
conceitos da lógica proposicional, que por meio da utilização de fórmulas que representem as<br>
propriedades dos estados, é possível realizar as verificações necessárias (SEGER, 1992).<br>
Apresentar um exemplo com um circuito e como este pode ser verificando com model<br>
checking<br>
2.2.6 Verificação formal de software<br>
Observa-se que o uso de verificacão de software tem sido feito aplicado em muitas áreas,<br>
tais como, infraestruturas industriais de missão critica e de segurança. Logo, existe a necessidade<br>
de garantir a corretude destes sistemas. Devido a isso, a verificação formal tem sido utilizada em<br>
três principais abordagens, sendo elas (COUSOT; COUSOT, 2010; D’SILVA et al., 2008):<br>
Apresentar exemplos para os métodos apresentados abaixo<br>
• Métodos dedutivos: Produzem provas matemáticas formais de corretude usando provadores<br>
de teoremas ou assistentes de prova para execução da prova e necessitam da interação<br>
humana para prover os argumentos (COUSOT; COUSOT, 2010);<br>
• Verificação de modelos: Exploram exaustivamente modelos de execuções de programa,<br>
que podem ser sujeitos a explosão combinatória, necessário a intervenção humana para<br>
geração dos modelos (ROCHA et al., 2015b);<br>
• Analise estática: Engloba diversas técnicas para calcular automaticamente informações<br>
sobre o comportamento de um programa sem executá-lo, sendo utilizado em otimização<br>
de código e verificação em compiladres (D’SILVA et al., 2008).<br>
Segundo ROCHA et al., na verificação formal de software apresentam-se dificuldades,<br>
tais como: quais as propriedades são de interesse na verificação em tempo de execução; e<br>
impossibilidade matemática de provar a corretude de propriedades não triviais no comportamento<br>
de programas (COUSOT; COUSOT, 2010).<br>
2.2.7 Lógica proposicional<br>
A lógica proposicional é uma linguagem formal onde é definida um alfabeto e conectivos<br>
proposicionais, e um conjunto de regras gramaticais, as quais serão utilizadas para construção<br>
das proposições (SOUZA, 2017). Porém apesar de importante, ela é limitada, não podendo<br>
expressar sentenças elementares importantes, tais como a da aritmética elementar. Por exemplo:<br>
1. Todos são mortais.<br>
2. Alguém é bondoso.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 25<br>
Na lógica preposicional, não poderiam ser analisadas, pois não teria como decompor<br>
ambas em sentença e assim não teria como analisar as diferenças entre ambas(ABE, 2002).<br>
Contudo, no exemplo: Existem cavalos com patas verdes. A relação criada pela frase poderia a<br>
ser analisada pela lógica proposicional(ABE, 2002). Descrever<br>
como<br>
seria<br>
está<br>
analise<br>
Segundo SOUZA, alfabeto da lógica proposicional é formado por símbolo de pontuação,<br>
símbolos proposicionais e conectivos proposicionais, onde cada um apresenta uma função em<br>
específico, sendo:<br>
• Símbolos de pontuação: Apenas dois símbolos de pontuação são utilizados o "(" e o ")".<br>
• Símbolos proposicionais: São utilizados para representar as proposições, onde um sím-<br>
bolo P pode ser utilizado para representar uma proposição qualquer, por exemplo: P="Está<br>
chovendo". O conjunto de símbolos proposicionais é infinito e enumerável, sendo possível<br>
representar infinitos e enumerável conjunto de proposições.<br>
• Conectivos proposicionais: São os símbolos usando frequentemente na matemática. Os<br>
símbolos recebem a seguinte denominação:<br>
1. ¬: Representa a partícula de negação, ou seja, "Não".<br>
2. ?: Representa a partícula "Ou"<br>
3. ?: Representa a partícula "E"<br>
4. ?: Representa a partícula "Se então ou implica".<br>
5. ?: Representa a partícula "Se, e somente se".<br>
Ainda segundo SOUZA, existem as fórmulas que são constituídas de forma indutiva, a<br>
partir de símbolos do alfabeto conforme as regras apresentadas abaixo:<br>
• Todo o símbolo preposicional é uma fórmula<br>
• Se H é uma fórmula, então (¬H), a negação de H, é uma fórmula.<br>
• Se H e G são fórmulas, então a disjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a conjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o antecedente e G consequente da fórmula.<br>
• Se H e G são fórmulas, então a bi-implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o lado esquerdo e G o lado direito da fórmula.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 26<br>
2.2.8 Linguagem de especificação de propriedades<br>
Linguagem de especificação de propriedades, do inglês Property Specification Language<br>
- PSL, é uma notação formal para especificação de comportamento em sistemas eletrônicos,<br>
compatível com as linguagens VHDL, Verilog, SystemC e SystemVerilog. Destina-se a utilização Adicionar<br>
refer-<br>
ência<br>
a cada<br>
Ling<br>
citada<br>
para a especificação funcional, mas também para entrada de ferramentas de verificação. A<br>
especificação do PSL é a utilização de assertivas sobre propriedades de um sistema, sendo estas<br>
propriedades constituídas de três elementos: expressões boolenas, expressões sequenciais e<br>
operadores temporais (IEEE. . . , 2010).<br>
Corrigir a apresentação da citação IEEE... estranho<br>
Segundo (IEEE. . . , 2010), o PSL foi totalmente desenvolvida com o intuito fornecer<br>
leitura e escrita de fácil entendimento, sintaxe concisa, semântica formal e rigorosamente <span class='f1 c_7' id='c_7_1' href='#c_7_2' cs_f='.c_7' >bem<br>
definida e</span> ser matematicamente precisa, visto a utilização da mesma em processo de verificação.<br>
O PSL pode ser utilizado para capturar requisitos relativos ao comportamento total do projeto,<br>
bem como, sobre o modo que o mesmo deverá operar no ambiente, ms também para capturar<br>
requisitos comportamentais e os pressupostos que surgem durante o processo de design. Ambas<br>
podem ser utilizadas para verificação de sistemas.<br>
Apresentar exemplos de uso da PSL<br>
2.2.9 Verificação baseada em assertivas<br>
Verificação baseada em assertivas, do inglês Assertion-Based Verification - ABV, é um<br>
paradigma de verificação igualente adequado para verificação formal e abordagens baseadas em<br>
simulação (BOULE; ZILIC, 2005) e em conjunto com a tecnica de PSL tem ganhado aceitação<br>
como um método essencial para verificação funcional do hardware (DAHAN et al., 2005).<br>
Na ABV as assertivas são declaração adicionadas ao projeto com o intuito de especificar<br>
o comportamento do projeto (BOULE; ZILIC, 2005), podendo escritos em PSL ou em SVA<br>
(System Verilog Assertions). No caso deste projeto será utilizado a PSL, devido a mesma ser<br>
utilizada juntamente com a linguagem VHDL.<br>
Com a utilização de ABV o circuito pode ser verificado usando técnicas de simulação<br>
e/ou verificação, por exemplo, model checking, para garantir que o mesmo esteja de acordo<br>
com o pretendido projeto (DAHAN et al., 2005). Na Figura 19 apresenta o modelo de assertiva<br>
utilizada no projeto, utilizando de um modelo próprio para assertivas, unindo as funcionalidades<br>
já existentes nas assertivas do VHDL, mas também novas (serão apresentadas nas próximas<br>
seções), fornecendo assim mais propriedades a serem analisadas.<br>
Descrever qual o objetivo da assert apresentado<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 27<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 e n t i t y AND_ent i s<br>
5 p o r t ( x , y : i n b i t ;<br>
6 F : o u t b i t<br>
7 ) ;<br>
8 end AND_ent ;<br>
9<br>
10 a r c h i t e c t u r e behav1 of AND_ent i s<br>
11 b e g i n<br>
12 ??@c2vhdl : ASSERT<br>
13 ??a s s e r t n o t ( x= ’ 0 ’ and y= ’ 1 ’ )<br>
14 ?? r e p o r t " Both v a l u e s o f s i g n a l s x and y a r e e q u a l t o 1 "<br>
15 ??s e v e r i t y ERROR;<br>
16 ??@c2vhdl :END<br>
17<br>
18 p r o c e s s ( x , y )<br>
19 b e g i n<br>
20 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
21 F &lt;= ’ 1 ’ ;<br>
22 e l s e<br>
23 F &lt;= ’ 0 ’ ;<br>
24 end i f ;<br>
25 end p r o c e s s ; 4<br>
26 end behav1 ;<br>
Fonte: Própria.<br>
2.2.10 Propriedades de segurança<br>
Propriedades de segurança é um meio de validação do comportamento de um determinado<br>
sistema, de modo que se uma dada propriedade de segurança for violada, então através de<br>
uma execução finita, é possível verificar tal erro. Algumas propriedades de segurança, no<br>
entanto, podem impor requisitos em fragmentos de caminho finito e não podem ser verificadas<br>
considerando apenas os estados alcançáveis. (BAIER et al., 2008).<br>
Segundo (CLARKE et al., 2003), podemos definir uma propriedade de segurança como:<br>
dado um sistema de transições ST = (S, S0, E), seja um conjunto B ? S que especifica um<br>
conjunto de maus estados tais que S0 ?B = ?, pode-se dizer que ST é seguro com relação a B,<br>
denotado por ST |= AG¬B se não existe um caminho no sistema de transição do estado inicial<br>
S0 até o estado B, de outro modo é dito que ST não é seguro.<br>
Adicionar exemplos de propriedades de segurança em hardware<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 28<br>
2.3 Técnicas de compiladores<br>
Compiladores são sistemas de software utilizados para tradução de <span class='f1 c_13' id='c_13_1' href='#c_13_2' cs_f='.c_13' >uma linguagem de</span><br>
programação para outra, ou seja, o programa da linguagem fonte é lido e traduzido para um<br>
código equivalente na outra linguagem, ou linguagem alvo. Geralmente utilizada para transformar<br>
trechos de código em uma linguagem a ser executada pelo computador (AHO et al., 2007).<br>
Diversas técnicas podem ser utilizadas nas diversas etapas, até que o código seja traduzido,<br>
tais como LL(1) e LR na análise sintática; eliminação de código morto; propagação de constante<br>
e Peephole na otimização de código(AHO et al., 2007). Neste projeto serão focados as áreas de<br>
transformações de código e otimização de código.<br>
2.3.1 Transformações de código<br>
Transformações de código correspondem a uma complexa função que envolve analise de<br>
<span class='f1 c_11' id='c_11_1' href='#c_11_2' cs_f='.c_11' >fluxo de dados e</span> modificação completa do programa que são parte integral da alta performance e<br>
sistemas computacionais. Podem ser classificados em transformações escalares que reduzem<br>
o número de instruções a serem executadas no programa ou transformações paralelas que<br>
maximizam o paralelismo (SRIKANT; SHANKAR, 2002).<br>
A Figura 11 representa o trecho de código apresentado na Figura 19. O trecho representa<br>
o comportamento das entradas, neste caso de um código da porta AND. E a figura Figura 12<br>
representa a tradução deste trecho em código na linguagem C. Esta tradução foi realizada pela<br>
ferramenta V2C, utilizada neste projeto. Adicionar<br>
refer-<br>
ência<br>
Figure 11 – Trecho de código em VHDL representando porta AND.<br>
1 p r o c e s s ( x , y )<br>
2 b e g i n<br>
3 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
4 F &lt;= ’ 1 ’ ;<br>
5 e l s e<br>
6 F &lt;= ’ 0 ’ ;<br>
7 end i f ;<br>
8 end p r o c e s s ;<br>
Fonte: Própria.<br>
Expandir esta seção. Apresentar propriedades de transformação e técnicas para avaliar a<br>
transformação<br>
2.3.2 Otimização de código<br>
A otimização de código consiste na melhoria do código intermediário gerado pelos<br>
algoritmos de compilação com o objetivo de obter um menor tempo de execução do programa,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 29<br>
Figure 12 – Trecho de código traduzido para linguagem C.<br>
1 /? S t a r t o f T r a n s l a t i o n ? /<br>
2 /? p0 : ? /<br>
3 i f ( chg [ x ] | | chg [ y ] ) {<br>
4 i f ( ( ( o l d [ x ]==1) && ( o l d [ y ]==1) ) ) {<br>
5 new [ f ] = 1 ;<br>
6 }<br>
7 e l s e {<br>
8 new [ f ] = 0 ;<br>
9 }<br>
10 }<br>
11 /? End o f T r a n s l a t i o n ? /<br>
Fonte: Própria.<br>
porém outros fatores podem ser introduzidos, como algoritmos menores. Este fato não implica<br>
em afirmar que o melhor código é gerado, visto que dada a complexidade, raramente pode ser<br>
obtido que o código gerado pode ser o melhor possível (AHO et al., 2007).<br>
Segundo AHO et al., otimização local de código consiste na otimização de um bloco<br>
básico de código, ou seja, a otimização ocorre em um trecho especifico de código. Os blocos<br>
básicos são trecho onde não ocorrem saltos ou loops, para nenhuma outra parte do código. A<br>
otimização global de código é baseado na analise do <span class='f1 c_11' id='c_11_1' href='#c_11_2' cs_f='.c_11' >fluxo de dados</span>, de modo que ocorra as<br>
elminação de instruções não necessárias ou substituição mais facil. A otimização global consite<br>
na analise completa do código. Neste sentido, nas próximas seções serão apresentadas algumas<br>
importantes técnicas de otimizações.<br>
2.3.2.1 Grafo Acliclico Direcional - GAD<br>
Grafo Aciclico Direcional é utilizado para diversos fins dentro da estrutura de compi-<br>
ladores, principalmente para geração da parse tree otimização de código. Pode ser usado na<br>
representação de instruções unicas blocos básicos de código(AHO et al., 2007). O uso de GAD<br>
permite a melhoria de de código, tais como:<br>
• Elminação de subexpressões locais comuns, ou seja, expressões que o valor já foi com-<br>
putado anteriomente;<br>
• Eliminação de código morto;<br>
• Reordernamento de declarações buscando reduzir o tempo que o valor temporário necessita<br>
ser preservado em um registro;<br>
A Figura 13 apresenta um bloco básico com algumas instruções, no caso apresentando<br>
são 4 operações entre somas e multiplicação e a partir deste bloco a Figura 14 apresenta o GDA<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 30<br>
Figure 13 – Exemplo de bloco basico de código.<br>
1 a = b + c<br>
2 b = a ? d<br>
3 c = b + c<br>
4 d = a ? d<br>
Fonte: (AHO et al., 2007)<br>
Figure 14 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
deste trecho de código. Nele apresenta cada nó como uma operação especifica e os terminais<br>
como as parcelas das operações.<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC<br>
Grafo de fluxo de controle corresponde a um grafo direcionado, no qual cada nó rep-<br>
resenta blocos básicos e cada aresta representa os caminhos de fluxo entre os blocos basi-<br>
cos (ALLEN, 1970). É importante ressaltar que saltos determinam o final de um determinado<br>
bloco básico, ou seja, saltos indicam um caminho para uma nova região de código básico (AHO<br>
et al., 2007).<br>
Apresentar um exemplo de como e utilizado em código<br>
2.3.2.3 Eliminção de código morto<br>
A eliminacação de código morto é uma técnica que busca a eficiência de um programa<br>
evitando a execução de instruções não necessária em tempo de execução (KNOOP et al., 1994).<br>
O código morto consiste em instruções que não serão alcançáveis durante o fluxo do programa,<br>
sendo esta técnica basicamente a retirada de qualquer variável que não será utilizada em qualquer<br>
outro nó do grafo (AHO et al., 2007).<br>
A utilização de GAD corresponde na eliminação de qualquer nó raiz, ou seja, nó sem<br>
ancestrais, as quais não esteja ativa anexada a mesma. A execução repetida desta operação<br>
removerá todos os nós correspondentes a código morto (AHO et al., 2007).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 31<br>
Figure 15 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
Na Figura 15, supondo que os nós a, b e c estejam ativa, porém o nó énão esteja, o último Corrigir<br>
nó é?pode ser eliminado imediatamente. Os nós restantes continuam no GDA, a menos que não tenho<br>
variáveis ativas atreladas aos nós (AHO et al., 2007).<br>
2.3.2.4 Análise do <span class='f1 c_11' id='c_11_1' href='#c_11_2' cs_f='.c_11' >fluxo de dados</span><br>
Análise de <span class='f1 c_11' id='c_11_1' href='#c_11_2' cs_f='.c_11' >fluxo de dados</span> refere-se ao conjunto de técnicas que derivam informações<br>
sobre o <span class='f1 c_11' id='c_11_1' href='#c_11_2' cs_f='.c_11' >fluxo de dados</span> ao longo dos caminhos de execução do programa. Para análise do<br>
programa, é necessário considerar todas as posiveis execuções através do grafo de fluxo de<br>
controle (AHO et al., 2007).<br>
Apresentar exemplos<br>
2.3.2.5 Gerador de código<br>
O gerador de código é responsavél pela tradução final do programa-fonte para o programa-<br>
alvo, o mesmo recebe como entrada um código intermediário juntamente com a tabela de<br>
símbolos. Faz-se necessário que o programa-fonte tenha sido analisado sintatica e lexicamente,<br>
assim evitando que erros possam ser passados para o programa-alvo, por outro lado a existência<br>
de uma nível de otimização, faz-se opicional neste caso (AHO et al., 2007).<br>
O gerador de código possui três tarefas primarias, sendo as mesmas seleção de instrução,<br>
alocação de registros e atribuições. A seleção de instruções envolve a escolha das instruções<br>
apropriadas da máquina-alvo para implementar as declarações do código intermediario. A<br>
atribuição e atribuição de registros envolve a decisão sobre os valores a serem registrados nos<br>
registros(AHO et al., 2007).<br>
Apresentar exemplo<br>
32<br>
3 TRABALHOS CORRELATOS<br>
Sugiro apenas mencionar que foi feito a revisão sistemática; o que já foi feito e os resul-<br>
tados. As outras seções sobre RS e mover para apêndice.<br>
3.1 Revisão sistemática<br>
A revisão sistemática consiste é um método de identificação, análise e interpretação de<br>
pesquisas relevantes em determinada área ou questão de pesquisa. Para execução da revisão sis-<br>
temática se requer um esforço maior, em comparação as pesquisas tradicionais, sendo necessário<br>
seguir uma sequência de passos metodológicos sobre a área ou questão de pesquisa ao qual<br>
deseja ser feita a pesquisa (KITCHENHAM, 2004).<br>
Para a execução da revisão sistemática, é necessário um esforço considerável, se com-<br>
parado a uma revisão informal a literatura. Enquanto que a revisão de literatura informal é<br>
conduzida de forma ad-hoc, sem planejamento e critérios de seleção estabelecidos a priori,<br>
a revisão sistemática requer um protocolo formal bem definido, com uma sequência de pas-<br>
sos metodológicos, para conduzir uma pesquisa sobre o tema ao qual deseja-se realizar a<br>
pesquisa (MAFRA; TRAVASSOS, 2006).<br>
A aplicação da revisão sistemática requer que seja seguido um conjunto bem definido e<br>
sequêncial de passos, seguindo um protocolo de pesquisa desenvolvido previamente. Através<br>
deste método é possível realizar uma extensa pesquisa, contemplando uma grande quantidade<br>
de informações sobre o assunto pesquisado (MAFRA; TRAVASSOS, 2006). Este protocolo é<br>
construído considerando um tema específico que representa o elemento central da investigação,<br>
onde os passos da pesquisa, as estratégias definidas para coletar as evidências e o foco das<br>
questões de pesquisa são definidas explicitamente, de tal forma que outros pesquisadores sejam<br>
capazes de reproduzir o mesmo protocolo de pesquisa (BIOLCHINI et al., 2005).<br>
Segundo MAFRA; TRAVASSOS, o processo para a condução de revisões sistemáticas<br>
envolve três etapas:<br>
1. Planejamento da Revisão: os objetivos da pesquisa são listados e o protocolo da revisão<br>
é definido.<br>
2. Condução da Revisão:nesta atividade, as fontes para a revisão sistemática são sele-<br>
cionadas, os estudos primários são identificados, selecionados e avaliados de acordo com<br>
os critérios de inclusão, exclusão, e de qualidade estabelecidos durante o protocolo da<br>
revisão.<br>
Chapter 3. TRABALHOS CORRELATOS 33<br>
3. Análise dos Resultados: os dados dos estudos são extraídos e sintetizados para análise e<br>
apresentação dos resultados.<br>
Vale ressaltar que como o objetivo deste trabalho é realizar um estudo exploratório de<br>
caracterização de área podemos dizer que esta revisão sistemática se caracteriza como uma quasi-<br>
sistemática (TRAVASSOS et al., 2008), pois segue o mesmo processo da revisão sistemática e<br>
preserva o rigor e mesmo formalismo para as fases metodológicas de elaboração de protocolo e<br>
execução da revisão, mas sem a aplicação de uma meta-análise a princípio, que pode ser aplicada<br>
posteriormente.<br>
3.1.1 Planejamento da Revisão Sistemática<br>
Objetivo: Este estudo tem o objetivo esquematizado a partir da estrutura do paradigma<br>
GQM (do ingles Goal,Question and Metric)(BASILI et al., 1994).<br>
Analisar Publicações científicas através de um estudo baseado em revisão sis-<br>
temática<br>
Com propósito de Identifica-las<br>
Com relação as Vantagens e desvantagens da utilização de assertiva e transformações<br>
de código na verificação do código na linguagem de descrição VHDL<br>
Do ponto de vista do Pesquisador<br>
No contexto Acadêmico ou industrial para verificação de assertivas na linguagem<br>
de descrição VHDL<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM<br>
Formulação da Pergunta: Buscamos respostas para as seguintes perguntas:<br>
• Q1: Quais são os métodos para verificação de circuitos lógicos descritos na linguagem de<br>
programação VHDL?<br>
– Q1.1: Foi desenvolvido e está disponível alguma ferramenta para aplicação do<br>
método?<br>
– Q1.2: Qual a técnica de exploração de estados para circuitos lógicos?<br>
– Q1.3: O método proposto é baseado em técnicas de verificação de software?<br>
– Q1.4: Como o método proposto valida pré e pós condições no programa?<br>
– Q1.3: Foi utilizado algum benchmark de programas em VHDL para experimentação<br>
e o mesmo encontra-se disponível?<br>
– Q1.4: Quais as perspectivas futuras para melhorar da aplicação do método proposto?<br>
Escopo da pesquisa:Na delimitação do escopo da pesquisa foram estabelecidos critérios,<br>
buscando garantir a viabilidade da execução, acessibilidade dos dados e abrangência do estudo re-<br>
alizado. A pesquisa dar-se-á a partir de bibliotecas digitais através das suas respectivas máquinas<br>
Chapter 3. TRABALHOS CORRELATOS 34<br>
de busca e, quando os dados não estiverem disponíveis eletronicamente, através de consultas<br>
manuais.<br>
Critérios de Seleção de Fontes. Para as bibliotecas digitais é desejado:<br>
• Possuir uma máquina de busca que permita o uso de expressões lógicas ou mecanismo<br>
equivalente.<br>
• Incluir em sua base, publicações de exatas ou correlatas que possuam relação direta com o<br>
tema a ser pesquisado<br>
• As máquinas de busca deverão permitir a busca no texto completo das publicações.<br>
Segundo ROCHA et al., os mecanismos de busca utilizados devem garantir resultados<br>
únicos através da busca de um mesmo conjunto de palavras-chaves (string de busca). Quando<br>
isto não for possível, deve-se estudar e documentar uma forma de minimizar os potenciais efeitos<br>
colaterais desta limitação.<br>
Métodos de Busca das Publicações. As fontes digitais foram acessadas via Web, através<br>
de expressões de busca pré-estabelecidas. A biblioteca digital consultada foi a Scopus, acessível<br>
em http://www.scopus.com. Segundo a editora ELSEVIER, a Scopus é uma das maiores bases<br>
de dados de resumos e citações da literatura de pesquisa peer-reviewed com mais de 22, 800<br>
títulos de mais de 5, 000 editoras internacionais abrangendo as áreas de tecnologia, medicina,<br>
artes, ciências sócias e com atualizações diárias. Entre as editoras podemos citar: Springer<br>
(SPRINGER, 2018); IEEE Xplore Digital Library (IEEE, 2018);ACM Digital Library (ACM,<br>
2018) ; ScienceDirect/Elsevier (B.V, 2018); Wiley Online Library (SONS, 2018); dentre outras.<br>
String de Busca. A string de busca foi definida segundo o padrão PICO (do inglês<br>
Population, Intervention, Comparison, Outcomes) (KITCHENHAM et al., 2009), conforme a<br>
estrutura abaixo:<br>
• População: Trabalhos publicados em conferências e periódicos que relacionam verificação<br>
de propriedades de circuitos lógicos em códigos para a descrição de hardware.<br>
• Intervenção: Verificação de propriedades relacionadas a verificação de circuitos para as<br>
diferentes estruturas das linguagens de descrição de hardware;<br>
• Comparação: análise de cobertura e suporte das abordagens identificadas para a verificação<br>
de propriedades das linguagens de descrição de hardware;<br>
• Resultados: a partir da descrição das abordagens pretende-se verificar a cobertura que cada<br>
abordagem apresenta na manipulação das diferentes estruturas da linguagem de descrição<br>
de hardware para a verificação de propriedades baseada em assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 35<br>
Segundo ROCHA et al., como este estudo representa um estudo de mapeamento/caracteri-<br>
zação, a string de busca foi definida de acordo com dois aspectos: População e Intervenção, como<br>
é apresentado na estrutura abaixo. Posteriormente esta mesma string de busca será executada<br>
na biblioteca Scopus para busca de artigos e publicações de modo a gerar uma interseção entre<br>
população e intervenção.<br>
• População: publicações que fazem referência a verificação de propriedades de circuitos<br>
lógicos e sinônimos:<br>
– Palavras-chaves: "circuit checker" OR "circuit verification" OR "contract based<br>
verification" OR "code analysis" OR "static analysis" OR "dynamic analysis" OR<br>
"safety verification" OR "RTL analysis" OR "program analysis" OR "property veri-<br>
fication" OR "formal verification" OR "model checking" OR "model checker" OR<br>
"hardware checker" OR "hardware verification" OR "validity checker" OR "hard-<br>
ware assertion" OR "assertion checker" OR "assert verification" OR "assertion-based<br>
verification" OR "assertion based verification" OR "assertion-based design" OR "bit<br>
level verification"<br>
• Intervenção: Verificação de circuitos e sinônimos:<br>
– Palavras-chaves:"hardware statement" OR "hardware code" OR "hardware source<br>
code" OR "hardware semantics" OR "hardware property" OR "logical gates" OR<br>
"sequential circuit" OR "parallel circuit" OR "real circuits" OR "complex circuits"<br>
OR "control circuitry" OR ”software netlist” OR “hardware emulation” OR “silicon<br>
debug”<br>
3.1.1.1 Procedimentos de Seleção e Critérios<br>
A estratégia de busca será aplicada por um pesquisador para identificar as publicações<br>
em potencial. A seleção das publicações dar-se-á em 2 etapas, conforme apresentado a seguir.<br>
1. Seleção e catalogação preliminar dos dados coletados: A seleção preliminar das publi-<br>
cações será feita a partir da aplicação da string de busca na biblioteca Scopus, o resultado<br>
desta busca corresponde a seleção preliminar. Todas as publicações serão armazenadas<br>
para análise posterior;<br>
2. Seleção dos dados relevantes - [1 filtro]: A seleção preliminar com o uso da expressão<br>
de busca não garante que todo o material coletado seja útil no contexto da pesquisa, pois a<br>
aplicação das expressões de busca é restrita ao aspecto sintático. Por isso, é necessário a<br>
criação de filtros de exclusão e inclusão, de modo a classificar os artigos e publicações que<br>
se enquadram no contexto da pesquisa realizada. Nesta epata apenas serão lidos o título,<br>
abstracts, e palavras-chaves e classificar de acordo com os filtros, ou seja, se será aceito ou<br>
excluído. Devem ser excluídas as publicações contidas no conjunto preliminar que:<br>
Chapter 3. TRABALHOS CORRELATOS 36<br>
• CE1-01: Não serão selecionadas publicações em que as palavras-chave da busca<br>
não apareçam no título, resumo e/ou texto da publicação (excluem-se os seguintes<br>
campos: as seções de agradecimentos, biografia dos autores, referências bibliográficas<br>
e anexas).<br>
• CE1-02: Não serão selecionadas publicações em que descrevam e/ou apresentam<br>
‘keynote speeches’, tutoriais, cursos e similares.<br>
• CE1-03: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação/validação de códigos para descrição de hardware.<br>
• CE1-04: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação de código de descrição de hardware baseado em assertivas ou propriedades<br>
de verificação de hardware.<br>
Podem ser incluídas apenas as publicações contidas no conjunto preliminar que:<br>
• CI1-01:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita uma abordagem para verificação<br>
de código de descrição de hardware baseado em assertivas ou propriedades de<br>
verificação de hardware.<br>
• CI1-02:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita recomendações de melhoria<br>
na utilização de abordagens para verificação de código de descrição de hardware<br>
baseado em assertivas ou propriedades de verificação de hardware.<br>
3. Seleção dos dados relevantes - [2 filtro]: Apesar do 1o filtro limitar o universo de busca,<br>
infelizmente não há garantias de que todo material selecionado no filtro anterior seja útil<br>
no contexto da pesquisa. Neste caso, novos filtros são gerados, buscando, da mesma forma<br>
que o primeiro filtro, classificar os artigos e publicações que se enquadram no contexto<br>
da pesquisa. Para este filtro é necessário a leitura na integras dos artigos selecionados<br>
anteriormente. O objetivo é identificar que relacionam assertivas e/ou propriedade de<br>
verificação de hardware.<br>
• CS2 -ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware e não citam assertivas<br>
• CS2 +ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware, mas citam assertivas<br>
• CS2 -ASS +VER_HARD: Não devem ser selecionadas publicações que contextual-<br>
izam verificação de hardware, mas citam assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 37<br>
Dessa forma, todas as publicações devem respeitar o critério abaixo:<br>
• CS3 +ASS +VER_HARD: Serão selecionadas publicações que contextualizam<br>
verificação de hardware e citam assertivas em seu contexto.<br>
Devido ao tempo necessário para o desenvolvimento execução dos filtros da revisão<br>
sistemática serem extensos, apenas o primeiro filtro foi executado neste projeto, mesmo que<br>
os parâmetros para o segundo filtro já tenho sido desenvolvidos. Em contra partida foram<br>
selecionados 6 artigos que serviram como ferramentas de estudo para o desenvolvimento da<br>
metodologia que será apesentada no Capítulo 4.<br>
3.2 Revisão da literatura<br>
Nesta sessão serão apresentados trabalho relevantes para o desenvolvimento do método<br>
proposto que foram identificados utlizando a revisão sistemática mencionado anteriormente.<br>
Os artigos apresentam técnicas de transformações de código, utilização de Assertion-Based<br>
Verification e PSL para verificação de hardware.<br>
3.2.1 V2c-A verilog to C translator<br>
O artigo de MUKHERJEE et al. apresenta uma ferramenta implementada em C++<br>
chamada v2c para transformação de código da linguagem de descrição Verilog para linguagem<br>
de programação C. A ferramenta é executada a nível de palavra, visto que esta abordagem garante<br>
uma aumento na escalabilidade, mas também proporionando que técnicas, como interpolaçãoe adicionar<br>
refer-<br>
ência<br>
aceleração de looppossam ser utilizadas para verificação, algo inviavél, caso a tradução fosse<br>
adicionar<br>
refer-<br>
ência<br>
executada a nível de bit. O sistema recebe como entrada um código em Verilg, onde são aplicadas<br>
regras semânticas e mapeando os bit de operação, chamado software netlist. Após isso, o código<br>
intermediário é convertido para C.<br>
A contribuição deste trabalhoconsiste na utilização de transformações de código como<br>
Qual<br>
tra-<br>
balho?<br>
base principal e partindo deste pressuposto torna-se vantajoso devido a utilização de outras<br>
ferramentas que não apresente suporte a certas linguagens, tais com a ferramenta ESBMC,<br>
utilizada neste trabalho, não apresenta suporte a VHDL, porém apresenta suporte as linguagens<br>
C/C++. Em outras palavras, a contribuição deste trabalhofoi a utilização de traduções de códigos<br>
Qual<br>
tra-<br>
balho?<br>
e utilizado este conceito como modelo de entrada para analise de circuitos.<br>
3.2.2 Unbounded safety verification for hardware using software ana-<br>
lyzers<br>
No artigo de MUKHERJEE et al. foi apresentado uma metodologia que aborda a utiliza-<br>
ção de técnicas e analisadores de software, com o objetivo de de abordar a análise de circuitos e<br>
Chapter 3. TRABALHOS CORRELATOS 38<br>
com isso trançar um paralelo entre as abordagens. Para testes foram utilizadas três metodologias<br>
de análise, usando interpolação, k-inductione tecnologias hibrídas. Como resultante dos testes, foi adicionar<br>
refer-<br>
ência<br>
adicionar<br>
refer-<br>
ência<br>
observado as principais causas de erros, por exemplo, bits não preciso e no caso das operações<br>
a bit-level ocorria perda de informações. Também foi obeservado que apesar de não serem<br>
otimizadas para análises de hardware, alguns analisadores de softaware podem, dependendo da<br>
técnica utilizada no analisador, ser utilizada para analise de hardware.<br>
Descrever<br>
qual<br>
o mo-<br>
tivo.<br>
A utilização de técnicas de análise de software para o desenvolvimento de análise de<br>
hardware é o foco a ser abordado neste neste trabalho de maneira prática, utilizando os princípio<br>
analisados por (MUKHERJEE et al., 2016a). Neste contexto, o objetivo deste trabalho é a<br>
utilização de técnicas de software para análise de circuitos, diferente do artigo apresentado acima<br>
que busca utilização uma abordagem mais complexa provando a possibilidade da utilização de<br>
técnicas de analise de software no contexto da verificação de hardware.<br>
A última frase está confusa, no meu entedimento é o mesmo sentido.<br>
3.2.3 Formal verification of timed VHDL programs<br>
No trabalho apresentado por BARA et al. é proposto uma abordagem para a análise<br>
de tempo relacionado a cada porta lógica dentro de um dado circuito analisado. A abordagem<br>
apresenta a tradução <span class='f1 c_6' id='c_6_1' href='#c_6_2' cs_f='.c_6' >de um circuito</span> lógico codificado em VHDL para um formalismo baseado<br>
em automato de tempo. Tal formalismo é representado por uma automato de estados finitos referência<br>
com relogios simbólicos que evoluem em taxa uniforme. A tradução é executada de modo<br>
automatico, baseado na emulação da propagação de cada transação ao longo de cada sinal, o<br>
seja, são automatos programados e cronometrados do circuito. Após a tradução para automato, a<br>
analise é feita pela ferramenta UPPALque é um model checking de verificação de propriedades referência<br>
de tempo. Seguindo esta metodologia a análise pode ser extraida de modo independente de cada<br>
bloco, desta forma a análise é feita de forma mais precisa, podendo ser analisado inumeros<br>
fatores, tais como limites de intervalo e sinal de correlação.<br>
O artigo apresenta uma abordagem de tempo, que torna-se interessante adição ao método.<br>
Porém até o momento a função não foi implementada ficando a trabalho futuros.<br>
Expandir o texto acima, exemplo, descrever como o método poderia ser incluindo no seu<br>
TCC.<br>
3.2.4 On the use of assertions for embedded-software dynamic verifica-<br>
tion<br>
Em GUGLIELMO et al. é apresentado uma metodologia para a integração dinamica de<br>
Assertion-Based Verification para várias fases da análise da verificação de fluxo em sistemas<br>
embarcados, por exemplo, emulação, diagnosticos e Debug, mas também um ferramenta chamada<br>
Chapter 3. TRABALHOS CORRELATOS 39<br>
RadCheck. O metodo de aplicação, chamado V-model é dividido em fases de verificação em<br>
paralelo com as fases de design do circuito. Com base no V-model, o método é aplicado, iniciando<br>
com o nível de sistema e as especificação do sistema, neste caso especificado usando PSL.<br>
Neste nível é especificado todas as funcionalidades gerais da aplicação. No nível de integração<br>
visa investigar problemas de interação que possam ocorrer, definindo propriedades que cobrem<br>
incrementalmente as unidades estruturais interativas de aplicação. No nível de unidade descrevem<br>
comportamentos internos e são definidas através de parâmetros de entrada/saída das unidade e<br>
estruturas de dados internas.<br>
A contribuição deste projeto está relacionado a utilização de assertivas no contexto da<br>
verificação de software. As assertivas são o principal meio de análise proposto neste projeto,<br>
visto que estas mesma assertivas serão analisadas pelo ESBMC. Aliado a isso em GUGLIELMO<br>
et al. é apresentado modelos de utilização de assertivas no processo de verificação de hardware,<br>
e tais assertivas foram adaptadas para um modelo proposto neste trabalho.<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation<br>
No trabalho de BOULE; ZILIC é apresentado uma ferramenta de geração de assertivas<br>
no contexto da emulação de circuitos, de modo que estas assertivas descrita em PSL possam<br>
transformadas para o modelo de linguagem de descrição de hardware. Inicialmente é realizada<br>
toda análise de cada assertiva e a mesma é traduzida em partes, levando em consideração os<br>
operadores e cada estrutura, por exemplo if-else, utilizado na declaração da assertiva.<br>
Apresentar um exemplo para explicar o texto acima<br>
trabalho de BOULE; ZILIC consolida e apresenta aspectos importantes, tais como a<br>
utilização de uma ferramenta para geração de assertivas, o que torna-se no contexto deste projeto,<br>
extremamente importante, visto que o modelo adotado atualmente consiste tanto na geração<br>
automática das assertivas, bem como a inserção manual por parte do usuário.<br>
40<br>
4 MÉTODO PROPOSTO<br>
Este Capítulo descreve o método proposto neste trabalho, baseado transformações de<br>
código para análise de circuitos lógicos descritos em VHDL utilizando Bounded Model Checking,<br>
neste caso o model checker ESBMC.<br>
4.1 Visão geral do método<br>
O método proposto consiste inicialmente em receber como entrada um circuito lógico<br>
descrito em VHDL, onde uma dada propriedade representada em uma assertiva será analisada,<br>
as assertivas serão inseridas de automaticamente pelo método ou pelo próprio usuário do método.<br>
O código VHDL analisado posteriomente é traduzido para linguagem C e recebe uma instrumen-<br>
tação de código (com funções especificas suportadas pelo método) para a posterior validação do<br>
mesmo. O Código em C automaticamente gerado, já instrumentado, será processado e analisado<br>
pelo ESBMC de acordo com as assertivas inseridas e ao final é apresentado o resultado. Caso<br>
alguma das assertivas seja violada, um contra-exemplo é apresentado ao usuário. Uma visão<br>
geral do método proposto é apresentado na Figura 16 e nas sessões a seguir serão apresentados<br>
cada etapa do método proposto neste trabalho.<br>
Figure 16 – Ciclo da ferramenta<br>
Fonte: Própria<br>
Com o intuito de auxiliar nas explicações apresentadas nas próximas sessões, o código<br>
na Figura 17 será utilizado nas explanações, bem como será apresentado todas as alterações do<br>
mesmo, conforme cada etapa do método.<br>
Chapter 4. MÉTODO PROPOSTO 41<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 ENTITY U l a _ t c c IS<br>
5 PORT(A, B , B i n v e r t i d o , Op1 , Op2 : IN BIT ;<br>
6 R e s u l t a d o :<span class='f1 c_10' id='c_10_1' href='#c_10_2' cs_f='.c_10' >OUT BIT ) ;<br>
7 END</span> U l a _ t c c ;<br>
8<br>
9 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
10 SIGNAL a n d _ p o r t : b i t ;<br>
11 SIGNAL o r _ p o r t : b i t ;<br>
12 SIGNAL x o r _ p o r t : b i t ;<br>
13 SIGNAL mux2x1 : b i t ;<br>
14 BEGIN<br>
15 PROCESS(A, B , B i n v e r t i d o , Op1 )<br>
16 BEGIN<br>
17 ??PORTA AND<br>
18 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
19 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
20 ELSE<br>
21 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
22 END IF ;<br>
23 ??PORTA OR<br>
24 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
25 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
26 ELSE<br>
27 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
28 END IF ;<br>
29 ??PORTA XOR<br>
30 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
31 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
32 ELSIF (A = ’ 1 ’ and mux2x1 = ’ 1 ’ ) THEN<br>
33 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
34 ELSE<br>
35 x o r _ p o r t &lt;= ’ 1 ’ ;<br>
36 END IF ;<br>
37 ??INVERSOR<br>
38 IF ( B i n v e r t i d o = ’ 0 ’ ) THEN<br>
39 mux2x1 &lt;= B ;<br>
40 ELSE<br>
41 mux2x1 &lt;= NOT B ;<br>
42 END IF ;<br>
43 ??MUX4X1<br>
44 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
45 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
46 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
47 R e s u l t a d o &lt;= o r _ p o r t ;<br>
48 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
49 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
50 END IF ;<br>
51 <span class='f1 c_3' id='c_3_1' href='#c_3_2' cs_f='.c_3' >END PROCESS ;<br>
52 END</span> U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 42<br>
4.2 Preprocessamento do VHDL e inserção de assertivas<br>
A fase inicial do método consiste no preprocessamento do código VHDL com as an-<br>
otações de código pelo usuário ou pelo método proposto de forma automática, incluindo as<br>
assertivas, conforme a Figura 16, na etapa A. O método não realiza qualquer tipo de verificação<br>
sobre o código VHDL, apenas utiliza o mesmo como entrada juntamente com as assertivas<br>
inseridas. Toda verificação é realizada sobre o código em linguagem C, que será traduzido a<br>
partir do código VHDL analisado, nas próximas etapas do método proposto. Vale ressaltar que<br>
mesmo a linguagem VHDL tendo um modelo de assertivas padrão, para o método tornou-se<br>
necessário a criação de um modelo (baseado em comentários) para que as funções do model<br>
checker adotado fossem suportadas, como a geração de valores não deterministicos.<br>
As assertivas manuais são adicionadas entre as tags @c2vhdl:ASSERT e @c2vhdl:END<br>
e todo trecho de código entre estas tags deve estar comentado, desta forma não apresentará<br>
erro na tradução do código em linguagem C, bem como na sintetização do código VHDL. Nas<br>
assertivas são incluidas as funções necessárias para a análise utilizando a ferramenta ESBMC. A<br>
assertiva apresenta três informações principais, sendo elas: condição, mensagem e gravidade.<br>
Ajustar está assertiva. Para quem não vê o código todo, ela não faz sentido<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR.<br>
1 ??@c2vhdl : ASSERT<br>
2 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ )<br>
3 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 "<br>
4 ??s e v e r i t y ERROR;<br>
5 ??@c2vhdl :END<br>
Fonte: Própria.<br>
A condição (na linha 2 da Figura 19) representa a assertiva propriamente dita e que será<br>
analisado pela aplicação. A condição será precedida de??assert e seguido ou não da palavra<br>
not, com isso a assertiva pode assumir valor negativo, conforme necessidade do usuário. Na<br>
Figura 19 a assertiva busca verificar se a variavél Resultado terá valor igual a 1. Qual a<br>
razão<br>
para<br>
isso,<br>
ex-<br>
plique!<br>
A mensagem (??report na linha 3 da Figura 19) é definida pelo usuário e será<br>
apresentado caso a assertiva apresente falha, assim a mensagem pode ser utilizada como um meio<br>
de depuração das propriedades validadas. A severidade (severity na linha 4 da Figura 19)<br>
pode ser definida como error, que representa um erro fatal e parada da verificação. A severidade<br>
do tipo warning que representa um erro não fatal, contabiliza as falhas das assertivas, porém<br>
não causa a parada da verificação. As mensagens futuramente pode ser integradas um framework<br>
para teste de unidade, contudo está é uma etapa ainda em planejamento neste trabalho.<br>
Juntamente com as assertivas outra função que pode ser utilizada é a função __ESBMC<br>
Chapter 4. MÉTODO PROPOSTO 43<br>
_assume() suportada pelo model checker ESBMC. Esta função utilizada em conjuto com a<br>
ferramenta ESBMC permite que durante a verificação uma variavél possa ter uma valor setado<br>
durante o tempo de execução da verificação. A importância desta função é fazer verificações onde<br>
se conhece os valores de entrada juntamente com o valor resultante, por exemplo, na verificação<br>
de portas lógicas.<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume().<br>
1 ??__ESBMC_assume (A = ’ 1 ’ )<br>
2 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
Fonte: Própria.<br>
A assertivas que serão verificadas são automáticas traduzidas a partir das entradas do<br>
código VHDL. Seja no modelo manual (assertivas escritas pelo usuário) ou automático (inferidas<br>
pelo método proposto por meio de análise estática), as entradas são mapeadas para serem<br>
utilizados na etapa de instrumentação. Desta forma, tais entradas podem ser utilizadas para gerar<br>
essas assertivas e então serem adicionadas diretamente ao código em linguagem C durante a fase<br>
de instrumentação.<br>
A Figura 20 apresenta o código juntamente com as assertivas conforme o padrão salien-<br>
tado na section 4.2. Neste exemplo foi implementado utilizado a inserção manual das assertivas<br>
e também da função __ESBMC_assume(), entretanto o objetivo é automatizar estas funções<br>
durante a execução da ferramenta.<br>
4.3 Tradução de código VHDL para a linguagem C<br>
Nesta etapa a tradução do código VHDL para linguagem C é executada, conforme<br>
apresentado na Figura 16, etapa B. A partir deste ponto, a ferramenta é executada de maneira<br>
propriamente dita, tendo todo o processo automatizado até a apresentação do resultado. Para<br>
esta etapa do método foi selecionado a ferramenta V2Cque realiza a tradução de VHDL para Adicionar<br>
refer-<br>
ência<br>
Linguagem C.<br>
A ferramenta V2C apresenta diversas vantagens em relação a equivalência de tradução<br>
de linguagens, contudo V2C apresenta certas limitação na tradução do código VHDL, em outras<br>
palavras, a mesma não reconhece algumas estruturas especificas do VHDL. A ferramenta aceita<br>
apenas entradas e saídas do tipo: bit, std_ulogic, qsim_state, std_ulogic_vector<br>
e interger. Na parte de arquitetura, a ferramenta aceita uma gama maior de estruturas, tra-<br>
balhando com expressoões do tipo: signal, variable, integers, strings e caracteres.<br>
Em expreções condicionais os operandos são AND, OR, NOT &lt;=, =&gt;,=,&lt;,&gt; e &lt;&gt;. Aceita<br>
também a estrutura de process, além da estutura block. A estrutura process é limitada<br>
Chapter 4. MÉTODO PROPOSTO 44<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 . . .<br>
4 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
5 SIGNAL a n d _ p o r t : b i t ;<br>
6 SIGNAL o r _ p o r t : b i t ;<br>
7 SIGNAL x o r _ p o r t : b i t ;<br>
8 SIGNAL mux2x1 : b i t ;<br>
9 BEGIN<br>
10 PROCESS(A, B , B i n v e r t i d o , Op1 ) IS<br>
11 BEGIN<br>
12 ??PORTA AND<br>
13 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
14 ??__ESBMC_assume (A = ’ 1 ’ )<br>
15 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
16 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
17 ELSE<br>
18 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
19 END IF ;<br>
20 . . .<br>
21 ??MUX4X1<br>
22 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
23 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
24 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
25 R e s u l t a d o &lt;= o r _ p o r t ;<br>
26 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
27 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
28 ??@c2vhdl : ASSERT<br>
29 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
30 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
31 ??s e v e r i t y ERROR;<br>
32 ??@c2vhdl :END<br>
33 END IF ;<br>
34 <span class='f1 c_3' id='c_3_1' href='#c_3_2' cs_f='.c_3' >END PROCESS ;<br>
35 END</span> U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
apenas a: if-else, case e loops. Como trabalho futuro, neste trabalho tem-se buscado<br>
novas abordagens para ampliar o suporte a estruturas não suportadas pelo V2C.<br>
Na tradução é necessário substituir os operadores originais por seus equivalentes em<br>
linguagem C. A excessão são os operadore específicos que gerenciam os valores de bit, tais<br>
como concatenação ou manipulação de partes vertoriais, para os quais são necessários construir<br>
procedimentos especificos em C.<br>
Conforme mostrado na Figura 21, na tradução são gerados vários vetores para suporte<br>
a tradução dos sinais representados no VHDL, sendo eles chg[], old[] e new[]. O vetor<br>
old[] contém o valor do sinais do passo anteriore a partir deste vetor o valor a ser usado nos Confuso<br>
issocálculo é obtido. O vetor new[] representa os novos valores a serem calculados pelos antigose<br>
Qual?<br>
Chapter 4. MÉTODO PROPOSTO 45<br>
o vetor chg[] contém um or exclusivo entre o valor novo e antigo e em caso de alteração entre<br>
os valores é copiado o valor de new[] para old[].<br>
O texto acima está muito confuso, corrigi rapidamente<br>
No código C gerado, os vetores in_data[] e out_data[] contêm os sinais de<br>
entrada e saída, respectivamente. No caso de circuitos sequênciais, o valor do status é inserido<br>
no primeiro (índice 0). A funçãoentão lerá os valores in_data[] e escreverá os resultados do qual?<br>
processamento em out_data[]. Ao final da operações os valores de estado são passado para<br>
out_data[].<br>
Conforme especificado e seguindo os parametros da ferramenta, a mesma realiza a<br>
tradução, mantendo inalterado qualquer fragmento de código que esteja comentado, neste caso,<br>
as assertivas presentes no código VHDL permanecem inalteradas, sendo utilizadas na próxima<br>
etapa do método proposto.<br>
4.4 Instrumentação de código<br>
As assertivas após a tradução permanecem comentadas, sendo necessário prepara-lás, ou<br>
seja traduzi-las, para verificação posterior do código na linguagem em C. Com isso é necessário<br>
uma instrumentação do código para prover suporte as assertivas traduzidas para análise, conforme<br>
apresentado na Figura 16, etapa C.<br>
Todas as etapas da instrumentação são realizados sobre o código C já traduzido. O passo<br>
inicial da instrumentação é a adição da macros no inicio do código C com as definição das<br>
assertivas a serem utilizadas. Na Figura 22 são apresentados os macros utilizadas no código C. A<br>
Linha 1 da figura corresponde a mensagem de erro a ser apresentada e a Linha 2 corresponde<br>
ao modelo da assertiva e a chamanda da macro definida na Linha 1 em caso de falha. Estas<br>
definições para as assertivas também podem ser utilizadas no código C traduzidos sem o uso do<br>
ESBMC.<br>
Figure 22 – Macros das assertivas implementadas em linguagem C<br>
1 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r ,M, __FILE__ , __LINE__ , # # __VA_ARGS__ )<br>
2 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
Fonte: Própria.<br>
O passo seguinte é a identificação das assertivas comentadas ao longo do corpo do<br>
código traduzido, utilizando o exemplo da Figura 23. As assertivas são identificadas através<br>
das tags @c2vhdl:ASSERT e @c2vhdl:END e a busca é realizado através destas tags. Ao<br>
ser encontrado a tag @c2vhdl:ASSERT, é realizado um loop até que seja encontrada a tag<br>
Chapter 4. MÉTODO PROPOSTO 46<br>
@c2vhdl:END e com isso toda a assertiva inserida possa ser passada a função de busca das<br>
informações da assertiva contidas entre as tags apresentadas.<br>
Com os dados das assertivas obtidos é realizado a busca da condição, mensagem e<br>
severidade através dos comandos ??assert, ??report e ??severity respectivamente.<br>
Estas informações são encontradas através do uso e uma Regex no código e que são adicionadas<br>
ao código C seguindo o modelo definido na macro. Este processo é repetido até outra assertiva<br>
ser encontrada ou caso chegue ao fina do código C.<br>
Com a função __ESBMC_assume() ocorre processo semelhante ao das assertivas.<br>
Utilizando novamente uma regex que realiza a busca por esta função no código e é retirado o<br>
comentário da mesma, desta forma a mesma passa a esta acessivél para o ESBMC, visto que a<br>
declaração da mesma já segue o modelo padrão a ser utilizado pelo ESBMC.<br>
Durante a instrumentação de código também é realizado a entrada de sinais não de-<br>
terministicos para variaveis não inicializadas ou argumentos de funções do código C gerado<br>
da tradução, utilizando a função __VERIFIER_nondet_int(). Esta função é utilizada em<br>
todas as variaveis de entrada e também nos sinais criados ao longo da arquitetura. Desta forma,<br>
todas as variavéis necessárias são inicializadas para verificação.<br>
Explicar o funcionamento do nondet com o ESBMC<br>
Em outras palavras, na instrumentação de código é realizado a traduçao das assertivas do<br>
modelo utilizado no código VHDL para para o modelo utilizado em linguagem C, além como de<br>
outras funções que possam ser utilizados pelo VHDL. Ao final da instrumentação o código C<br>
fica disponivel para que possa ser dado como entrada para outras ferramentas de verificação de<br>
código e não apenas o ESBMC.<br>
4.5 Verificação de assertivas usando Model Checker<br>
O model checker adotado no desenvolvimento de método é o ESBMCna versão 3.0.0 referência<br>
e conforme explicado na subsection 2.2.3, esta ferramenta recebe como entrada um código C<br>
ou C++ e devido a isso foi escolhida neste projeto. Nesta seção será apresentado a etapa D do apresentar<br>
outras<br>
vanta-<br>
gens<br>
métod proposto na Figura 16.<br>
Para a verificação, a primeira etapa é a identificação das assertivas no código C analisado,<br>
para isso é utilizado uma opção do ESBMC (??show-claims), mais especificamente as<br>
assertivas instrumentadas no código C analisado. Cada assertiva é identificada através de uma<br>
numeração de acordo com a ordem de busca do código analisado. Cada assertiva encontrada é<br>
armazenada para que seja realizada uma análise individual de cada claim, ou seja, assertiva.<br>
Chapter 4. MÉTODO PROPOSTO 47<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas.<br>
1 VAR<br>
2 c o n t a d o r : i n t e i r o<br>
3 c l a i m : l i s t a<br>
4 c l a i m _ s t r i n g : s t r i n g<br>
5<br>
6 FUNCAO c a l l _ e s b m c : a r q u i v o<br>
7 c o n t a d o r &lt;?0<br>
8 INICIO<br>
9 s a i d a &lt;?f un ca o de g e r a c a o das c l a i m s p e l o ESBMC<br>
10 ENQUANTO c o n t a d o r &lt; s a i d a FACA<br>
11 c o n t a d o r +=2<br>
12 r e g e x p a r a p r o c u r a r c l a i m e numeracao da c l a i m<br>
13 SE e n c o n t r a r c l a i m ENTAO<br>
14 r e g e x p a r a p r o c u r a r a p a l a v r a " a s s e r t i o n "<br>
15 SE e n c o n t r a r a p a l a v r a " a s s e r t i o n " ENTAO<br>
16 c o n t a d o r +=1<br>
17 A d i c i o n a a numeracao da c l a i m na l i s t a<br>
18 FIM?SE<br>
19 FIM?SE<br>
20 FIM?ENQUANTO<br>
21 FIM?FUNCAO<br>
Fonte: Própria.<br>
Na Linha 9 da Figura 24 é apresentado a chamada da ferramenta ESBMC que ocorre e<br>
através da opção ??show-claims lista todas as claims presentes no texto, como apresentado<br>
na Figura 25. Como o ESBMC infere de forma automatica assertivas a serem verificadas no<br>
código. Visando isolar somente as assertivas instrumentadas pelo método proposto, juntamente<br>
com a opção –show-claims é utilizado as opções:<br>
• ??no-pointer-check: para não realizar a checagem de ponteiros no código;<br>
• ??no-div-by-zero-check: para não realizar a checagem de divisões por zero no<br>
código; e<br>
• ??no-bounds-check: para não realizar a checagem de array bounds no código.<br>
Chapter 4. MÉTODO PROPOSTO 48<br>
Figure 25 – Imagem de claims contendo assertivas.<br>
Fonte:Própria<br>
Após a listagem das claims com assertivas ser gerada, outra função, indicada na Figura 26,<br>
é chamada para verificação de cada claim individualmente. Para cada claim, ocorre a chamada do<br>
ESBMC, utilizando as opções ??no-pointer-check, ??no-div-by-zero-check e<br>
??no-bounds-check, juntamente com a opção ??unwind em que realiza o número de<br>
desdobramentos dos laços no código analisado.<br>
Contudo, dependendo da complexidade da assertiva, faz-se necessário aumentar o número<br>
de desdobramentos que, por padrão são dez, conforme análise experimentais. A função é chamada<br>
na Linha 11 da Figura 26 e após a analise da claim é realizado a busca do resultado e exibição<br>
caso seja uma propriedade violada.<br>
Desta forma o ESBMC realiza apenas a checagem necessária dentro da assertiva, evitando<br>
que outros parâmetros sejam verificados, sem a devida necessidade do mesmo. Ao final de todos<br>
os desdobramentos é apresentado o resultado, apresentado na Figura 27, sendo positiva (sem<br>
erros) ou negativa (com violação de propriedades), dependendo da assertiva e do código analisado.<br>
Este processo se repete até a lista de assertivas ser finalizada.<br>
Chapter 4. MÉTODO PROPOSTO 49<br>
Figure 26 – Pseudocódigo da função de análise das claims.<br>
1 VAR<br>
2 c o n t a d o r 1 : i n t e i r o<br>
3 c o n t a d o r 2 : i n t e i r o<br>
4 r e s u l t a d o : l i s t a<br>
5<br>
6 FUNCAO esbmc_c la ims : l i s t a , a r q u i v o<br>
7 c o n t a d o r 1 &lt;?0<br>
8 c o n t a d o r 2 &lt;?0<br>
9 busca p e l <span class='f1 c_8' id='c_8_1' href='#c_8_2' cs_f='.c_8' >o nome da</span> fu nc a o no a r q u i v o<br>
10 ENQUANTO c o n t a d o r &lt; l i s t a FACA<br>
11 s a i d a &lt;?Execu ta comando de a n a l i s e da c l a i m<br>
numerada na l i s t a<br>
12 ENQUANTO c o n t a d o r 2 &lt; s a i d a<br>
13 Regex busca se a p r o p r i e d a d e f o i v i o l a d a<br>
14 SE p r o p r i e d a d e f o i v i o l a d a ENTAO<br>
15 Pu la p a r a l i n h a da v i o l a ç ã o<br>
16 A d i c i o n a o e r r o ao r e s u l t a d o<br>
17 FIM?SE<br>
18 FIM?ENQUANTO<br>
19 FIM?ENQUANTO<br>
20 FIM?FUNCAO<br>
Fonte: Própria.<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta.<br>
Fonte:Própria<br>
Ajustar os códigos, alguns estao muito grandes e com trechos desnecessário, não foi<br>
citado o link do repo da ferramenta<br>
Chapter 4. MÉTODO PROPOSTO 50<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C.<br>
1 void u l a _ t c c ( i n t i n _ d a t a [ ] , i n t o u t _ d a t a [ ] )<br>
2 {<br>
3 i n t _ i _ =0;<br>
4 i n t _c on t_ ;<br>
5 enum s e g n a l e {A, B , B i n v e r t i d o , Op1 , Op2 , R e s u l t a d o , and_po r t , o r _ p o r t ,<br>
6 x o r _ p o r t , mux2x1 , _MAX_} ;<br>
7 i n t o l d [_MAX_ ] ;<br>
8 i n t new [_MAX_ ] ;<br>
9 i n t chg [_MAX_ ] ;<br>
10 new [A] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
11 new [B] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
12 new [ B i n v e r t i d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
13 new [ Op1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
14 new [ Op2 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
15 new [ R e s u l t a d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
16 new [ a n d _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
17 new [ o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
18 new [ x o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
19 new [ mux2x1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
20<br>
21 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
22 {<br>
23 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
24 }<br>
25 new [A] = i n _ d a t a [ 1 ] ;<br>
26 new [B] = i n _ d a t a [ 2 ] ;<br>
27 new [ B i n v e r t i d o ] = i n _ d a t a [ 3 ] ;<br>
28 new [ Op1 ] = i n _ d a t a [ 4 ] ;<br>
29 new [ Op2 ] = i n _ d a t a [ 5 ] ;<br>
30<br>
31 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
32 {<br>
33 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
34 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
35 }<br>
36<br>
37 do {<br>
38 _ co n t _ =0;<br>
39 /? S t a r t o f T r a n s l a t i o n ? /<br>
40<br>
41 /? p0 : ? /<br>
42 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
43 /?PORTA AND ? /<br>
44 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
45 \ \ __ESBMC_assume ( o l d [A] = 1) ;<br>
46 \ \ __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
47 new [ a n d _ p o r t ] = 1 ;<br>
48 }<br>
49 e l s e {<br>
50 new [ a n d _ p o r t ] = 0 ;<br>
51 }<br>
52 /?PORTA OR ? /<br>
53 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
54 new [ a n d _ p o r t ] = 0 ;<br>
55 }<br>
56 e l s e {<br>
57 new [ a n d _ p o r t ] = 1 ;<br>
58 }<br>
59 /?PORTA XOR ? /<br>
60 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
61 new [ x o r _ p o r t ] = 0 ;<br>
62 }<br>
63 e l s e i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==1) ) {<br>
64 new [ x o r _ p o r t ] = 0 ;<br>
65 }<br>
66 e l s e {<br>
67 new [ x o r _ p o r t ] = 1 ;<br>
68 }<br>
69 /? INVERSOR ? /<br>
70 i f ( ( o l d [ B i n v e r t i d o ]==0) ) {<br>
71 i f ( chg [B ] ) {<br>
72 new [ mux2x1 ]= o l d [B ] ;<br>
73 }<br>
74 }<br>
75 e l s e {<br>
76 i f ( chg [B ] ) {<br>
77 new [ mux2x1 ]=~ o l d [B ] ;<br>
78 }<br>
79 }<br>
80 /?MUX4X1 ? /<br>
81 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
82 i f ( chg [ a n d _ p o r t ] ) {<br>
83 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
84 \ \ @c2vhdl : ASSERT<br>
85 \ \ a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
86 \ \ r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
87 \ \ s e v e r i t y ERROR;<br>
88 \ \ @c2vhdl :END<br>
89 }<br>
90 }<br>
91 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
92 i f ( chg [ o r _ p o r t ] ) {<br>
93 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
94 }<br>
95 }<br>
96 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
97 i f ( chg [ x o r _ p o r t ] ) {<br>
98 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
99 }<br>
100 }<br>
101 }<br>
102<br>
103 /? End o f T r a n s l a t i o n ? /<br>
104 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
105 {<br>
106 i f ( new [ _ i _ ] ! = o l d [ _ i _ ] ) _ con t_ =1;<br>
107 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
108 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
109 }<br>
110 } whi le ( _c on t_ ) ;<br>
111<br>
112 new [A] &= 0X01 ;<br>
113 new [B] &= 0X01 ;<br>
114 new [ B i n v e r t i d o ] &= 0X01 ;<br>
115 new [ Op1 ] &= 0X01 ;<br>
116 new [ Op2 ] &= 0X01 ;<br>
117 new [ R e s u l t a d o ] &= 0X01 ;<br>
118 new [ a n d _ p o r t ] &= 0X01 ;<br>
119 new [ o r _ p o r t ] &= 0X01 ;<br>
120 new [ x o r _ p o r t ] &= 0X01 ;<br>
121 new [ mux2x1 ] &= 0X01 ;<br>
122<br>
123 o u t _ d a t a [ 0 ] = 0 ; _ i _ =0;<br>
124 o u t _ d a t a [ 0 ] | = new [A] &lt;&lt; _ i _ ; _ i _ +=1;<br>
125 o u t _ d a t a [ 0 ] | = new [B] &lt;&lt; _ i _ ; _ i _ +=1;<br>
126 o u t _ d a t a [ 0 ] | = new [ B i n v e r t i d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
127 o u t _ d a t a [ 0 ] | = new [ Op1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
128 o u t _ d a t a [ 0 ] | = new [ Op2 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
129 o u t _ d a t a [ 0 ] | = new [ R e s u l t a d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
130 o u t _ d a t a [ 0 ] | = new [ a n d _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
131 o u t _ d a t a [ 0 ] | = new [ o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
132 o u t _ d a t a [ 0 ] | = new [ x o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
133 o u t _ d a t a [ 0 ] | = new [ mux2x1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
134<br>
135 o u t _ d a t a [ 1 ] = new [ R e s u l t a d o ] ;<br>
136 }<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 51<br>
Figure 23 – Código com assertivas traduzida para linguagem C<br>
1 # inc lude &lt; s t d i o . h&gt;<br>
2 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r , M , __FILE__ , __LINE__ , ##<br>
__VA_ARGS__ ) / / Update t o p r i n t t h e t r a c e<br>
3 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
4<br>
5 . . .<br>
6<br>
7 do {<br>
8 _co n t _ =0;<br>
9 /? S t a r t o f T r a n s l a t i o n ? /<br>
10 chg [A] = __VERIFIER_nondet_int ( ) ;<br>
11 chg [B] = __VERIFIER_nondet_int ( ) ;<br>
12 chg [ B i n v e r t i d o ] = __VERIFIER_nondet_int ( ) ;<br>
13 chg [ Op1 ] = __VERIFIER_nondet_int ( ) ;<br>
14 chg [ a n d _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
15 chg [ R e s u l t a d o ] = __VERIFIER_nondet_int ( ) ;<br>
16 chg [ o r _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
17 chg [ mux2x1 ] = __VERIFIER_nondet_int ( ) ;<br>
18<br>
19 /? p0 : ? /<br>
20 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
21 /?PORTA AND ? /<br>
22 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
23 __ESBMC_assume ( o l d [A] = 1) ;<br>
24 __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
25 new [ a n d _ p o r t ] = 1 ;<br>
26 }<br>
27 e l s e {<br>
28 new [ a n d _ p o r t ] = 0 ;<br>
29 }<br>
30<br>
31 . . .<br>
32<br>
33 /?MUX4X1 ? /<br>
34 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
35 i f ( chg [ a n d _ p o r t ] ) {<br>
36 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
37 __MY_asser t ( new [ R e s u l t a d o ] == 1 , "O r e s u l t a d o é d i f e r e n t e de 0 " ) ;<br>
38 }<br>
39 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
40 i f ( chg [ o r _ p o r t ] ) {<br>
41 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
42 }<br>
43 }<br>
44 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
45 i f ( chg [ x o r _ p o r t ] ) {<br>
46 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
47 }<br>
48 }<br>
49 }<br>
50<br>
51 /? End o f T r a n s l a t i o n ? /<br>
52 . . .<br>
Fonte: Própria.<br>
52<br>
5 CRONOGRAMA<br>
53<br>
6 CONSIDERAÇÕES PARCIAIS E<br>
TRABALHOS FUTUROS<br>
O trabalho aborda o desenvolvimento de um método para análise de circuitos lógicos de-<br>
scrito em VHDL através da aplicação de técnica de transformação de código e a técnica Bounded<br>
Model Cheking. Este método tem como objetivo de explorar os estados alcanç alcançáveis no<br>
circuito, e dessa forma identificar erros que possam resutar em mal funcionamento do sistema.<br>
Entre as dificuldade encontradas, a principal esta ligada a etapa de tradução de código.<br>
Devido a ferramenta utilizada inicialmente conter diversas limitações, a mesma diminui a eficácia<br>
da ferramenta, pois a quantidade de estruturas que podem ser utilizadas é limitada e com isso<br>
limitando também o processo de criação de protótipos.<br>
Os trabalhos futuros é necessário buscar uma nova ferramenta ou método de tradução<br>
que tenha uma gama maior de tradução, seja em estruturas ou palavras reservadas,deste forma<br>
o método desenvlvido torna-se mais eficiente e gerando uma menor intervenção do usuário no<br>
código VHDL. A melhoria na tradução de código também beneficia ageração das assertivas<br>
automáticamente, pois com uma gama maior de estruturas suportadas, mais assertivas podem ser<br>
geradas.<br>
Além disso a geração automática das assertivas é Outro ponto abordado, já sitado anterior-<br>
mente, é a geração automática das assertivas, visto que na estapa atual ainda nõ foi implementado.<br>
Este recuros visa da liberdade ao desenvolvedor promovendo de maneira automática os teste<br>
sobre o código, não necessitando que uma intervenção, tornando a inserção manual apenas em<br>
casos especificos de testes.<br>
54<br>
BIBLIOGRAPHY<br>
ABE, J. Introducao a Logica Para a Ciencia Da Computacao. Arte & Ciência, 2002. ISBN<br>
9788574730455. Disponível em: &lt;https://books.google.com.br/books?id=AgBJdjoNPwUC&gt;.<br>
ACM. 2018. Acessado em: 01 de março de 2018. Disponível em: &lt;http://dl.acm.org/&gt;.<br>
AHO, A. V.; SETHI, R.; ULLMAN, J. D. Compilers: principles, techniques, and tools. [S.l.]:<br>
Addison-wesley Reading, 2007. v. 2.<br>
ALLEN, F. E. Control flow analysis. In: ACM. ACM Sigplan Notices. [S.l.], 1970. v. 5, n. 7, p.<br>
1–19.<br>
BAIER, C.; KATOEN, J.-P.; LARSEN, K. G. Principles of model checking. [S.l.]: MIT press,<br>
2008.<br>
BARA, A. et al. Formal verification of timed vhdl programs. In: IET. FDL. [S.l.], 2010. p.<br>
80–85.<br>
BASILI, V. R.; CALDIERA, G.; ROMBACH, H. D. Experience factory. Encyclopedia of<br>
software engineering, Wiley Online Library, 1994.<br>
BENSALEM, S.; LAKHNECH, Y. Automatic generation of invariants. Formal Methods in<br>
System Design, Springer, v. 15, n. 1, p. 75–92, 1999.<br>
BIERE, A. The aiger and-inverter graph (aig) format. Available at http://fmv.jku.at/aiger, 2016.<br>
BIOLCHINI, J. et al. Systematic review in software engineering. System Engineering and<br>
Computer Science Department COPPE/UFRJ, Technical Report ES, v. 679, n. 05, p. 45, 2005.<br>
BOULE, M.; ZILIC, Z. Incorporating efficient assertion checkers into hardware emulation. In:<br>
IEEE. Computer Design: VLSI in Computers and Processors, 2005. ICCD 2005. Proceedings.<br>
2005 IEEE International Conference on. [S.l.], 2005. p. 221–228.<br>
BOULE, M.; ZILIC, Z. Efficient automata-based assertion-checker synthesis of seres for<br>
hardware emulation. In: IEEE COMPUTER SOCIETY. Proceedings of the 2007 Asia and South<br>
Pacific Design Automation Conference. [S.l.], 2007. p. 324–329.<br>
BRAYTON, R.; MISHCHENKO, A. Abc: An academic industrial-strength verification tool. In:<br>
SPRINGER. Computer Aided Verification. [S.l.], 2010. p. 24–40.<br>
B.V. 2018. Acessado em 1 de março de 2018. Disponível em: &lt;http://www.sciencedirect.com/&gt;.<br>
CABODI, G. et al. Hardware model checking competition 2014: an analysis and comparison of<br>
solvers and benchmarks. Journal on Satisfiability, Boolean Modeling and Computation, v. 9, p.<br>
135–172, 2016.<br>
CAPPELATTI, D. Praticando VHDL. Editora Feevale, 2010. ISBN 9788577171200. Disponível<br>
em: &lt;https://books.google.com.br/books?id=z4\_CYog\_UskC&gt;.<br>
Bibliography 55<br>
CHRISTEN, E.; BAKALAR, K. Vhdl-ams-a <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >hardware description language</span> for analog and<br>
mixed-signal applications. IEEE Transactions on Circuits and Systems II: Analog and Digital<br>
Signal Processing, IEEE, v. 46, n. 10, p. 1263–1272, 1999.<br>
CHU, P. P. RTL hardware design using VHDL: coding for efficiency, portability, and scalability.<br>
[S.l.]: John Wiley & Sons, 2006.<br>
CLARKE, E. et al. Verification of hybrid systems based on counterexample-guided abstraction<br>
refinement. In: SPRINGER. TACAS. [S.l.], 2003. v. 3, p. 192–207.<br>
CLARKE, E. M. The birth of model checking. In: 25 Years of Model Checking. [S.l.]: Springer,<br>
2008. p. 1–26.<br>
CLARKE, E. M.; GRUMBERG, O.; LONG, D. E. Model checking and abstraction. ACM<br>
transactions on Programming Languages and Systems (TOPLAS), ACM, v. 16, n. 5, p.<br>
1512–1542, 1994.<br>
CORDEIRO, L.; FISCHER, B.; MARQUES-SILVA, J. Smt-based bounded model checking for<br>
embedded ansi-c software. IEEE Transactions on Software Engineering, IEEE, v. 38, n. 4, p.<br>
957–974, 2012.<br>
COUSOT, P.; COUSOT, R. A gentle introduction to formal verification of computer systems by<br>
abstract interpretation. [S.l.]: IOS Press, 2010.<br>
DAHAN, A. et al. Combining system level modeling with assertion based verification. In: Sixth<br>
international symposium on quality electronic design (isqed’05). [S.l.: s.n.], 2005. p. 310–315.<br>
ISSN 1948-3287.<br>
D’SILVA, V.; KROENING, D.; WEISSENBACHER, G. A survey of automated techniques<br>
for formal software verification. IEEE Transactions on Computer-Aided Design of Integrated<br>
Circuits and Systems, IEEE, v. 27, n. 7, p. 1165–1178, 2008.<br>
ELSEVIER. 2017. Acessado em: 01 março 2018. Disponível<br>
em: &lt;https://www.elsevier.com/__data/assets/pdf_file/0007/69451/<br>
0597-Scopus-Content-Coverage-Guide-US-LETTER-v4-HI-singles-no-ticks.pdf&gt;.<br>
G1. Acidente foi provocado por falha em circuito eletrônico, diz se-<br>
cretário. 2012. Disponível em: &lt;http://g1.globo.com/sao-paulo/noticia/2012/05/<br>
acidente-foi-provocado-por-falha-em-circuito-eletronico-diz-secretario.html&gt;.<br>
GUGLIELMO, G. D. et al. On the use of assertions for embedded-software dynamic verification.<br>
In: IEEE. Design and Diagnostics of Electronic Circuits & Systems (DDECS), 2012 IEEE 15th<br>
International Symposium on. [S.l.], 2012. p. 330–335.<br>
GUPTA, A. Formal hardware verification methods: A survey. In: SPRINGER. Computer-Aided<br>
Verification. [S.l.], 1992. p. 5–92.<br>
HALDER, A.; VENKATESWARLU, A. A study of petri nets modeling analysis and simulation.<br>
Department of Aerospace Engineering Indian Institute of Technology Kharagpur, India, 2006.<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Interpolation and symbol elimination in vampire.<br>
Automated Reasoning, Springer, p. 188–195, 2010.<br>
Bibliography 56<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Case studies on invariant generation using a<br>
saturation theorem prover. Advances in Artificial Intelligence, Springer, p. 1–15, 2011.<br>
IDOETA, I. V.; CAPUANO, F. G. Elementos de eletrônica digital. [S.l.]: Livros Erica, 1982.<br>
IEC/IEEE International Standard - Behavioural languages - Part 1-1: VHDL Language<br>
Reference Manual. IEC 61691-1-1:2011(E) IEEE Std 1076-2008, p. 1–648, May 2011.<br>
IEEE. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http://ieeexplore.ieee.org/<br>
Xplore/home.jsp&gt;.<br>
IEEE Standard for Property Specification Language (PSL). IEEE Std 1850-2010 (Revision of<br>
IEEE Std 1850-2005), p. 1–182, April 2010.<br>
IEEE Standard for Verilog <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >Hardware Description Language</span>. IEEE Std 1364-2005 (Revision of<br>
IEEE Std 1364-2001), p. 1–560, 2006.<br>
KITCHENHAM, B. Procedures for performing systematic reviews. Keele, UK, Keele University,<br>
v. 33, n. 2004, p. 1–26, 2004.<br>
KITCHENHAM, B. et al. Systematic literature reviews in software engineering–a systematic<br>
literature review. Information and software technology, Elsevier, v. 51, n. 1, p. 7–15, 2009.<br>
KNOOP, J.; RÜTHING, O.; STEFFEN, B. Partial dead code elimination. [S.l.]: ACM, 1994.<br>
v. 29.<br>
KOSCIANSKI, A.; SOARES, M. dos S. Qualidade de Software - 2a Edição: Aprenda as<br>
metodologias e técnicas mais modernas para o desenvolvimento de software. Novatec,<br>
2007. ISBN 9788575221129. Disponível em: &lt;https://books.google.com.br/books?id=<br>
O9aWoUq6L88C&gt;.<br>
KROPF, T. Introduction to Formal Hardware Verification. Springer Berlin Heidelberg,<br>
2013. ISBN 9783662038093. Disponível em: &lt;https://books.google.com.br/books?id=<br>
7ImrCAAAQBAJ&gt;.<br>
MAFRA, S. N.; TRAVASSOS, G. H. Estudos primarios e secundarios apoiando a busca por<br>
evidencia em engenharia de software. Relatorio Tecnico, RT-ES, v. 687, n. 06, 2006.<br>
MUKHERJEE, R. et al. Unbounded safety verification for hardware using software analyzers.<br>
In: EDA CONSORTIUM. Proceedings of the 2016 Conference on Design, Automation & Test in<br>
Europe. [S.l.], 2016. p. 1152–1155.<br>
MUKHERJEE, R.; TAUTSCHNIG, M.; KROENING, D. v2c–a verilog to c translator. In:<br>
SPRINGER. International Conference on Tools and Algorithms for the Construction and<br>
Analysis of Systems. [S.l.], 2016. p. 580–586.<br>
MURATA, T. Petri nets: Properties, analysis and applications. Proceedings of the IEEE, IEEE,<br>
v. 77, n. 4, p. 541–580, 1989.<br>
RAMESH, U. B. K.; SENTILLES, S.; CRNKOVIC, I. Energy management in embedded<br>
systems: Towards a taxonomy. In: IEEE PRESS. Proceedings of the First International<br>
Workshop on Green and Sustainable Software. [S.l.], 2012. p. 41–44.<br>
ROCHA, H. et al. Exploiting safety properties in bounded model checking for test cases<br>
generation of c programs. 2010.<br>
Bibliography 57<br>
ROCHA, H. et al. Model checking embedded c software using k-induction and invariants<br>
(extended version). arXiv preprint arXiv:1509.02471, 2015.<br>
ROCHA, H. O. et al. Verificacao de sistemas de software baseada em transformacoes de codigo<br>
usando bounded model checking. Universidade Federal do Amazonas, 2015.<br>
SARGENT, R. G. Verification and validation of simulation models. In: WINTER SIMULATION<br>
CONFERENCE. Proceedings of the 37th conference on Winter simulation. [S.l.], 2005. p.<br>
130–143.<br>
SEGER, C.-J. An introduction to formal hardware verification. [S.l.]: University of British<br>
Columbia, Department of Computer Science, 1992.<br>
SOMMERVILLE, I. Engenharia de software. PEARSON BRASIL, 2011. ISBN 9788579361081.<br>
Disponível em: &lt;https://books.google.com.br/books?id=H4u5ygAACAAJ&gt;.<br>
SONS, J. W. . 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http:<br>
//onlinelibrary.wiley.com/&gt;.<br>
SOUZA, J. Lógica para Ciência da Computação. Elsevier Brasil, 2017. ISBN 9788535278255.<br>
Disponível em: &lt;https://books.google.com.br/books?id=Ds2sCQAAQBAJ&gt;.<br>
SPRINGER. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;https:<br>
//link.springer.com/&gt;.<br>
SRIKANT, Y.; SHANKAR, P. The Compiler Design Handbook: Optimizations and<br>
Machine Code Generation. CRC Press, 2002. ISBN 9781420040579. Disponível em:<br>
&lt;https://books.google.com.br/books?id=0K\_jIsgyNpoC&gt;.<br>
THOMAS, D.; MOORBY, P. The Verilog R© <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >Hardware Description Language</span>. Springer<br>
US, 2008. ISBN 9780387853444. Disponível em: &lt;https://books.google.com.br/books?id=<br>
DxQGrz7q-SwC&gt;.<br>
TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L. Sistemas digitais: princípios e aplicações. [S.l.]:<br>
Prentice Hall, 2003. v. 8.<br>
TRAVASSOS, G. H. et al. An environment to support large scale experimentation in software<br>
engineering. In: IEEE. Engineering of Complex Computer Systems, 2008. ICECCS 2008. 13th<br>
IEEE International Conference on. [S.l.], 2008. p</div>
<!-- DIVISOR_DIV_CANDIDATE -->

<div class='divisor divisor-texto' id="cand__file7"><hr class='text-separator'><br>Input file: <a href='#'>main.pdf</a> (12773 chunks)<br>File found: <a href='https://arxiv.org/pdf/1504.01027' target='_blank'>https://arxiv.org/pdf/1504.01027</a> (22619 chunks)<br><br>Chunks in common: 332<br>Similarity: 0.94%<br><br><div class='textInfo'>The following is the content of the document <br>&nbsp;"<b>main.pdf</b>". <br>The terms in red were found in the document <br>&nbsp;"<b>https://arxiv.org/pdf/1504.01027</b>".<br><hr class='text-separator'></div>  UNIVERSIDADE FEDERAL DE RORAIMA<br>
PRÓ-REITORIA DE ENSINO E EXTENSÃO<br>
DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código<br>
com Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau<br>
de Bacharel em Ciência da Computação.<br>
Orientador: Dr. Herbert Oliveira Rocha<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau de<br>
Bacharel em Ciência da Computação.<br>
Defendido em 06 de março de 2017 e<br>
aprovado pela seguinte banca examinadora:<br>
Prof. Dr. Herbert Oliveira Rocha<br>
Orientador / Curso de Ciência da Computação -<br>
UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Fazer dedicatória<br>
ACKNOWLEDGEMENTS<br>
Fazer agradecimentos!!<br>
Procurar frase massa!!<br>
ABSTRACT<br>
Fazer resumo!!<br>
Palavras-chaves: ??<br>
ABSTRACT<br>
Fazer Abstract!!<br>
Key-words: ??<br>
LISTA DE FIGURAS<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog. . . . . . . . . . . . . . . . 15<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL. . . . . . . . . . . . . . . . . 16<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade. . . . . . . . . . . . . . . 17<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL. . . . . . . . . . . . . . . . 17<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1. . . . . . . . . . 18<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas. . . . . . . . . 18<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas. . . . . . . . . . 19<br>
Figure 8 – Arvore de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
Figure 9 – Rede de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL. . . . . . . . . . . . . . . . . 27<br>
Figure 11 – Trecho de código em VHDL representando porta AND. . . . . . . . . . . . 28<br>
Figure 12 – Trecho de código traduzido para linguagem C. . . . . . . . . . . . . . . . . 29<br>
Figure 13 – Exemplo de bloco basico de código. . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 14 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 15 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 31<br>
Figure 16 – Ciclo da ferramenta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR. . . . . . . 41<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR. . . . . . . . . . . . . . 42<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume(). . . . . . . . . . . 43<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19. . . . . . . . . . . . . . . 44<br>
Figure 22 – Macros das assertivas implementadas em linguagem C . . . . . . . . . . . . 45<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas. . . . . . . 47<br>
Figure 25 – Imagem de claims contendo assertivas. . . . . . . . . . . . . . . . . . . . . 48<br>
Figure 26 – Pseudocódigo da função de análise das claims. . . . . . . . . . . . . . . . . 49<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta. . . . . . . . . . . . . . 49<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C. . . . . . . . . . . . . 50<br>
Figure 23 – Código com assertivas traduzida para linguagem C . . . . . . . . . . . . . . 51<br>
LISTA DE TABELAS<br>
Table 1 – Objetivo do estudo utilizando <span class='f1 c_314' id='c_314_1' href='#c_314_2' cs_f='.c_314' >o paradigma GQM</span> . . . . . . . . . . . . . . . 33<br>
SUMÁRIO<br>
1 INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11<br>
1.1 Definição do problema . . . . . . . . . . . . . . . . . . . . . . . . . . . 12<br>
1.2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13<br>
1.3 Organização do trabalho . . . . . . . . . . . . . . . . . . . . . . . . . 14<br>
2 CONCEITOS E DEFINIÇÕES . . . . . . . . . . . . . . . . . . . . . . 15<br>
2.1 Linguagens de descrição de hardware . . . . . . . . . . . . . . . . . 15<br>
2.1.1 VHSIC Hardware Description Language - VHDL . . . . . . . . . . . . . 16<br>
2.1.2 Portas lógicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18<br>
2.2 Verificação de sistemas . . . . . . . . . . . . . . . . . . . . . . . . . . 19<br>
2.2.1 Diagrama de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.2 Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.3 Bounded Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . 21<br>
2.2.4 Redes de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22<br>
2.2.5 Verificação de hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
2.2.6 Verificação formal de software . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.7 Lógica proposicional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.8 Linguagem de especificação de propriedades . . . . . . . . . . . . . . 26<br>
2.2.9 Verificação baseada em assertivas . . . . . . . . . . . . . . . . . . . . 26<br>
2.2.10 Propriedades de segurança . . . . . . . . . . . . . . . . . . . . . . . . 27<br>
2.3 Técnicas de compiladores . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.1 Transformações de código . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2 Otimização de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2.1 Grafo Acliclico Direcional - GAD . . . . . . . . . . . . . . . . . . . . . . . . 29<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.3 Eliminção de código morto . . . . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.4 Análise do fluxo de dados . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
2.3.2.5 Gerador de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
3 TRABALHOS CORRELATOS . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1 Revisão sistemática . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1.1 Planejamento da Revisão Sistemática . . . . . . . . . . . . . . . . . . 33<br>
3.1.1.1 Procedimentos de Seleção e Critérios . . . . . . . . . . . . . . . . . . . . 35<br>
3.2 Revisão da literatura . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.1 V2c-A verilog to C translator . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.2 Unbounded safety verification for hardware using software analyzers . 37<br>
3.2.3 Formal verification of timed VHDL programs . . . . . . . . . . . . . . . 38<br>
3.2.4 On the use of assertions for embedded-software dynamic verification 38<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation . . 39<br>
4 MÉTODO PROPOSTO . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.1 Visão geral do método . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.2 Preprocessamento do VHDL e inserção de assertivas . . . . . . . 42<br>
4.3 Tradução de código VHDL para a linguagem C . . . . . . . . . . . . 43<br>
4.4 Instrumentação de código . . . . . . . . . . . . . . . . . . . . . . . . 45<br>
4.5 Verificação de assertivas usando Model Checker . . . . . . . . . . 46<br>
5 CRONOGRAMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52<br>
6 CONSIDERAÇÕES PARCIAIS E TRABALHOS FUTUROS . . . . . 53<br>
BIBLIOGRAPHY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54<br>
11<br>
1 INTRODUÇÃO<br>
A complexidade de sistemas computacionais cresce exponencialmente. Muitas compan- Exemplificar<br>
este<br>
cresci-<br>
mento.<br>
hias e organizações estão rotineiramente lidando com software que contém milhares de linhas<br>
de código, escritos por diferentes pessoas, que usam linguagens distintas, ferramentas, estilos e<br>
hardware projetados de diversas formas e combinações (HODER et al., 2011).<br>
No contexto de sistemas compostos de hardware e software, tem-se os sistemas embarca-<br>
dos (SE) que são dispositivos semicondutores com software integrados, <span class='f1 c_207' id='c_207_1' href='#c_207_2' cs_f='.c_207' >os quais se</span> conectam<br>
a outros dispositivos. Usualmente, o principal propósito dos SE é o controle e provimento de<br>
informações para uma função específica (RAMESH et al., 2012).<br>
Os SE são extremamente interativos com seu ambiente, operam geralmente <span class='f1 c_142' id='c_142_1' href='#c_142_2' cs_f='.c_142' >em tempo real<br>
e</span> estão disponíveis continuamente. No entanto, estes sistemas, por possuírem um curto espaço<br>
de tempo para a liberação do produto ao mercado, precisam ser desenvolvidos rapidamente e<br>
atingir um alto nível de qualidade, mas, devido a esta necessidade, os programadores podem<br>
cometer enganos <span class='f1 c_306' id='c_306_1' href='#c_306_2' cs_f='.c_306' >durante a fase de</span> desenvolvimento destes sistemas.<br>
Os SE têm se proliferado em partes consideráveis das atividades do nosso cotidiano,<br>
com a característica de possuir grande quantidade de complexidade e diversidade. Devido a esta<br>
complexidade, erros podem passar despercebidos, causando não apenas penalidades econômicas<br>
e/ou fracassos do produto no mercado, mas principalmente o risco de perda de vidas humanas<br>
(CABODI et al., 2016). Como, <span class='f1 c_278' id='c_278_1' href='#c_278_2' cs_f='.c_278' >por exemplo, o</span> acidente noticiado no (G1, 2012), no qual, <span class='f1 c_195' id='c_195_1' href='#c_195_2' cs_f='.c_195' >de<br>
acordo com</span> o secretário de transportes, uma falha na placa do circuito eletrônico responsável<br>
pelo controle de velocidade dos trens ocasionou a colisão entre duas composições na estação de<br>
metrô de São Paulo.<br>
Segundo ROCHA et al.2015b, <span class='f1 c_272' id='c_272_1' href='#c_272_2' cs_f='.c_272' >para se obter um</span> alto nível de qualidade no desenvolvi-<br>
mento <span class='f1 c_236' id='c_236_1' href='#c_236_2' cs_f='.c_236' >dos sistemas de</span> hardware e software, a execução desses sistemas deve ser controlada e da<br>
mesma forma deve-se buscar meios de <span class='f1 c_61' id='c_61_1' href='#c_61_2' cs_f='.c_61' >garantir que as</span> propriedades definidas sejam atingidas. Por<br>
exemplo, <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >a partir do</span> conhecimento prévio do modo de implementação de determinado hardware,<br>
é possível utilizá-lo de forma mais eficiente. Neste sentido, diversas estratégias de verificação e<br>
de teste estão sendo pesquisadas e aplicadas para <span class='f1 c_116' id='c_116_1' href='#c_116_2' cs_f='.c_116' >garantir a qualidade do</span> software e hardware<br>
(HODER et al., 2010; ROCHA et al., 2010; BRAYTON; MISHCHENKO, 2010; CORDEIRO et<br>
al., 2012; CABODI et al., 2016).<br>
Por este motivo, com o intuito de analisar e otimizar a descrição dos circuitos digitais,<br>
tem-se utilizado as linguagens de descrição de hardware (HDL). Estas se diferem das linguagens<br>
de programação por conseguirem gerar execuções não apenas sequenciais, como também con-<br>
correntes ou paralelas (CHU, 2006). Neste contexto, a VHSIC Hardware Description Language<br>
Chapter 1. INTRODUÇÃO 12<br>
(VHDL) é uma das linguagens de descrição de hardware mais utilizadas atualmente. A descrição<br>
em VHDL pode ser em vários níveis de abstração, sendo o mais alto o nível comportamen-<br>
tal <span class='f1 c_77' id='c_77_1' href='#c_77_2' cs_f='.c_77' >que permite a</span> descrição do circuito através de loops e processos, definido-o <span class='f1 c_317' id='c_317_1' href='#c_317_2' cs_f='.c_317' >na forma de</span><br>
algoritmo. Como características das linguagens de descrição, o VHDL permite declarações se-<br>
quenciais ou concorrentes onde as declarações continuam ativas e sua ordem torna-se irrelevante<br>
(CAPPELATTI, 2010).<br>
Aliada à linguagem de descrição de hardware, a verificação formal de sistemas computa-<br>
cionais tem desempenhado um papel importante para assegurar a previsibilidade e a confiabili-<br>
dade na concepção de aplicações críticas. E, para isso, tem-se utilizado a técnica denominada<br>
model checking, que é baseada em formalismos matemáticos para provar propriedades de pro-<br>
gramas reativos (BENSALEM; LAKHNECH, 1999). Esta técnica gera uma busca exaustiva no<br>
espaço de estados do modelo para determinar se uma dada propriedade é válida ou não (BAIER<br>
et al., 2008), tendo como principal razão para o seu sucesso o funcionamento completamente<br>
automático, ou seja, sem qualquer intervenção do usuário.<br>
Visando contribuir com a verificação de <span class='f1 c_75' id='c_75_1' href='#c_75_2' cs_f='.c_75' >sistemas embarcados no</span> âmbito de sistemas<br>
computacionais, o contexto deste trabalho está situado no uso de metodologias e técnicas de<br>
verificação formal para programas escritos em VHDL (BIERE, 2016), focando principalmente<br>
no Bounded Model Checking (CORDEIRO et al., 2012; ROCHA et al., 2015a). Este trabalho está<br>
interessado especificamente na parte de: verificação <span class='f1 c_119' id='c_119_1' href='#c_119_2' cs_f='.c_119' >de modelos de</span> hardware descritos em níveis<br>
de circuitos de bits na linguagem VHDL, via transformações de código para gerar modelos (com<br>
assertivas) já suportados por model checkers, como o ESBMC (CORDEIRO et al., 2012).<br>
Dessa forma, o trabalho almeja analisar <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >as propriedades de</span> alcançabilidade para a<br>
identificação de localizações de erro, bem como, assertivas contendo propriedades de segurança.<br>
A propriedade de alcançabilidade ou propriedade do estado de erro é satisfatória (SAT), se um<br>
estado de erro é alcançável. Caso contrário, a propriedade é considerada insatisfatória (UNSAT).<br>
No caso SAT, o model checking também gera um rastreio da validação da propriedade (contra-<br>
exemplo), ou seja, uma sequência de estados que mostra como chegar ao erro <span class='f1 c_34' id='c_34_1' href='#c_34_2' cs_f='.c_34' >a partir de um<br>
ponto</span> inicial.<br>
1.1 Definição do problema<br>
O avanço da tecnologia, principalmente nas áreas de design e fabricação de eletrônicos,<br>
aumentou a importância do hardware nos dias atuais. Cada vez com mais funcionalidades<br>
integradas, aliada a velocidade e circuitos menores, faz com que a complexidade <span class='f1 c_236' id='c_236_1' href='#c_236_2' cs_f='.c_236' >dos sistemas<br>
de</span> hardware aumente. Entretanto, devido à complexidade cada vez maior, a detecção tardia<br>
de erros no sistema pode resultar em perda de produção, mas também custos associados ao<br>
desenvolvimento do sistema(GUPTA, 1992). Devido a isso, a verificação de hardware visa<br>
assegurar que o circuito atinja as especificações para o qual foi projetado, através de técnicas<br>
Chapter 1. INTRODUÇÃO 13<br>
formais ou dinâmicas (BOULE; ZILIC, 2007).<br>
Por esta razão, a utilização de métodos formais tornou-se uma abordagem atraente<br>
para superar as limitações inerentes à validação baseada em simulação. Portanto, <span class='f1 c_219' id='c_219_1' href='#c_219_2' cs_f='.c_219' >a maioria<br>
das</span> empresas de semicondutores têm investigado a sua aplicabilidade. Escolhas individuais de<br>
métodos, ferramentas e áreas de aplicação das empresas têm variado, assim como o seu nível<br>
de sucesso (CABODI et al., 2016). Com os recentes avanços na escalabilidade de automação<br>
dos model checkers e nas equivalências sequenciais de verificação, <span class='f1 c_219' id='c_219_1' href='#c_219_2' cs_f='.c_219' >a maioria das</span> empresas têm<br>
crescido ao contar com essas técnicas(CLARKE, 2008).<br>
O problema considerado neste trabalho é expresso na seguinte questão: Como comple-<br>
mentar e aprimorar a verificação de propriedades de segurança em circuitos lógicos, <span class='f1 c_130' id='c_130_1' href='#c_130_2' cs_f='.c_130' >de tal<br>
forma que</span> uma propriedade possa ser mapeada em um problema de alcançabilidade sim-<br>
bólica, ou seja, se é possível alcançar um estado específico (para uma dada propriedade) <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >a<br>
partir do</span> estado inicial?<br>
1.2 Objetivos<br>
O objetivo principal deste trabalho é projetar e avaliar um método para efetuar verificação<br>
de circuitos, de forma automática, descritos em VHDL com portas lógicas em nível de bit<br>
pela utilização de técnicas de transformação de códigos combinado com a técnica Bounded<br>
Model Checking para exploração de estados alcançáveis no circuito, visando identificar erros ou<br>
comportamentos indevidos ou inesperados que podem resultar no funcionamento incorreto de<br>
um dado sistema.<br>
Os objetivos específicos são:<br>
1. Propor um método para especificar pré e pós-condições de circuitos digitais em nível de<br>
portas lógicas descritos em VHDL;<br>
2. Analisar ferramentas de verificação de modelos que utilizam a técnica Bounded Model<br>
Checking;<br>
3. Especificar uma técnica de conversão de circuitos em linguagem de descrição de hardware<br>
VHDL para um modelo a ser verificado usando a técnica Bounded Model Checking;<br>
4. Desenvolver um método para identificação de estados de erros ou ocorrências indevidas,<br>
de um dado circuito analisado, em modelos de hardware descritos em nível de bit na<br>
linguagem de descrição VHDL.<br>
5. Validar a aplicação do método proposto sobre benchmarks públicos de programas em<br>
VHDL, <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >a fim de</span> examinar a sua eficácia e aplicabilidade.<br>
Chapter 1. INTRODUÇÃO 14<br>
1.3 Organização do trabalho<br>
A introdução deste trabalho apresentou: o contexto, definição <span class='f1 c_261' id='c_261_1' href='#c_261_2' cs_f='.c_261' >do problema, e</span> objetivos<br>
deste trabalho. Os próximos capítulos estão organizados <span class='f1 c_330' id='c_330_1' href='#c_330_2' cs_f='.c_330' >da seguinte forma</span>:<br>
No Capítulo 2 Conceitos e Definições, são apresentados os conceitos abordados <span class='f1 c_164' id='c_164_1' href='#c_164_2' cs_f='.c_164' >neste<br>
trabalho, especificamente</span>: Linguagens de descrição de hardware; Verificação e validação de<br>
sistemas; e Técnicas de compiladores.<br>
No Capítulo 3 Trabalhos Correlatos, serão apresentados o método de pesquisa bibli-<br>
ográfica utilizado, sendo ele a revisão sistemática, seguido do resultado encontrado com esta<br>
pesquisa e, por fim, a contribuição dos artigos utilizados no desenvolvimento do projeto.<br>
No Capítulo 4 Método Proposto, são descritas <span class='f1 c_129' id='c_129_1' href='#c_129_2' cs_f='.c_129' >as etapas de</span> execução do novo método<br>
<span class='f1 c_293' id='c_293_1' href='#c_293_2' cs_f='.c_293' >proposto que consiste</span> na transformação do código, instrumentação de assertivas e verificação de<br>
código utilizando um model checker.<br>
No Capítulo 5, será apresentado o cronograma de atividades a ser realizado na elaboração<br>
do método durante o desenvolvimento <span class='f1 c_211' id='c_211_1' href='#c_211_2' cs_f='.c_211' >do projeto.<br>
E</span>, por fim, no Capítulo 6 Considerações parciais e trabalhos futuros, serão apresentas<br>
as considerações parciais e as sugestões de trabalhos futuros <span class='f1 c_232' id='c_232_1' href='#c_232_2' cs_f='.c_232' >que podem ser</span> desenvolvidos.<br>
15<br>
2 CONCEITOS E DEFINIÇÕES<br>
Este capítulo tem apresenta os principais conceitos e definições abordados neste tra-<br>
balho, tais como: Linguagens de descrição de hardware, Verificação de sistemas e Técnicas de<br>
Compiladores.<br>
2.1 Linguagens de descrição de hardware<br>
As linguagens de descrição de hardware (HDL) foram desenvolvidas com o intuito de<br>
auxiliar a criação de circuitos lógicos com grande número de elementos e <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >com uma gama de</span><br>
abstrações lógicas e eletrônicas (THOMAS; MOORBY, 2008). Entre os exemplos, podemos<br>
citar: VDHL (IEC/IEEE. . . , 2011), Verilog (IEEE. . . , 2006) e SystemC (??).<br>
Segundo CHRISTEN; BAKALAR,1999, linguagens de descrição de hardware são lingua-<br>
gens de programação utilizadas com o intuito de descrever <span class='f1 c_284' id='c_284_1' href='#c_284_2' cs_f='.c_284' >o comportamento de</span> um determinado<br>
circuito, técnica conhecida como modelagem. Os modelos descritos em HDL são utilizados<br>
como entrada para um simulador, onde o mesmo pode ter seu comportamento analisado.<br>
As HDL’s trazem consigo diversas vantagens, entre elas códigos independentes de tec-<br>
nologia e fabricante, podendo ser portáteis e reutilizáveis (CAPPELATTI, 2010). As linguagens<br>
mais modernas, tais como VHDL e Verilog, possuem suporte tanto a descrição do circuito pro-<br>
priamente dito, quanto ao comportamento que o mesmo deve exercer (CHRISTEN; BAKALAR,<br>
1999).<br>
A Verilog, como já citado, é uma linguagem de descrição de hardware que fornece<br>
diversos níveis de abstração para desenvolvimento de sistemas digitais(THOMAS; MOORBY,<br>
2008). A linguagem <span class='f1 c_175' id='c_175_1' href='#c_175_2' cs_f='.c_175' >foi desenvolvida para</span> ser simples e efetiva nos diversos níveis de abstração<br>
incluindo o suporte ao desenvolvimento, verificação, síntese e testes de software (IEEE. . . , 2006).<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog.<br>
1 p r i m i t i v e m u l t i p l e x e r ( mux , c o n t r o l , dataA , da taB ) ;<br>
2 o u t p u t mux ;<br>
3 i n p u t c o n t r o l , dataA , da taB ;<br>
4 e n d p r i m i t i v e<br>
Fonte: Adaptado de (IEEE. . . , 2006).<br>
Na Figura 1 apresenta um exemplo de multiplexador descrito em Verilog utilizando a<br>
estrutura de modelagem, chamada UDP <span class='f1 c_77' id='c_77_1' href='#c_77_2' cs_f='.c_77' >que permite a</span> criação de novos primitivas para serem<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 16<br>
utilizada. Apresenta uma saída apenas(mux) e três entradas sendo uma de controle(control) e<br>
duas de dados(dataA e dataB).<br>
A VHDL é uma linguagem de descrição de hardware amplamente utilizada, concebida<br>
na década de 80, devido uma necessidade <span class='f1 c_135' id='c_135_1' href='#c_135_2' cs_f='.c_135' >do Departamento de</span> Defesa dos Estados Unidos<br>
da América (CAPPELATTI, 2010). Assim como a Verilog, esta linguagem também suporta o<br>
desenvolvimento, a verificação, a síntese, e os testes de hardware (IEC/IEEE. . . , 2011).<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL.<br>
1 l i b r a r y IEEE ;<br>
2 use IEEE . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 use IEEE . s t d _ l o g i c _ u n s i g <span class='f1 c_322' id='c_322_1' href='#c_322_2' cs_f='.c_322' >n e d</span> . a l l ;<br>
4 e n t i t y mux2x1 i s<br>
5 p o r t ( s e l : i n STD_LOGIC ;<br>
6 a , b : i n STD_LOGIC ;<br>
7 y : o u t STD_LOGIC ) ;<br>
8 end mux2x1 ;<br>
9<br>
10 a r c h i t e c t u r e d a t a f l o w of mux2x1 i s b e g i n<br>
11 y &lt;= ( a AND NOT s e l ) OR ( b AND s e l ) ;<br>
12 end d a t a f l o w .<br>
Fonte: (CAPPELATTI, 2010).<br>
Na Figura 2 está descrito um multiplexador de duas entradas descrito em VHDL, apre-<br>
sentando na parte inicial as bibliotecas e na entidade(entity) a declaração das variáveis utilizadas.<br>
Na arquitetura(architecture) apresenta o funcionamento do multiplexador, relacionando en-<br>
tradas e saídas conforme tenham sido declarados. Este conceitos serão melhor apresentados na<br>
subsection 2.1.1.<br>
Conforme apresentado nas Figura 1 e Figura 2, ambas as linguagens apresentam difer-<br>
enças no modelos de declaração e utilização para descrição de hardware. Para este trabalho foi<br>
escolhido a VHDL devido a linguagem apresentar um melhor escopo para análise, facilitando o<br>
trabalho de análise proposto para este projeto.<br>
2.1.1 VHSIC Hardware Description Language - VHDL<br>
Revisar textos e verificar <span class='f1 c_176' id='c_176_1' href='#c_176_2' cs_f='.c_176' >a necessidade de</span> mais exemplo<br>
VHDL é uma linguagem de descrição de hardware destinada a ser utilizada <span class='f1 c_204' id='c_204_1' href='#c_204_2' cs_f='.c_204' >em todas<br>
as etapas</span> da criação de sistemas eletrônicos, sendo elas: desenvolvimento; verificação; síntese;<br>
e, teste de circuitos (IEC/IEEE. . . , 2011). Segundo (CAPPELATTI, 2010), a VHDL apresenta<br>
três principais pilares: abstração, que consiste na descrição com diferentes níveis de detalhes;<br>
modularidade, <span class='f1 c_77' id='c_77_1' href='#c_77_2' cs_f='.c_77' >que permite a</span> divisão do projeto em vários blocos ou módulos para posterior<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 17<br>
interconexão; e hierarquia, permite que módulos possam ser compostos por submódulos e, os<br>
mesmos tenham níveis de abstração diferentes, dependendo da necessidade do projeto. Devido a<br>
esta versatilidade que a linguagem VHDL foi selecionada <span class='f1 c_32' id='c_32_1' href='#c_32_2' cs_f='.c_32' >para o trabalho</span> proposto.<br>
Segundo IEC/IEEE. . . ,2011, é necessário um padrão para formatação da descrição em<br>
VHDL: Entity (Pinos de entrada/saída) e Architecture (Arquitetura). A Entity ou entidade repre-<br>
senta o bloco onde são declaradas as entradas e as saídas do circuito utilizadas <span class='f1 c_151' id='c_151_1' href='#c_151_2' cs_f='.c_151' >em todo o sistema</span>,<br>
conforme apresentado na Figura 3. A Architecture ou arquitetura, apresentado na Figura 4, define<br>
a relação entre entradas e saídas declaradas na entidade, podendo tais especificações serem<br>
completas ou parciais. <span class='f1 c_313' id='c_313_1' href='#c_313_2' cs_f='.c_313' >Assim como em</span> outras linguagens, bibliotecas podem ser adicionadas,<br>
para que novas funções e atributos possam ser utilizados no projeto.<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade.<br>
1 l i b r a r y i e e e ;<br>
2 use IEEE . STD_LOGIC_1164 . ALL<br>
3<br>
4 ENTITY f u l l _ a d d e r IS PORT(<br>
5 x1 , x2 , c i n : i n s t d _ l o g i c ;<br>
6 S , c o u n t : o u t s t d _ l o g i c ) ;<br>
7 END f u l l _ a d d e r ;<br>
Fonte: Própria.<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL.<br>
1 ARCHITECTURE b e h a v i o r a l OF f u l l _ a d d e r IS<br>
2 BEGIN<br>
3 s &lt;=x1 XOR x2 XOR c i n ;<br>
4 cout &lt;=( x1 AND x2 ) OR ( x1 AND c i n ) OR ( b<br>
AND c i n ) ;<br>
5 END b e h a v i o r a l ;<br>
Fonte: Própria.<br>
Segundo CAPPELATTI,2010 uma descrição em VHDL pode conter diferentes níveis de<br>
abstração:<br>
• Comportamental: Permite descrever o circuito através de laços e processos. O circuito<br>
é definido <span class='f1 c_104' id='c_104_1' href='#c_104_2' cs_f='.c_104' >em forma de um algoritmo</span>, utilizando construção similares as utilizadas em<br>
linguagem de programação.<br>
• Transferência de registradores: Englobando a representação do dispositivo em nível de<br>
transferência entre registradores, que consiste na utilização de funções lógicas combina-<br>
cionais e de registradores.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 18<br>
• Estrutural: O circuito é descrito mais próximo da implementação real, podendo ser<br>
definidas portas lógicas com atrasos unitários ou com atrasos detalhados.<br>
2.1.2 Portas lógicas<br>
Segundo (IDOETA; CAPUANO, 1982), o conceito de portas lógicas é baseado na<br>
conhecida álgebra de Boole ou álgebra booleana, desenvolvida pelo matemático inglês George<br>
Boole em 1854. A álgebra booleana é representada por apenas dois valores, sendo eles o 0 e 1 e,<br>
através disso, expressa a relação entre entrada e saída <span class='f1 c_199' id='c_199_1' href='#c_199_2' cs_f='.c_199' >dentro de um</span> circuito. As portas lógicas<br>
podem ser construídas <span class='f1 c_34' id='c_34_1' href='#c_34_2' cs_f='.c_34' >a partir de</span> diodos, transistores e resistores interconectados <span class='f1 c_57' id='c_57_1' href='#c_57_2' cs_f='.c_57' >de modo que</span> a<br>
saída seja o resultante de uma operação lógica básica realizada sobre as entradas (TOCCI et al.,<br>
2003). A Figura 5 apresenta um exemplo de álgebra booleana sem a utilização de diagramas.<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1.<br>
Fonte: (TOCCI et al., 2003)<br>
Ainda segundo TOCCI et al.,2003, devido a esta característica, a álgebra booleana possui<br>
três operações básicas, OR (ou), AND (e) e NOT (não). Tal conjunto de operações também é<br>
denominado de operações booleanas e, <span class='f1 c_263' id='c_263_1' href='#c_263_2' cs_f='.c_263' >por meio da</span> utilização de tabelas verdade é possível<br>
descrever as saídas baseando-se nas entradas e na operação aplicada. Cada operação booleana<br>
possui sua tabela verdade ( Figura 6), bem como sua representação <span class='f1 c_104' id='c_104_1' href='#c_104_2' cs_f='.c_104' >em forma de</span> diagrama.<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas.<br>
Fonte: (TOCCI et al., 2003)<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 19<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas.<br>
Fonte: (TOCCI et al., 2003)<br>
A Figura 7 apresenta um circuito lógico formado pelas portas básicas da álgebra booleana.<br>
O circuito apresenta três entradas representadas pelas letras A, B e C, mas também formada<br>
por duas portas AND, uma porta NOT e uma porta OR. Cada uma destas portas representando<br>
operações a serem realizadas, podendo receber como entrada um valor inicial ou resultante de<br>
outra porta, como no exemplo ocorre com a última porta AND.<br>
Entetanto, segundo (KROPF, 2013), a análise de circuitos é extremamente complexa,<br>
resultando em um problema NP-Completo, algoritmos possuem tempo de execução exponencial.<br>
Contudo, este tempo de execução exponencial é uma complexidade exponencial para o pior caso,<br>
resultando crescimento exponencial da execução a medida que <span class='f1 c_247' id='c_247_1' href='#c_247_2' cs_f='.c_247' >o tamanho do</span> problema aumenta.<br>
Ainda, segundo (KROPF, 2013) a avaliação das funções booleanas podem ser ver-<br>
dadeiras(True) ou falso(False), com isso, para um função com n variáveis, apresenta 2n possibili-<br>
dades de avaliação. Utilizando o exemplo da Figura 7 que apresenta 3 entradas, logo apresenta 8<br>
possibilidade de avaliação ao final e este número aumenta à medida que o número de variáveis<br>
tambe aumenta<br>
2.2 Verificação de sistemas<br>
No contexto de verificação de sistemas, faz-se necessário a diferenciação entre verificação<br>
e validação. Verificação e validação possuem o intuíto de mostrar que determinado sistema fun-<br>
cione conforme o especificado, além de satisfazer as especificações do cliente (SOMMERVILLE,<br>
2011).<br>
Segundo (SARGENT, 2005), verificação é <span class='f1 c_230' id='c_230_1' href='#c_230_2' cs_f='.c_230' >o processo de</span> determinar <span class='f1 c_47' id='c_47_1' href='#c_47_2' cs_f='.c_47' >se um modelo</span><br>
computacional obtido por discretização <span class='f1 c_177' id='c_177_1' href='#c_177_2' cs_f='.c_177' >de um modelo</span> matemático de um evento físico e o<br>
código que implementa o modelo computacional pode <span class='f1 c_73' id='c_73_1' href='#c_73_2' cs_f='.c_73' >ser usado para</span> representar o modelo<br>
matemático do evento com precisão suficiente e validação é <span class='f1 c_230' id='c_230_1' href='#c_230_2' cs_f='.c_230' >o processo de</span> determinar <span class='f1 c_47' id='c_47_1' href='#c_47_2' cs_f='.c_47' >se um<br>
modelo</span> matemático de um evento físico representa o evento físico real com precisão suficiente.<br>
A verificação consite identificação de erros e provavéis problemas que um componente<br>
pronto possa apresentar, enquanto a validação busca analisar se tal componete esta seguindo<br>
os requisitos pré-definidos para sua construção (KOSCIANSKI; SOARES, 2007). <span class='f1 c_56' id='c_56_1' href='#c_56_2' cs_f='.c_56' >O teste de</span><br>
programa, na qual o software é executado com dados de teste é a principal forma de validação,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 20<br>
porém, tecnicas de verificação, tais como, inspeção e revisões também podem integrar <span class='f1 c_319' id='c_319_1' href='#c_319_2' cs_f='.c_319' >a etapa de</span><br>
validação (SOMMERVILLE, 2011).<br>
2.2.1 Diagrama de decisão binária<br>
Um diagrama de decisão binária(DDB) pode ser definido como um grafo aciclico para<br>
representação de funcões boolenas. Existe uma ordem rigorosa na ocorrência de variáveis à me-<br>
dida que se percorre o grafo da raiz para a folha. Dado como exemplo a formula f=(a?b)?(c?d)<br>
<span class='f1 c_286' id='c_286_1' href='#c_286_2' cs_f='.c_286' >e utilizando a</span> ordenação de variavél a &lt; b &lt; c &lt; d, na Figura 8. Dada a atribuição de valores<br>
booleanos as variaveis a, b, c e d, pode-se decidir se a atribuição torna a fórmula verdadeira<br>
atravessando o início do gráfico na raiz e ramificação em cada nó. Definindo a, c e d = 1 e c = 0<br>
leva a folha de rótulo 1, portanto, a fórmula é verdadeira para essa tarefa (CLARKE et al., 1994).<br>
Figure 8 – Arvore de decisão binária<br>
Fonte: (CLARKE et al., 1994)<br>
Adicionar mais detalhes e descrever onde DDB é utilizado.<br>
O DDB permite o teste eficiente de satisfabilidade, validade e eficiência (KROPF, 2013).<br>
O uso e DDB em conjunto com Model Checking e técnicas de abstração permitiu o aumento na<br>
capacidade de verificação, <span class='f1 c_57' id='c_57_1' href='#c_57_2' cs_f='.c_57' >de modo que</span> sistemas mais realistas podessem ser verificados(??)<br>
2.2.2 Model Checking<br>
Model checking é uma técnica de verificação formal que explora todos os possíveis<br>
estados <span class='f1 c_196' id='c_196_1' href='#c_196_2' cs_f='.c_196' >do sistema, de modo a</span> provar <span class='f1 c_47' id='c_47_1' href='#c_47_2' cs_f='.c_47' >se um modelo</span> satisfaz determinada propriedade. Pode ser<br>
aplicada <span class='f1 c_197' id='c_197_1' href='#c_197_2' cs_f='.c_197' >em uma ampla gama de</span> aplicações, tais como sistema embarcados, design de hardware<br>
e engenharia de software (BAIER et al., 2008).<br>
Entre as vantagens da utilização de Model Checking estão:<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 21<br>
• Possuem suporte a verificação parcial, <span class='f1 c_94' id='c_94_1' href='#c_94_2' cs_f='.c_94' >em outras palavras</span>, a verificação individual de<br>
propriedades, permitido foco primeiro as propriedades essenciais(BAIER et al., 2008).<br>
• Não requer qualquer interação do usuário, nem um alto grau de especialização para <span class='f1 c_234' id='c_234_1' href='#c_234_2' cs_f='.c_234' >o uso<br>
de</span> model checking(BAIER et al., 2008).<br>
• Possui como base a teoria de grafos, estruturas <span class='f1 c_167' id='c_167_1' href='#c_167_2' cs_f='.c_167' >de dados e</span> lógica no desenvolvimento da<br>
solução(BAIER et al., 2008).<br>
• Útil para fins de depuração, pois formece informações <span class='f1 c_252' id='c_252_1' href='#c_252_2' cs_f='.c_252' >em caso de</span> uma propriedade seja<br>
invalidada(BAIER et al., 2008).<br>
Por outro lado, apresenta também algumas desvantagens:<br>
• Sofre do problema de explosão de espaço de estados, <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >ou seja, a quantidade de</span> estados<br>
necessários pode ser maior que a memória disponivel pelo sistema(BAIER et al., 2008).<br>
• Faz a verificação apenas dos requisios declarados, logo, não a garantia de integridade.<br>
Baseado nisso, a validade de propriedades não verificadas não pode ser julgada(BAIER et<br>
al., 2008).<br>
• A verificação de modelos geralmente não é computável, isso <span class='f1 c_134' id='c_134_1' href='#c_134_2' cs_f='.c_134' >deve-se a</span> questões de decidi-<br>
bilidade utilizada (BAIER et al., 2008).<br>
Outras técnicas foram implementadas em conjuntos com Model checkings com o intuito<br>
de aumentas <span class='f1 c_124' id='c_124_1' href='#c_124_2' cs_f='.c_124' >a capacidade de</span> verificação, como a técnica SAT na qual não sofre do problema de<br>
explosão de estados existente usando DDB. A técnica SAT em conjuto com Model Checking é<br>
conhecida como Bounded Model Checking (??).<br>
2.2.3 Bounded Model Checking<br>
Segundo ROCHA et al., Bounded Model Checking (BMC) é um tipo especial de Model<br>
Checking que usualmente adota o método de satisfabilidade booleana, <span class='f1 c_30' id='c_30_1' href='#c_30_2' cs_f='.c_30' >o qual tem</span> sido introduzido<br>
como uma técnica complementar para diagrama de decisão binaria para aliviar o problema da<br>
explosão de estados, visto que a técnica de Model Checking busca todos os estados possíveis<br>
para verificação.<br>
Bounded Model Checking é uma técnica para a verificação de uma dada propriedade<br>
em uma determinada profundidade do sistema analisado. Logo, dado <span class='f1 c_140' id='c_140_1' href='#c_140_2' cs_f='.c_140' >um sistema de</span> transições<br>
M, uma propriedade ?, e um limite (bound) k, o BMC desenrola o sistema k vezes e traduz <span class='f1 c_253' id='c_253_1' href='#c_253_2' cs_f='.c_253' >o<br>
sistema em uma</span> condição de verificação(CV) ? tal que ? é satisfeito se e somente se ? tem um<br>
contra-exemplo de profundidade menor ou igual a k (ROCHA et al., 2015b).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 22<br>
O Extended SMT-Based Bounded Model Checker (ESBMC) é um Bounded Model<br>
Checking baseado em satisfabilidade booleana (SAT) que permite verificação aritmética de Já tem<br>
su-<br>
porte<br>
a<br>
SMT<br>
adi-<br>
cionar<br>
ao<br>
texto<br>
overflow e undeflow, segurança de ponteiros, limite de array, de gerar propriedades de segurança<br>
em programas em C/C++. ESBMC utiliza uma versão modificada do CBMC no front-end <span class='f1 c_191' id='c_191_1' href='#c_191_2' cs_f='.c_191' >para<br>
analisar o</span> código ANSI-C e <span class='f1 c_74' id='c_74_1' href='#c_74_2' cs_f='.c_74' >para gerar as</span> condições de verificação através de execução simbólica<br>
(CORDEIRO et al., 2012; ROCHA et al., 2015b).<br>
No ESBMC, o programa analisado é modelado <span class='f1 c_273' id='c_273_1' href='#c_273_2' cs_f='.c_273' >em um sistema de</span> transição de estados,<br>
conforme a trupla: M = (S,R, S0), o qual é gerado um grafo de controle de fluxo (GFC), onde<br>
S representa <span class='f1 c_190' id='c_190_1' href='#c_190_2' cs_f='.c_190' >o conjunto de</span> estados, R ? SxS representa as transições e S ? S representa<br>
o conjuto de estados iniciais. Um estado s ? S consiste no valor do contador de programa<br>
(PC) e <span class='f1 c_114' id='c_114_1' href='#c_114_2' cs_f='.c_114' >os valores de todas as</span> variáveis dos programas. O estado inicial S0 atribui o inicio do<br>
programa GFC ao PC, desta forma o ESBMC identifica as transições, conforme a formula lógica,<br>
?=(Si,Si+1) que captura as retrições <span class='f1 c_132' id='c_132_1' href='#c_132_2' cs_f='.c_132' >sobre os valores</span> correspondntes do PC e das variáveis do<br>
programa (CORDEIRO et al., 2012).<br>
Segundo o site do ESBMC(??), a ferramenta permite ao usuário indicar propriedades<br>
adicionaisusando assertivas que também são verificadas. O ESBMC converte as condições Descrever<br>
quais<br>
pro-<br>
priedades<br>
o<br>
esbmc<br>
su-<br>
porta<br>
usando diferentes técnicas de backgroundpara posteriormente passar para verificador SMT. Outra<br>
apresentar<br>
exem-<br>
plo<br>
vantagem é a ferramenta permitir verificação de software single-thread e multi-thread.<br>
Descrever qual a razão da <span class='f1 c_194' id='c_194_1' href='#c_194_2' cs_f='.c_194' >escolha para o trabalho</span>, apresentar resultados do SV-COMP<br>
dos últimos 3 anos<br>
2.2.4 Redes de petri<br>
Apresentar definição formal para RP<br>
corrigir o texto abaixo RP não é uma ferramenta e sim um método de modelagem<br>
Redes de petri são utilizadas como ferramentas de modelagem gráfica com propriedades<br>
matemática. Como ferramenta gráfica são utilizadas como comunicação visual, como fluxogra-<br>
mas, por exemplo, e como ferramenta matemática podem configurar modelos matemáticos que<br>
regem <span class='f1 c_59' id='c_59_1' href='#c_59_2' cs_f='.c_59' >o comportamento dos</span> sistemas. A grade premissa desta ferramenta é descrever sistemas<br>
<span class='f1 c_303' id='c_303_1' href='#c_303_2' cs_f='.c_303' >de processamento de</span> informações caracterizados como concorrentes, assíncronos, distribuídos,<br>
paralelos, não deterministas e/ou estocásticos (MURATA, 1989).<br>
As redes de petri são representados como grafos direcionais compostos por nós e arcos,<br>
conforme apresentado na Figura 9. Os nós representam as transições e eventos e os arcos<br>
representam os pesos. Dentro desta representação, os arcos e eventos são componentes passivos<br>
enquanto as transições são ativos. <span class='f1 c_203' id='c_203_1' href='#c_203_2' cs_f='.c_203' >A principal vantagem</span> da utilização das redes de petri esta<br>
relacionado ao chamado "Token game" que consiste no comportamento da rede de petri, <span class='f1 c_94' id='c_94_1' href='#c_94_2' cs_f='.c_94' >em<br>
outras palavras</span>, representa o funcionamento do sistema representado pela rede(HALDER;<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 23<br>
VENKATESWARLU, 2006).<br>
Figure 9 – Rede de petri<br>
Fonte: (HALDER; VENKATESWARLU, 2006)<br>
Descrever o funcionamento da RP apresentado na IMG<br>
Descrever quais propriedades podem ser verificadas com RP e onde será utilizado no seu<br>
trabalho.<br>
2.2.5 Verificação de hardware<br>
Para a verificação de hardware diversas técnicas têm sido propostas (). <span class='f1 c_263' id='c_263_1' href='#c_263_2' cs_f='.c_263' >Por meio da</span> Apresentar<br>
exem-<br>
plos<br>
com<br>
refer-<br>
ências<br>
simulação, visa assegurar que uma implemetação, descrição do hardware em qualquer qualquer<br>
nível de abstração da hierarquia de hardware, atinja suas especificações, propriedades <span class='f1 c_14' id='c_14_1' href='#c_14_2' cs_f='.c_14' >que devem<br>
ser</span> respeitadas para que a corretude do mesmo seja comprovada (GUPTA, 1992). A Verificação<br>
formal de hardware consiste na utilização de técnicas para corretude de circuitos lógicos, ou<br>
seja, consiste na utilização de modelos matemáticos para descrição de propriedade e/ou de<br>
comportamento de um dado sistema (KROPF, 2013).<br>
Entre as abordagens utilizadas na verificação formal de hardware consiste tanto na imple-<br>
mentação quanto a especificação estarem descritas em lógica formal, neste caso a corretude será<br>
obtida através da comprovada relação entre a implementação e a especificação (SEGER, 1992).<br>
A especificação formal consiste na descrição do comportamento, bem como, das propriedades<br>
<span class='f1 c_163' id='c_163_1' href='#c_163_2' cs_f='.c_163' >do sistema em</span> linguagem matemática, tornando-se crucial para <span class='f1 c_230' id='c_230_1' href='#c_230_2' cs_f='.c_230' >o processo de</span> verificação. Na<br>
implementação formal, o nível de abstração, tais como, Gate level e RTL são importantes infor-<br>
mações <span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >para o desenvolvimento</span> do formalismo, bem como as classes, <span class='f1 c_39' id='c_39_1' href='#c_39_2' cs_f='.c_39' >por exemplo se</span> o circuito<br>
é sequencial ou combinacional, se utiliza pipeline, etc (KROPF, 2013).<br>
Apresentar um exemplo de RTL<br>
A utilização de Model Checking também se faz presente nos modelos formais de ver-<br>
ificação de hardware, onde apenas é utilizado <span class='f1 c_59' id='c_59_1' href='#c_59_2' cs_f='.c_59' >o comportamento dos</span> circuitos na verificação,<br>
<span class='f1 c_133' id='c_133_1' href='#c_133_2' cs_f='.c_133' >de modo a</span> verificar a se as propriedades presentes são satisfeitas. Para isso, são utilizados os<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 24<br>
conceitos da lógica proposicional, que <span class='f1 c_263' id='c_263_1' href='#c_263_2' cs_f='.c_263' >por meio da</span> utilização de fórmulas que representem as<br>
propriedades dos estados, é possível realizar as verificações necessárias (SEGER, 1992).<br>
Apresentar um exemplo com um circuito e como este pode ser verificando com model<br>
checking<br>
2.2.6 Verificação formal de software<br>
Observa-<span class='f1 c_84' id='c_84_1' href='#c_84_2' cs_f='.c_84' >se que o uso de</span> verificacão de software tem sido feito aplicado em muitas áreas,<br>
tais como, infraestruturas industriais de missão critica e de segurança. Logo, existe <span class='f1 c_176' id='c_176_1' href='#c_176_2' cs_f='.c_176' >a necessidade<br>
de</span> garantir a corretude destes sistemas. Devido a isso, a verificação formal tem sido utilizada em<br>
três principais abordagens, sendo elas (COUSOT; COUSOT, 2010; D’SILVA et al., 2008):<br>
Apresentar exemplos para os métodos apresentados abaixo<br>
• Métodos dedutivos: Produzem provas matemáticas formais de corretude usando provadores<br>
de teoremas ou assistentes de prova para execução da prova e necessitam da interação<br>
humana para prover os argumentos (COUSOT; COUSOT, 2010);<br>
• Verificação de modelos: Exploram exaustivamente modelos de execuções de programa,<br>
<span class='f1 c_232' id='c_232_1' href='#c_232_2' cs_f='.c_232' >que podem ser</span> sujeitos a explosão combinatória, necessário a intervenção humana para<br>
geração dos modelos (ROCHA et al., 2015b);<br>
• Analise estática: Engloba diversas técnicas para calcular automaticamente informações<br>
sobre <span class='f1 c_284' id='c_284_1' href='#c_284_2' cs_f='.c_284' >o comportamento de</span> um programa sem executá-lo, sendo utilizado em otimização<br>
de código e verificação em compiladres (D’SILVA et al., 2008).<br>
Segundo ROCHA et al., na verificação formal de software apresentam-se dificuldades,<br>
tais como: quais as propriedades são de interesse na verificação em tempo de execução; e<br>
impossibilidade matemática de provar a corretude de propriedades não triviais no comportamento<br>
de programas (COUSOT; COUSOT, 2010).<br>
2.2.7 Lógica proposicional<br>
A lógica proposicional é uma linguagem formal onde é definida um alfabeto e conectivos<br>
proposicionais, e <span class='f1 c_222' id='c_222_1' href='#c_222_2' cs_f='.c_222' >um conjunto de</span> regras gramaticais, as quais serão utilizadas para construção<br>
das proposições (SOUZA, 2017). Porém apesar de importante, ela é limitada, não podendo<br>
expressar sentenças elementares importantes, tais como a da aritmética elementar. Por exemplo:<br>
1. Todos são mortais.<br>
2. Alguém é bondoso.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 25<br>
Na lógica preposicional, não poderiam ser analisadas, pois não teria como decompor<br>
ambas em sentença e assim não teria como analisar as diferenças entre ambas(ABE, 2002).<br>
Contudo, no exemplo: Existem cavalos com patas verdes. A relação criada pela frase poderia a<br>
ser analisada pela lógica proposicional(ABE, 2002). Descrever<br>
como<br>
seria<br>
está<br>
analise<br>
Segundo SOUZA, alfabeto da lógica proposicional é formado por símbolo de pontuação,<br>
símbolos proposicionais e conectivos proposicionais, onde cada um apresenta uma função em<br>
específico, sendo:<br>
• Símbolos de pontuação: Apenas dois símbolos de pontuação são utilizados o "(" e o ")".<br>
• Símbolos proposicionais: São utilizados para representar as proposições, onde um sím-<br>
bolo P pode ser utilizado para representar uma proposição qualquer, por exemplo: P="Está<br>
chovendo". <span class='f1 c_190' id='c_190_1' href='#c_190_2' cs_f='.c_190' >O conjunto de</span> símbolos proposicionais é infinito e enumerável, sendo possível<br>
representar infinitos e enumerável conjunto de proposições.<br>
• Conectivos proposicionais: São os símbolos usando frequentemente na matemática. Os<br>
símbolos recebem a seguinte denominação:<br>
1. ¬: Representa a partícula de negação, ou seja, "Não".<br>
2. ?: Representa a partícula "Ou"<br>
3. ?: Representa a partícula "E"<br>
4. ?: Representa a partícula "Se então ou implica".<br>
5. ?: Representa a partícula "Se, e somente se".<br>
Ainda segundo SOUZA, existem as fórmulas que são constituídas de forma indutiva, <span class='f1 c_34' id='c_34_1' href='#c_34_2' cs_f='.c_34' >a<br>
partir de</span> símbolos do alfabeto conforme as regras apresentadas abaixo:<br>
• Todo o símbolo preposicional é uma fórmula<br>
• Se H é uma fórmula, então (¬H), a negação de H, é uma fórmula.<br>
• Se H e G são fórmulas, então a disjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a conjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o antecedente e G consequente da fórmula.<br>
• Se H e G são fórmulas, então a bi-implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o lado esquerdo e G o lado direito da fórmula.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 26<br>
2.2.8 Linguagem de especificação de propriedades<br>
Linguagem de especificação de propriedades, do inglês Property Specification Language<br>
- PSL, é uma notação formal para especificação de comportamento em sistemas eletrônicos,<br>
compatível com as linguagens VHDL, Verilog, SystemC e SystemVerilog. <span class='f1 c_329' id='c_329_1' href='#c_329_2' cs_f='.c_329' >Destina-se a</span> utilização Adicionar<br>
refer-<br>
ência<br>
a cada<br>
Ling<br>
citada<br>
para a especificação funcional, mas também para entrada de ferramentas de verificação. A<br>
especificação do PSL é a utilização de assertivas sobre <span class='f1 c_10' id='c_10_1' href='#c_10_2' cs_f='.c_10' >propriedades de um sistema</span>, sendo estas<br>
propriedades constituídas de três elementos: expressões boolenas, expressões sequenciais e<br>
operadores temporais (IEEE. . . , 2010).<br>
Corrigir a apresentação da citação IEEE... estranho<br>
Segundo (IEEE. . . , 2010), o PSL foi totalmente desenvolvida com o intuito fornecer<br>
leitura e escrita de fácil entendimento, sintaxe concisa, semântica formal e rigorosamente bem<br>
definida e ser matematicamente precisa, visto a utilização da mesma em processo de verificação.<br>
O PSL pode ser utilizado para capturar requisitos relativos ao comportamento total do projeto,<br>
<span class='f1 c_138' id='c_138_1' href='#c_138_2' cs_f='.c_138' >bem como, sobre o</span> <span class='f1 c_231' id='c_231_1' href='#c_231_2' cs_f='.c_231' >modo que o</span> mesmo deverá operar no ambiente, ms também para capturar<br>
requisitos comportamentais e os pressupostos que surgem <span class='f1 c_332' id='c_332_1' href='#c_332_2' cs_f='.c_332' >durante o processo de</span> design. Ambas<br>
podem ser utilizadas para verificação de sistemas.<br>
Apresentar exemplos de uso da PSL<br>
2.2.9 Verificação baseada em assertivas<br>
Verificação baseada em assertivas, do inglês Assertion-Based Verification - ABV, é um<br>
paradigma de verificação igualente adequado para verificação formal e abordagens baseadas em<br>
simulação (BOULE; ZILIC, 2005) e em conjunto com a tecnica de PSL tem ganhado aceitação<br>
como um método essencial para verificação funcional do hardware (DAHAN et al., 2005).<br>
Na ABV as assertivas são declaração adicionadas ao projeto com o intuito de especificar<br>
<span class='f1 c_276' id='c_276_1' href='#c_276_2' cs_f='.c_276' >o comportamento do</span> projeto (BOULE; ZILIC, 2005), podendo escritos em PSL ou em SVA<br>
(System Verilog Assertions). No caso deste projeto será utilizado a PSL, devido a mesma ser<br>
utilizada juntamente com a linguagem VHDL.<br>
Com a utilização de ABV o circuito pode ser verificado usando técnicas de simulação<br>
e/ou verificação, por exemplo, model checking, <span class='f1 c_182' id='c_182_1' href='#c_182_2' cs_f='.c_182' >para garantir que</span> o mesmo esteja <span class='f1 c_195' id='c_195_1' href='#c_195_2' cs_f='.c_195' >de acordo<br>
com</span> o pretendido projeto (DAHAN et al., 2005). Na Figura 19 apresenta <span class='f1 c_143' id='c_143_1' href='#c_143_2' cs_f='.c_143' >o modelo de</span> assertiva<br>
utilizada no projeto, utilizando <span class='f1 c_177' id='c_177_1' href='#c_177_2' cs_f='.c_177' >de um modelo</span> próprio para assertivas, unindo as funcionalidades<br>
já existentes nas assertivas do VHDL, mas também novas (serão apresentadas nas próximas<br>
seções), fornecendo assim mais propriedades a serem analisadas.<br>
Descrever <span class='f1 c_185' id='c_185_1' href='#c_185_2' cs_f='.c_185' >qual o objetivo da</span> assert apresentado<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 27<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 e n t i t y AND_ent i s<br>
5 p o r t ( x , y : i n b i t ;<br>
6 F : o u t b i t<br>
7 ) ;<br>
8 end AND_ent ;<br>
9<br>
10 a r c h i t e c t u r e behav1 of AND_ent i s<br>
11 b e g i n<br>
12 ??@c2vhdl : ASSERT<br>
13 ??a s s e r t n o t ( x= ’ 0 ’ and y= ’ 1 ’ )<br>
14 ?? r e p o r t " Both v a l u e s o f s i g n a l s x and y a r e e q u a l t o 1 "<br>
15 ??s e v e r i t y ERROR;<br>
16 ??@c2vhdl :END<br>
17<br>
18 p r o c e s s ( x , y )<br>
19 b e g i n<br>
20 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
21 F &lt;= ’ 1 ’ ;<br>
22 e l s e<br>
23 F &lt;= ’ 0 ’ ;<br>
24 end i f ;<br>
25 end p r o c e s s ; 4<br>
26 end behav1 ;<br>
Fonte: Própria.<br>
2.2.10 Propriedades de segurança<br>
Propriedades de segurança é <span class='f1 c_8' id='c_8_1' href='#c_8_2' cs_f='.c_8' >um meio de</span> validação do comportamento de um determinado<br>
sistema, <span class='f1 c_57' id='c_57_1' href='#c_57_2' cs_f='.c_57' >de modo que</span> se uma dada propriedade de segurança for violada, então através de<br>
uma execução finita, é possível verificar tal erro. Algumas propriedades de segurança, no<br>
entanto, podem impor requisitos em fragmentos de caminho finito e não podem ser verificadas<br>
considerando apenas os estados alcançáveis. (BAIER et al., 2008).<br>
Segundo (CLARKE et al., 2003), podemos definir uma propriedade de segurança como:<br>
dado <span class='f1 c_140' id='c_140_1' href='#c_140_2' cs_f='.c_140' >um sistema de</span> transições ST = (S, S0, E), seja um conjunto B ? S que especifica <span class='f1 c_222' id='c_222_1' href='#c_222_2' cs_f='.c_222' >um<br>
conjunto de</span> maus estados tais que S0 ?B = ?, pode-se dizer que ST é seguro com relação a B,<br>
denotado por ST |= AG¬B se não existe um caminho no sistema de transição do estado inicial<br>
S0 até o estado B, de outro modo é dito que ST não é seguro.<br>
Adicionar exemplos de propriedades de segurança em hardware<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 28<br>
2.3 Técnicas de compiladores<br>
Compiladores são sistemas de software utilizados para tradução de uma linguagem de<br>
programação para outra, ou seja, o programa da linguagem fonte é lido e traduzido para um<br>
código equivalente na outra linguagem, ou linguagem alvo. Geralmente utilizada para transformar<br>
trechos de código em uma linguagem a ser executada pelo computador (AHO et al., 2007).<br>
Diversas técnicas podem ser utilizadas nas diversas etapas, até que o código seja traduzido,<br>
tais como LL(1) e LR na análise sintática; eliminação de código morto; propagação de constante<br>
e Peephole na otimização de código(AHO et al., 2007). Neste projeto serão focados as áreas de<br>
transformações de código e otimização de código.<br>
2.3.1 Transformações de código<br>
Transformações de código correspondem a uma complexa função que envolve analise de<br>
fluxo <span class='f1 c_167' id='c_167_1' href='#c_167_2' cs_f='.c_167' >de dados e</span> modificação completa do programa que são parte integral da alta performance e<br>
sistemas computacionais. Podem ser classificados em transformações escalares que reduzem<br>
o número de instruções a serem executadas no programa ou transformações paralelas que<br>
maximizam o paralelismo (SRIKANT; SHANKAR, 2002).<br>
A Figura 11 representa o trecho de código apresentado na Figura 19. O trecho representa<br>
o comportamento das entradas, neste caso de um código da porta AND. E a figura Figura 12<br>
representa a tradução deste trecho em código na linguagem C. Esta tradução foi realizada pela<br>
ferramenta V2C, utilizada neste projeto. Adicionar<br>
refer-<br>
ência<br>
Figure 11 – Trecho de código em VHDL representando porta AND.<br>
1 p r o c e s s ( x , y )<br>
2 b e g i n<br>
3 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
4 F &lt;= ’ 1 ’ ;<br>
5 e l s e<br>
6 F &lt;= ’ 0 ’ ;<br>
7 end i f ;<br>
8 end p r o c e s s ;<br>
Fonte: Própria.<br>
Expandir esta seção. Apresentar propriedades de transformação e técnicas para avaliar a<br>
transformação<br>
2.3.2 Otimização de código<br>
A otimização de código consiste na melhoria do código intermediário gerado pelos<br>
algoritmos de compilação <span class='f1 c_153' id='c_153_1' href='#c_153_2' cs_f='.c_153' >com o objetivo de</span> obter um menor tempo de execução do programa,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 29<br>
Figure 12 – Trecho de código traduzido para linguagem C.<br>
1 /? S t a r <span class='f1 c_65' id='c_65_1' href='#c_65_2' cs_f='.c_65' >t o f</span> T r a n s l a t i o n ? /<br>
2 /? p0 : ? /<br>
3 i f ( chg [ x ] | | chg [ y ] ) {<br>
4 i f ( ( ( o l d [ x ]==1) && ( o l d [ y ]==1) ) ) {<br>
5 new [ f ] = 1 ;<br>
6 }<br>
7 e l s e {<br>
8 new [ f ] = 0 ;<br>
9 }<br>
10 }<br>
11 /? End o f T r a n s l a t i o n ? /<br>
Fonte: Própria.<br>
porém outros fatores podem ser introduzidos, como algoritmos menores. Este fato não implica<br>
em afirmar que o melhor código é gerado, visto que dada a complexidade, raramente pode ser<br>
obtido que o código gerado pode ser o melhor possível (AHO et al., 2007).<br>
Segundo AHO et al., otimização local de código consiste na otimização de um bloco<br>
básico de código, <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >ou seja, a</span> otimização ocorre em um trecho especifico de código. Os blocos<br>
básicos são trecho onde não ocorrem saltos ou loops, para nenhuma outra parte do código. A<br>
otimização global de código é baseado na analise do fluxo <span class='f1 c_323' id='c_323_1' href='#c_323_2' cs_f='.c_323' >de dados, de modo que</span> ocorra as<br>
elminação de instruções não necessárias ou substituição mais facil. A otimização global consite<br>
na analise completa do código. Neste sentido, nas próximas seções serão apresentadas algumas<br>
importantes técnicas de otimizações.<br>
2.3.2.1 Grafo Acliclico Direcional - GAD<br>
Grafo Aciclico Direcional é utilizado para diversos fins dentro da estrutura de compi-<br>
ladores, principalmente para geração da parse tree otimização de código. Pode ser usado na<br>
representação de instruções unicas blocos básicos de código(AHO et al., 2007). <span class='f1 c_234' id='c_234_1' href='#c_234_2' cs_f='.c_234' >O uso de</span> GAD<br>
permite a melhoria de de código, tais como:<br>
• Elminação de subexpressões locais comuns, ou seja, expressões que o valor já foi com-<br>
putado anteriomente;<br>
• Eliminação de código morto;<br>
• Reordernamento de declarações buscando reduzir o tempo que o valor temporário necessita<br>
ser preservado em um registro;<br>
A Figura 13 apresenta um bloco básico com algumas instruções, no caso apresentando<br>
são 4 operações entre somas e multiplicação <span class='f1 c_171' id='c_171_1' href='#c_171_2' cs_f='.c_171' >e a partir deste</span> bloco a Figura 14 apresenta o GDA<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 30<br>
Figure 13 – Exemplo de bloco basico de código.<br>
1 a = b + c<br>
2 b = a ? d<br>
3 c = b + c<br>
4 d = a ? d<br>
Fonte: (AHO et al., 2007)<br>
Figure 14 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
deste trecho de código. Nele apresenta cada nó como uma operação especifica e os terminais<br>
como as parcelas das operações.<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC<br>
Grafo de fluxo de controle corresponde a um grafo direcionado, no qual cada nó rep-<br>
resenta blocos básicos e cada aresta representa <span class='f1 c_291' id='c_291_1' href='#c_291_2' cs_f='.c_291' >os caminhos de</span> fluxo entre os blocos basi-<br>
cos (ALLEN, 1970). É importante ressaltar que saltos determinam o final de um determinado<br>
bloco básico, ou seja, saltos indicam um caminho para uma nova região de código básico (AHO<br>
et al., 2007).<br>
Apresentar um exemplo de como e utilizado em código<br>
2.3.2.3 Eliminção de código morto<br>
A eliminacação de código morto é uma técnica que busca a eficiência de um programa<br>
evitando a execução de instruções não necessária em tempo de execução (KNOOP et al., 1994).<br>
O código morto consiste em instruções que não serão alcançáveis durante o fluxo do programa,<br>
sendo esta técnica basicamente a retirada de qualquer variável que não será utilizada em qualquer<br>
outro nó do grafo (AHO et al., 2007).<br>
A utilização de GAD corresponde na eliminação de qualquer nó raiz, ou seja, nó sem<br>
ancestrais, as quais não esteja ativa anexada a mesma. A execução repetida desta operação<br>
removerá todos os nós correspondentes a código morto (AHO et al., 2007).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 31<br>
Figure 15 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
Na Figura 15, supondo que os nós a, b e c estejam ativa, porém o nó énão esteja, o último Corrigir<br>
nó é?pode ser eliminado imediatamente. Os nós restantes continuam no GDA, a menos que não tenho<br>
variáveis ativas atreladas aos nós (AHO et al., 2007).<br>
2.3.2.4 Análise do fluxo de dados<br>
Análise de fluxo de dados <span class='f1 c_266' id='c_266_1' href='#c_266_2' cs_f='.c_266' >refere-se ao</span> conjunto de técnicas que derivam informações<br>
sobre o fluxo de dados ao longo dos caminhos de execução do programa. Para análise do<br>
programa, é necessário considerar todas as posiveis execuções através do grafo de fluxo de<br>
controle (AHO et al., 2007).<br>
Apresentar exemplos<br>
2.3.2.5 Gerador de código<br>
O gerador de código é responsavél pela tradução final do programa-<span class='f1 c_275' id='c_275_1' href='#c_275_2' cs_f='.c_275' >fonte para o</span> programa-<br>
alvo, o mesmo recebe como entrada um código intermediário juntamente <span class='f1 c_118' id='c_118_1' href='#c_118_2' cs_f='.c_118' >com a tabela</span> de<br>
símbolos. Faz-se necessário que o programa-fonte tenha sido analisado sintatica e lexicamente,<br>
assim evitando que erros possam ser passados para o programa-alvo, por outro lado a existência<br>
de uma nível de otimização, faz-se opicional neste caso (AHO et al., 2007).<br>
O gerador de código possui três tarefas primarias, sendo as mesmas seleção de instrução,<br>
alocação de registros e atribuições. A seleção de instruções envolve a escolha das instruções<br>
apropriadas da máquina-alvo para implementar as declarações do código intermediario. A<br>
atribuição e atribuição de registros envolve a decisão <span class='f1 c_132' id='c_132_1' href='#c_132_2' cs_f='.c_132' >sobre os valores</span> a serem registrados nos<br>
registros(AHO et al., 2007).<br>
Apresentar exemplo<br>
32<br>
3 TRABALHOS CORRELATOS<br>
Sugiro apenas mencionar que foi feito a revisão sistemática; o que já foi feito e os resul-<br>
tados. As outras seções sobre RS e mover para apêndice.<br>
3.1 Revisão sistemática<br>
A revisão sistemática consiste é um método de identificação, análise e interpretação de<br>
pesquisas relevantes em determinada área ou questão de pesquisa. Para execução da revisão sis-<br>
temática se requer um esforço maior, em comparação as pesquisas tradicionais, sendo necessário<br>
seguir uma sequência de passos metodológicos sobre a área ou questão de pesquisa ao qual<br>
deseja ser feita a pesquisa (KITCHENHAM, 2004).<br>
Para a execução da revisão sistemática, é necessário um esforço considerável, se com-<br>
parado a uma revisão informal a literatura. Enquanto que a revisão de literatura informal é<br>
conduzida de forma ad-hoc, sem planejamento e critérios de seleção estabelecidos a priori,<br>
a revisão sistemática requer um protocolo formal bem definido, com uma sequência de pas-<br>
sos metodológicos, para conduzir uma pesquisa sobre o tema ao qual deseja-<span class='f1 c_108' id='c_108_1' href='#c_108_2' cs_f='.c_108' >se realizar a</span><br>
pesquisa (MAFRA; TRAVASSOS, 2006).<br>
A aplicação da revisão sistemática requer que seja seguido um conjunto bem definido e<br>
sequêncial de passos, seguindo um protocolo de pesquisa desenvolvido previamente. Através<br>
deste método é possível realizar uma extensa pesquisa, contemplando uma grande quantidade<br>
de informações sobre o assunto pesquisado (MAFRA; TRAVASSOS, 2006). Este protocolo é<br>
construído considerando um tema específico <span class='f1 c_85' id='c_85_1' href='#c_85_2' cs_f='.c_85' >que representa o</span> elemento central da investigação,<br>
onde os passos da pesquisa, as estratégias definidas para coletar as evidências e o foco das<br>
questões de pesquisa são definidas explicitamente, <span class='f1 c_130' id='c_130_1' href='#c_130_2' cs_f='.c_130' >de tal forma que</span> outros pesquisadores sejam<br>
capazes de reproduzir o mesmo protocolo de pesquisa (BIOLCHINI et al., 2005).<br>
Segundo MAFRA; TRAVASSOS, o processo para a condução de revisões sistemáticas<br>
envolve três etapas:<br>
1. Planejamento da Revisão: os objetivos da pesquisa são listados e o protocolo da revisão<br>
é definido.<br>
2. Condução da Revisão:nesta atividade, as fontes para a revisão sistemática são sele-<br>
cionadas, os estudos primários são identificados, selecionados e avaliados <span class='f1 c_195' id='c_195_1' href='#c_195_2' cs_f='.c_195' >de acordo com<br>
os</span> critérios de inclusão, exclusão, e de qualidade estabelecidos durante o protocolo da<br>
revisão.<br>
Chapter 3. TRABALHOS CORRELATOS 33<br>
3. Análise dos Resultados: os dados dos estudos são extraídos e sintetizados para análise e<br>
apresentação dos resultados.<br>
Vale ressaltar <span class='f1 c_93' id='c_93_1' href='#c_93_2' cs_f='.c_93' >que como o objetivo deste trabalho</span> é <span class='f1 c_83' id='c_83_1' href='#c_83_2' cs_f='.c_83' >realizar um estudo</span> exploratório de<br>
caracterização de área podemos dizer que esta revisão sistemática se caracteriza como uma quasi-<br>
sistemática (TRAVASSOS et al., 2008), pois segue o mesmo processo da revisão sistemática e<br>
preserva o rigor e mesmo formalismo para as fases metodológicas de elaboração de protocolo e<br>
execução da revisão, mas sem a aplicação de uma meta-análise a princípio, <span class='f1 c_243' id='c_243_1' href='#c_243_2' cs_f='.c_243' >que pode ser</span> aplicada<br>
posteriormente.<br>
3.1.1 Planejamento da Revisão Sistemática<br>
Objetivo: Este estudo <span class='f1 c_298' id='c_298_1' href='#c_298_2' cs_f='.c_298' >tem o objetivo</span> esquematizado <span class='f1 c_36' id='c_36_1' href='#c_36_2' cs_f='.c_36' >a partir da</span> estrutura do paradigma<br>
GQM (do ingles Goal,Question and Metric)(BASILI et al., 1994).<br>
Analisar Publicações científicas através de um estudo baseado em revisão sis-<br>
temática<br>
Com propósito de Identifica-las<br>
Com relação as Vantagens e desvantagens da utilização de assertiva e transformações<br>
de código na verificação do código na linguagem de descrição VHDL<br>
<span class='f1 c_254' id='c_254_1' href='#c_254_2' cs_f='.c_254' >Do ponto de vista</span> do Pesquisador<br>
No contexto Acadêmico ou industrial para verificação de assertivas na linguagem<br>
de descrição VHDL<br>
Table 1 – Objetivo do estudo utilizando <span class='f1 c_314' id='c_314_1' href='#c_314_2' cs_f='.c_314' >o paradigma GQM</span><br>
Formulação da Pergunta: Buscamos respostas para as seguintes perguntas:<br>
• Q1: Quais são os métodos para verificação de circuitos lógicos descritos na linguagem de<br>
programação VHDL?<br>
– Q1.1: <span class='f1 c_123' id='c_123_1' href='#c_123_2' cs_f='.c_123' >Foi desenvolvido e</span> está disponível alguma ferramenta para aplicação do<br>
método?<br>
– Q1.2: Qual a técnica de exploração de estados para circuitos lógicos?<br>
– Q1.3: O método proposto é baseado em técnicas de verificação de software?<br>
– Q1.4: Como o método proposto valida pré e pós condições no programa?<br>
– Q1.3: Foi utilizado algum benchmark de programas em VHDL para experimentação<br>
e o mesmo encontra-se disponível?<br>
– Q1.4: Quais as perspectivas futuras para melhorar da aplicação do método proposto?<br>
<span class='f1 c_271' id='c_271_1' href='#c_271_2' cs_f='.c_271' >Escopo da pesquisa</span>:Na delimitação do <span class='f1 c_271' id='c_271_1' href='#c_271_2' cs_f='.c_271' >escopo da pesquisa</span> foram estabelecidos critérios,<br>
buscando garantir a viabilidade da execução, acessibilidade dos dados e abrangência do estudo re-<br>
alizado. <span class='f1 c_288' id='c_288_1' href='#c_288_2' cs_f='.c_288' >A pesquisa dar-se</span>-á <span class='f1 c_34' id='c_34_1' href='#c_34_2' cs_f='.c_34' >a partir de</span> bibliotecas digitais através das suas respectivas máquinas<br>
Chapter 3. TRABALHOS CORRELATOS 34<br>
<span class='f1 c_117' id='c_117_1' href='#c_117_2' cs_f='.c_117' >de busca e</span>, quando os dados não estiverem disponíveis eletronicamente, através de consultas<br>
manuais.<br>
Critérios de Seleção de Fontes. Para <span class='f1 c_169' id='c_169_1' href='#c_169_2' cs_f='.c_169' >as bibliotecas digitais</span> é desejado:<br>
• Possuir uma máquina de busca que permita <span class='f1 c_234' id='c_234_1' href='#c_234_2' cs_f='.c_234' >o uso de</span> expressões lógicas ou mecanismo<br>
equivalente.<br>
• Incluir em sua base, publicações de exatas ou correlatas que possuam relação direta com o<br>
tema a ser pesquisado<br>
• As máquinas de busca deverão permitir a busca no texto completo das publicações.<br>
Segundo ROCHA et al., os mecanismos <span class='f1 c_33' id='c_33_1' href='#c_33_2' cs_f='.c_33' >de busca utilizados</span> devem garantir resultados<br>
únicos através da busca <span class='f1 c_315' id='c_315_1' href='#c_315_2' cs_f='.c_315' >de um mesmo</span> conjunto de palavras-chaves (<span class='f1 c_126' id='c_126_1' href='#c_126_2' cs_f='.c_126' >string de busca</span>). Quando<br>
isto não for possível, deve-se estudar e documentar <span class='f1 c_88' id='c_88_1' href='#c_88_2' cs_f='.c_88' >uma forma de minimizar os</span> potenciais efeitos<br>
colaterais desta limitação.<br>
Métodos de Busca das Publicações. As fontes digitais foram acessadas via Web, através<br>
de expressões de busca pré-estabelecidas. A biblioteca digital consultada foi a Scopus, acessível<br>
em http://www.scopus.com. Segundo a editora ELSEVIER, a Scopus é uma das maiores <span class='f1 c_224' id='c_224_1' href='#c_224_2' cs_f='.c_224' >bases<br>
de dados de</span> resumos e citações da literatura de pesquisa peer-reviewed com mais de 22, 800<br>
títulos <span class='f1 c_76' id='c_76_1' href='#c_76_2' cs_f='.c_76' >de mais de</span> 5, 000 editoras internacionais abrangendo as áreas de tecnologia, medicina,<br>
artes, ciências sócias e com atualizações diárias. Entre as editoras podemos citar: Springer<br>
(SPRINGER, 2018); IEEE Xplore Digital Library (IEEE, 2018);ACM Digital Library (ACM,<br>
2018) ; ScienceDirect/Elsevier (B.V, 2018); Wiley Online Library (SONS, 2018); dentre outras.<br>
<span class='f1 c_126' id='c_126_1' href='#c_126_2' cs_f='.c_126' >String de Busca</span>. <span class='f1 c_82' id='c_82_1' href='#c_82_2' cs_f='.c_82' >A string de busca</span> foi definida segundo o padrão PICO (do inglês<br>
Population, Intervention, Comparison, Outcomes) (KITCHENHAM et al., 2009), conforme a<br>
estrutura abaixo:<br>
• População: Trabalhos publicados em conferências e periódicos que relacionam verificação<br>
de propriedades de circuitos lógicos em códigos para a descrição de hardware.<br>
• Intervenção: Verificação de propriedades relacionadas a verificação de circuitos para as<br>
diferentes estruturas das linguagens de descrição de hardware;<br>
• Comparação: análise de cobertura e suporte das abordagens identificadas para a verificação<br>
de propriedades das linguagens de descrição de hardware;<br>
• Resultados: <span class='f1 c_36' id='c_36_1' href='#c_36_2' cs_f='.c_36' >a partir da</span> descrição das abordagens pretende-se verificar a cobertura que cada<br>
abordagem apresenta na manipulação das diferentes estruturas da linguagem de descrição<br>
de hardware para a verificação de propriedades baseada em assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 35<br>
Segundo ROCHA et al., como este estudo representa <span class='f1 c_256' id='c_256_1' href='#c_256_2' cs_f='.c_256' >um estudo de</span> mapeamento/caracteri-<br>
zação, <span class='f1 c_82' id='c_82_1' href='#c_82_2' cs_f='.c_82' >a string de busca</span> foi definida <span class='f1 c_195' id='c_195_1' href='#c_195_2' cs_f='.c_195' >de acordo com</span> dois aspectos: População e Intervenção, como<br>
é apresentado na estrutura abaixo. Posteriormente esta mesma <span class='f1 c_126' id='c_126_1' href='#c_126_2' cs_f='.c_126' >string de busca</span> será executada<br>
na biblioteca Scopus para busca <span class='f1 c_283' id='c_283_1' href='#c_283_2' cs_f='.c_283' >de artigos e</span> publicações <span class='f1 c_133' id='c_133_1' href='#c_133_2' cs_f='.c_133' >de modo a</span> gerar uma interseção entre<br>
população e intervenção.<br>
• População: publicações que fazem referência a verificação de propriedades de circuitos<br>
lógicos e sinônimos:<br>
– Palavras-chaves: "circuit checker" OR "circuit verification" OR "contract based<br>
verification" OR "code analysis" OR "static analysis" OR "dynamic analysis" OR<br>
"safety verification" OR "RTL analysis" OR "program analysis" OR "property veri-<br>
fication" OR "formal verification" OR "model checking" OR "model checker" OR<br>
"hardware checker" OR "hardware verification" OR "validity checker" OR "hard-<br>
ware assertion" OR "assertion checker" OR "assert verification" OR "assertion-based<br>
verification" OR "assertion based verification" OR "assertion-based design" OR "bit<br>
level verification"<br>
• Intervenção: Verificação de circuitos e sinônimos:<br>
– Palavras-chaves:"hardware statement" OR "hardware code" OR "hardware source<br>
code" OR "hardware semantics" OR "hardware property" OR "logical gates" OR<br>
"sequential circuit" OR "parallel circuit" OR "real circuits" OR "complex circuits"<br>
OR "control circuitry" OR ”software netlist” OR “hardware emulation” OR “silicon<br>
debug”<br>
3.1.1.1 Procedimentos de Seleção e Critérios<br>
A estratégia de busca será aplicada por um pesquisador para identificar as publicações<br>
em potencial. A seleção das publicações dar-se-á em 2 etapas, conforme apresentado a seguir.<br>
1. Seleção e catalogação preliminar <span class='f1 c_106' id='c_106_1' href='#c_106_2' cs_f='.c_106' >dos dados coletados: A</span> seleção preliminar das publi-<br>
cações será feita <span class='f1 c_36' id='c_36_1' href='#c_36_2' cs_f='.c_36' >a partir da</span> aplicação da <span class='f1 c_126' id='c_126_1' href='#c_126_2' cs_f='.c_126' >string de busca</span> na biblioteca Scopus, o resultado<br>
desta busca corresponde a seleção preliminar. Todas as publicações serão armazenadas<br>
para análise posterior;<br>
2. Seleção dos dados relevantes - [1 filtro]: A seleção preliminar com o uso da expressão<br>
de busca não garante que todo o material coletado seja útil no contexto da pesquisa, pois a<br>
aplicação das expressões de busca é restrita ao aspecto sintático. Por isso, é necessário a<br>
criação <span class='f1 c_237' id='c_237_1' href='#c_237_2' cs_f='.c_237' >de filtros de</span> exclusão e inclusão, <span class='f1 c_133' id='c_133_1' href='#c_133_2' cs_f='.c_133' >de modo a</span> classificar os artigos e publicações que<br>
se enquadram no contexto da pesquisa realizada. Nesta epata apenas serão lidos o título,<br>
abstracts, e palavras-chaves e classificar <span class='f1 c_195' id='c_195_1' href='#c_195_2' cs_f='.c_195' >de acordo com os</span> filtros, ou seja, se será aceito ou<br>
excluído. Devem ser excluídas as publicações contidas no conjunto preliminar que:<br>
Chapter 3. TRABALHOS CORRELATOS 36<br>
• CE1-01: Não serão selecionadas publicações em que as palavras-chave da busca<br>
não apareçam no título, resumo e/ou texto da publicação (excluem-se os seguintes<br>
campos: as seções de agradecimentos, biografia dos autores, referências bibliográficas<br>
e anexas).<br>
• CE1-02: Não serão selecionadas publicações em que descrevam e/ou apresentam<br>
‘keynote speeches’, tutoriais, cursos e similares.<br>
• CE1-03: Não serão selecionadas publicações <span class='f1 c_101' id='c_101_1' href='#c_101_2' cs_f='.c_101' >em que o</span> contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita <span class='f1 c_96' id='c_96_1' href='#c_96_2' cs_f='.c_96' >uma abordagem para</span><br>
verificação/validação de códigos para descrição de hardware.<br>
• CE1-04: Não serão selecionadas publicações <span class='f1 c_101' id='c_101_1' href='#c_101_2' cs_f='.c_101' >em que o</span> contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita <span class='f1 c_96' id='c_96_1' href='#c_96_2' cs_f='.c_96' >uma abordagem para</span><br>
verificação de código de descrição de hardware baseado em assertivas ou propriedades<br>
de verificação de hardware.<br>
Podem ser incluídas apenas as publicações contidas no conjunto preliminar que:<br>
• CI1-01:<span class='f1 c_269' id='c_269_1' href='#c_269_2' cs_f='.c_269' >Podem ser selecionadas</span> publicações <span class='f1 c_101' id='c_101_1' href='#c_101_2' cs_f='.c_101' >em que o</span> contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita <span class='f1 c_96' id='c_96_1' href='#c_96_2' cs_f='.c_96' >uma abordagem para</span> verificação<br>
de código de descrição de hardware baseado em assertivas ou propriedades de<br>
verificação de hardware.<br>
• CI1-02:<span class='f1 c_269' id='c_269_1' href='#c_269_2' cs_f='.c_269' >Podem ser selecionadas</span> publicações <span class='f1 c_101' id='c_101_1' href='#c_101_2' cs_f='.c_101' >em que o</span> contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita recomendações de melhoria<br>
na utilização de abordagens para verificação de código de descrição de hardware<br>
baseado em assertivas ou propriedades de verificação de hardware.<br>
3. Seleção dos dados relevantes - [2 filtro]: Apesar do 1o filtro limitar o universo de busca,<br>
infelizmente não há garantias de que todo material selecionado no filtro anterior seja útil<br>
no contexto da pesquisa. Neste caso, novos filtros são gerados, buscando, da mesma forma<br>
que <span class='f1 c_156' id='c_156_1' href='#c_156_2' cs_f='.c_156' >o primeiro filtro</span>, classificar os artigos e publicações que se enquadram no contexto<br>
da pesquisa. Para este filtro é necessário a leitura na integras dos artigos selecionados<br>
anteriormente. O objetivo é identificar que relacionam assertivas e/ou propriedade de<br>
verificação de hardware.<br>
• CS2 -ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware e não citam assertivas<br>
• CS2 +ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware, mas citam assertivas<br>
• CS2 -ASS +VER_HARD: Não devem ser selecionadas publicações que contextual-<br>
izam verificação de hardware, mas citam assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 37<br>
Dessa forma, todas as publicações devem respeitar o critério abaixo:<br>
• CS3 +ASS +VER_HARD: Serão selecionadas publicações que contextualizam<br>
verificação de hardware e citam assertivas em seu contexto.<br>
Devido ao tempo necessário <span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >para o desenvolvimento</span> execução dos filtros da revisão<br>
sistemática serem extensos, apenas <span class='f1 c_156' id='c_156_1' href='#c_156_2' cs_f='.c_156' >o primeiro filtro</span> foi executado neste projeto, mesmo que<br>
<span class='f1 c_66' id='c_66_1' href='#c_66_2' cs_f='.c_66' >os parâmetros</span> para <span class='f1 c_109' id='c_109_1' href='#c_109_2' cs_f='.c_109' >o segundo filtro</span> já tenho sido desenvolvidos. Em contra partida foram<br>
<span class='f1 c_102' id='c_102_1' href='#c_102_2' cs_f='.c_102' >selecionados 6 artigos que</span> serviram como ferramentas de estudo <span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >para o desenvolvimento da</span><br>
metodologia que será apesentada no Capítulo 4.<br>
3.2 Revisão da literatura<br>
Nesta sessão serão apresentados trabalho relevantes <span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >para o desenvolvimento</span> do método<br>
proposto que foram identificados utlizando a revisão sistemática mencionado anteriormente.<br>
Os artigos apresentam técnicas de transformações de código, utilização de Assertion-Based<br>
Verification e PSL para verificação de hardware.<br>
3.2.1 V2c-A verilog to C translator<br>
O artigo de MUKHERJEE et al. apresenta uma ferramenta implementada em C++<br>
chamada v2c para transformação de código da linguagem de descrição Verilog para linguagem<br>
de programação C. A ferramenta é executada a nível de palavra, visto <span class='f1 c_115' id='c_115_1' href='#c_115_2' cs_f='.c_115' >que esta abordagem</span> garante<br>
uma aumento na escalabilidade, mas também proporionando que técnicas, como interpolaçãoe adicionar<br>
refer-<br>
ência<br>
aceleração de looppossam ser utilizadas para verificação, algo inviavél, caso a tradução fosse<br>
adicionar<br>
refer-<br>
ência<br>
executada a nível de bit. O sistema recebe como entrada um código em Verilg, onde são aplicadas<br>
regras semânticas e mapeando os bit de operação, chamado software netlist. Após isso, o código<br>
intermediário é convertido para C.<br>
A contribuição deste trabalhoconsiste na utilização de transformações de código como<br>
Qual<br>
tra-<br>
balho?<br>
base principal e partindo deste pressuposto torna-se vantajoso devido a utilização de outras<br>
ferramentas que não apresente suporte a certas linguagens, tais com a ferramenta ESBMC,<br>
utilizada neste trabalho, não apresenta suporte a VHDL, porém apresenta suporte as linguagens<br>
C/C++. <span class='f1 c_94' id='c_94_1' href='#c_94_2' cs_f='.c_94' >Em outras palavras</span>, a contribuição deste trabalhofoi a utilização de traduções de códigos<br>
Qual<br>
tra-<br>
balho?<br>
e utilizado este conceito como modelo <span class='f1 c_98' id='c_98_1' href='#c_98_2' cs_f='.c_98' >de entrada para</span> analise de circuitos.<br>
3.2.2 Unbounded safety verification for hardware using software ana-<br>
lyzers<br>
No artigo de MUKHERJEE et al. foi apresentado uma metodologia que aborda a utiliza-<br>
ção de técnicas e analisadores de software, <span class='f1 c_153' id='c_153_1' href='#c_153_2' cs_f='.c_153' >com o objetivo de</span> de abordar a análise de circuitos e<br>
Chapter 3. TRABALHOS CORRELATOS 38<br>
com isso trançar um paralelo entre as abordagens. Para testes foram utilizadas três metodologias<br>
de análise, usando interpolação, k-inductione tecnologias hibrídas. Como resultante dos testes, foi adicionar<br>
refer-<br>
ência<br>
adicionar<br>
refer-<br>
ência<br>
observado as principais causas de erros, por exemplo, bits não preciso e no caso das operações<br>
a bit-level ocorria perda de informações. Também foi obeservado que apesar de não serem<br>
otimizadas para análises de hardware, alguns analisadores de softaware podem, dependendo da<br>
técnica utilizada no analisador, ser utilizada para analise de hardware.<br>
Descrever<br>
qual<br>
o mo-<br>
tivo.<br>
A utilização de técnicas de análise de software <span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >para o desenvolvimento de</span> análise de<br>
hardware é o foco a ser abordado neste neste trabalho de maneira prática, utilizando os princípio<br>
analisados por (MUKHERJEE et al., 2016a). Neste contexto, <span class='f1 c_127' id='c_127_1' href='#c_127_2' cs_f='.c_127' >o objetivo deste trabalho</span> é a<br>
utilização de técnicas de software para análise de circuitos, diferente do artigo apresentado acima<br>
que busca utilização uma abordagem mais complexa provando a possibilidade da utilização de<br>
técnicas de analise de software no contexto da verificação de hardware.<br>
A última frase está confusa, no meu entedimento é o mesmo sentido.<br>
3.2.3 Formal verification of timed VHDL programs<br>
No trabalho apresentado por BARA et al. é <span class='f1 c_90' id='c_90_1' href='#c_90_2' cs_f='.c_90' >proposto uma abordagem para</span> a análise<br>
de tempo relacionado a cada porta lógica <span class='f1 c_199' id='c_199_1' href='#c_199_2' cs_f='.c_199' >dentro de um</span> dado circuito analisado. A abordagem<br>
apresenta a tradução de um circuito lógico codificado em VHDL para um formalismo baseado<br>
em automato de tempo. Tal formalismo é representado por uma automato de estados finitos referência<br>
com relogios simbólicos que evoluem em taxa uniforme. A tradução é executada de modo<br>
automatico, baseado na emulação da propagação de cada transação <span class='f1 c_221' id='c_221_1' href='#c_221_2' cs_f='.c_221' >ao longo de</span> cada sinal, o<br>
seja, são automatos programados e cronometrados do circuito. Após a tradução para automato, a<br>
analise é feita pela ferramenta UPPALque é um model checking de verificação de propriedades referência<br>
de tempo. Seguindo esta metodologia a análise pode ser extraida de modo independente de cada<br>
bloco, desta forma a análise é feita de forma mais precisa, podendo ser analisado inumeros<br>
<span class='f1 c_244' id='c_244_1' href='#c_244_2' cs_f='.c_244' >fatores, tais como</span> limites de intervalo e sinal de correlação.<br>
<span class='f1 c_19' id='c_19_1' href='#c_19_2' cs_f='.c_19' >O artigo apresenta uma abordagem de</span> tempo, que torna-se interessante adição ao método.<br>
Porém até o momento a função não foi implementada ficando a trabalho futuros.<br>
Expandir o texto acima, exemplo, descrever como o método poderia ser incluindo no seu<br>
TCC.<br>
3.2.4 On the use of assertions for embedded-software dynamic verifica-<br>
tion<br>
Em GUGLIELMO et al. é apresentado uma metodologia para a integração dinamica de<br>
Assertion-Based Verification para várias fases da análise da verificação de fluxo <span class='f1 c_326' id='c_326_1' href='#c_326_2' cs_f='.c_326' >em sistemas<br>
embarcados</span>, por exemplo, emulação, diagnosticos e Debug, mas também um ferramenta chamada<br>
Chapter 3. TRABALHOS CORRELATOS 39<br>
RadCheck. O metodo de aplicação, chamado V-model é dividido em fases de verificação em<br>
paralelo com as fases de design do circuito. <span class='f1 c_290' id='c_290_1' href='#c_290_2' cs_f='.c_290' >Com base no</span> V-model, o método é aplicado, iniciando<br>
com o nível de sistema e as especificação do sistema, neste caso especificado usando PSL.<br>
Neste nível é especificado todas as funcionalidades gerais da aplicação. No nível de integração<br>
visa investigar problemas de interação que possam ocorrer, definindo propriedades que cobrem<br>
incrementalmente as unidades estruturais interativas de aplicação. No nível de unidade descrevem<br>
comportamentos internos e são definidas através <span class='f1 c_318' id='c_318_1' href='#c_318_2' cs_f='.c_318' >de parâmetros de</span> entrada/saída das unidade e<br>
estruturas de dados internas.<br>
A contribuição deste projeto está relacionado a utilização de assertivas no contexto da<br>
verificação de software. As assertivas são o principal meio de análise proposto neste projeto,<br>
visto que estas mesma assertivas serão analisadas pelo ESBMC. Aliado a isso em GUGLIELMO<br>
et al. é apresentado modelos de utilização de assertivas no processo de verificação de hardware,<br>
e tais assertivas foram adaptadas para um modelo proposto neste trabalho.<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation<br>
No trabalho de BOULE; ZILIC é apresentado <span class='f1 c_64' id='c_64_1' href='#c_64_2' cs_f='.c_64' >uma ferramenta de</span> geração de assertivas<br>
no contexto da emulação de circuitos, <span class='f1 c_57' id='c_57_1' href='#c_57_2' cs_f='.c_57' >de modo que</span> estas assertivas descrita em PSL possam<br>
transformadas <span class='f1 c_170' id='c_170_1' href='#c_170_2' cs_f='.c_170' >para o modelo de</span> linguagem de descrição de hardware. Inicialmente é realizada<br>
toda análise de cada assertiva e a mesma é traduzida em partes, levando em consideração os<br>
operadores e cada estrutura, por exemplo if-else, utilizado na declaração da assertiva.<br>
Apresentar um exemplo para explicar o texto acima<br>
trabalho de BOULE; ZILIC consolida e apresenta aspectos importantes, tais como a<br>
utilização de uma ferramenta para geração de assertivas, o que torna-se no contexto deste projeto,<br>
extremamente importante, visto <span class='f1 c_282' id='c_282_1' href='#c_282_2' cs_f='.c_282' >que o modelo</span> adotado atualmente consiste tanto na geração<br>
automática das assertivas, <span class='f1 c_112' id='c_112_1' href='#c_112_2' cs_f='.c_112' >bem como a</span> inserção manual por parte do usuário.<br>
40<br>
4 MÉTODO PROPOSTO<br>
Este Capítulo descreve o método proposto neste trabalho, baseado transformações de<br>
código para análise de circuitos lógicos descritos em VHDL utilizando Bounded Model Checking,<br>
neste caso o model checker ESBMC.<br>
4.1 Visão geral do método<br>
O método proposto consiste inicialmente em receber como entrada um circuito lógico<br>
descrito em VHDL, onde uma dada propriedade <span class='f1 c_67' id='c_67_1' href='#c_67_2' cs_f='.c_67' >representada em uma</span> assertiva será analisada,<br>
as assertivas serão inseridas de automaticamente pelo método ou pelo próprio usuário do método.<br>
O código VHDL analisado posteriomente é traduzido para linguagem C e recebe uma instrumen-<br>
tação de código (com funções especificas suportadas pelo método) para a posterior validação do<br>
mesmo. O Código em C automaticamente gerado, já instrumentado, será processado e analisado<br>
pelo ESBMC <span class='f1 c_195' id='c_195_1' href='#c_195_2' cs_f='.c_195' >de acordo com</span> as assertivas inseridas e ao final é apresentado o resultado. Caso<br>
alguma das assertivas seja violada, um contra-exemplo é apresentado ao usuário. Uma visão<br>
geral do método proposto é apresentado na Figura 16 e nas sessões a seguir serão apresentados<br>
cada etapa do método proposto neste trabalho.<br>
Figure 16 – Ciclo da ferramenta<br>
Fonte: Própria<br>
Com o intuito de auxiliar nas explicações apresentadas nas próximas sessões, o código<br>
na Figura 17 será utilizado nas explanações, bem como será apresentado todas as alterações do<br>
mesmo, conforme cada etapa do método.<br>
Chapter 4. MÉTODO PROPOSTO 41<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 ENTITY U l a _ t c c IS<br>
5 PORT(A, B , B i n v e r t i d o , Op1 , Op2 : IN BIT ;<br>
6 R e s u l t a d o :OUT BIT ) ;<br>
7 END U l a _ t c c ;<br>
8<br>
9 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
10 SIGNAL a n d _ p o r t : b i t ;<br>
11 SIGNAL o r _ p o r t : b i t ;<br>
12 SIGNAL x o r _ p o r t : b i t ;<br>
13 SIGNAL mux2x1 : b i t ;<br>
14 BEGIN<br>
15 PROCESS(A, B , B i n v e r t i d o , Op1 )<br>
16 BEGIN<br>
17 ??PORTA AND<br>
18 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
19 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
20 ELSE<br>
21 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
22 END IF ;<br>
23 ??PORTA OR<br>
24 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
25 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
26 ELSE<br>
27 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
28 END IF ;<br>
29 ??PORTA XOR<br>
30 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
31 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
32 ELSIF (A = ’ 1 ’ and mux2x1 = ’ 1 ’ ) THEN<br>
33 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
34 ELSE<br>
35 x o r _ p o r t &lt;= ’ 1 ’ ;<br>
36 END IF ;<br>
37 ??INVERSOR<br>
38 IF ( B i n v e r t i d o = ’ 0 ’ ) THEN<br>
39 mux2x1 &lt;= B ;<br>
40 ELSE<br>
41 mux2x1 &lt;= NOT B ;<br>
42 END IF ;<br>
43 ??MUX4X1<br>
44 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
45 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
46 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
47 R e s u l t a d o &lt;= o r _ p o r t ;<br>
48 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
49 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
50 END IF ;<br>
51 END PROCESS ;<br>
52 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 42<br>
4.2 Preprocessamento do VHDL e inserção de assertivas<br>
A fase inicial do método consiste no preprocessamento do código VHDL com as an-<br>
otações de código pelo usuário ou pelo método proposto de forma automática, incluindo as<br>
assertivas, conforme a Figura 16, na etapa A. O método não realiza <span class='f1 c_181' id='c_181_1' href='#c_181_2' cs_f='.c_181' >qualquer tipo de</span> verificação<br>
sobre o código VHDL, apenas utiliza o mesmo como entrada juntamente com as assertivas<br>
inseridas. Toda verificação é realizada sobre o código em linguagem C, que será traduzido <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >a<br>
partir do</span> código VHDL analisado, nas próximas etapas do método proposto. Vale ressaltar que<br>
mesmo a linguagem VHDL tendo <span class='f1 c_310' id='c_310_1' href='#c_310_2' cs_f='.c_310' >um modelo de</span> assertivas padrão, para o método tornou-se<br>
necessário a criação <span class='f1 c_177' id='c_177_1' href='#c_177_2' cs_f='.c_177' >de um modelo</span> (baseado em comentários) para que as funções do model<br>
checker adotado fossem suportadas, como a geração de valores não deterministicos.<br>
As assertivas manuais são adicionadas entre as tags @c2vhdl:ASSERT e @c2vhdl:END<br>
e todo trecho de código entre estas tags deve estar comentado, desta forma não apresentará<br>
erro na tradução do código em linguagem C, bem como na sintetização do código VHDL. Nas<br>
assertivas são incluidas as funções necessárias para a análise utilizando a ferramenta ESBMC. A<br>
assertiva apresenta três informações principais, sendo elas: condição, mensagem e gravidade.<br>
Ajustar está assertiva. Para quem não vê o código todo, ela não faz sentido<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR.<br>
1 ??@c2vhdl : ASSERT<br>
2 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ )<br>
3 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 "<br>
4 ??s e v e r i t y ERROR;<br>
5 ??@c2vhdl :END<br>
Fonte: Própria.<br>
A condição (na linha 2 da Figura 19) representa a assertiva propriamente dita e que será<br>
analisado pela aplicação. A condição será precedida de??assert e seguido ou não da palavra<br>
not, com isso a assertiva pode assumir valor negativo, conforme necessidade do usuário. Na<br>
Figura 19 a assertiva busca verificar se a variavél Resultado terá valor igual a 1. Qual a<br>
razão<br>
para<br>
isso,<br>
ex-<br>
plique!<br>
A mensagem (??report na linha 3 da Figura 19) é definida pelo usuário e será<br>
apresentado caso a assertiva apresente falha, assim a mensagem pode ser utilizada <span class='f1 c_166' id='c_166_1' href='#c_166_2' cs_f='.c_166' >como um meio<br>
de</span> depuração das propriedades validadas. A severidade (severity na linha 4 da Figura 19)<br>
pode ser definida como error, <span class='f1 c_187' id='c_187_1' href='#c_187_2' cs_f='.c_187' >que representa um</span> erro fatal e parada da verificação. A severidade<br>
do tipo warning <span class='f1 c_187' id='c_187_1' href='#c_187_2' cs_f='.c_187' >que representa um</span> erro não fatal, contabiliza as falhas das assertivas, porém<br>
não causa a parada da verificação. As mensagens futuramente pode ser integradas um framework<br>
para teste de unidade, contudo está é uma etapa ainda em planejamento neste trabalho.<br>
Juntamente com as assertivas outra função <span class='f1 c_243' id='c_243_1' href='#c_243_2' cs_f='.c_243' >que pode ser</span> utilizada é a função __ESBMC<br>
Chapter 4. MÉTODO PROPOSTO 43<br>
_assume() suportada pelo model checker ESBMC. Esta função utilizada em conjuto com a<br>
ferramenta ESBMC permite que durante a verificação uma variavél possa ter uma valor setado<br>
<span class='f1 c_294' id='c_294_1' href='#c_294_2' cs_f='.c_294' >durante o tempo de</span> execução da verificação. A importância desta função é fazer verificações onde<br>
se conhece <span class='f1 c_114' id='c_114_1' href='#c_114_2' cs_f='.c_114' >os valores de</span> entrada juntamente com o valor resultante, por exemplo, na verificação<br>
de portas lógicas.<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume().<br>
1 ??__ESBMC_assume (A = ’ 1 ’ )<br>
2 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
Fonte: Própria.<br>
A assertivas que serão verificadas são automáticas traduzidas <span class='f1 c_80' id='c_80_1' href='#c_80_2' cs_f='.c_80' >a partir das</span> entradas do<br>
código VHDL. Seja no modelo manual (assertivas escritas pelo usuário) ou automático (inferidas<br>
pelo método proposto <span class='f1 c_265' id='c_265_1' href='#c_265_2' cs_f='.c_265' >por meio de</span> análise estática), as entradas são mapeadas para serem<br>
utilizados na etapa de instrumentação. Desta forma, tais entradas podem ser utilizadas para gerar<br>
essas assertivas e então serem adicionadas diretamente ao código em linguagem C <span class='f1 c_306' id='c_306_1' href='#c_306_2' cs_f='.c_306' >durante a fase<br>
de</span> instrumentação.<br>
A Figura 20 apresenta o código juntamente com as assertivas conforme o padrão salien-<br>
tado na section 4.2. Neste exemplo foi implementado utilizado a inserção manual das assertivas<br>
e também da função __ESBMC_assume(), entretanto o objetivo é automatizar estas funções<br>
durante a execução da ferramenta.<br>
4.3 Tradução de código VHDL para a linguagem C<br>
Nesta etapa a tradução do código VHDL para linguagem C é executada, conforme<br>
apresentado na Figura 16, etapa B. <span class='f1 c_242' id='c_242_1' href='#c_242_2' cs_f='.c_242' >A partir deste</span> ponto, a ferramenta é executada de maneira<br>
propriamente dita, tendo todo o processo automatizado até a apresentação do resultado. Para<br>
esta etapa do método foi selecionado a ferramenta V2Cque realiza a tradução de VHDL para Adicionar<br>
refer-<br>
ência<br>
Linguagem C.<br>
A ferramenta V2C apresenta diversas vantagens em relação a equivalência de tradução<br>
de linguagens, contudo V2C apresenta certas limitação na tradução do código VHDL, <span class='f1 c_94' id='c_94_1' href='#c_94_2' cs_f='.c_94' >em outras<br>
palavras</span>, a mesma não reconhece algumas estruturas especificas do VHDL. A ferramenta aceita<br>
apenas entradas e saídas do tipo: bit, std_ulogic, qsim_state, std_ulogic_vector<br>
e interger. Na parte de arquitetura, a ferramenta aceita uma gama maior de estruturas, tra-<br>
balhando com expressoões do tipo: signal, variable, integers, strings e caracteres.<br>
Em expreções condicionais os operandos são AND, OR, NOT &lt;=, =&gt;,=,&lt;,&gt; e &lt;&gt;. Aceita<br>
também a estrutura de process, além da estutura block. A estrutura process é limitada<br>
Chapter 4. MÉTODO PROPOSTO 44<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 . . .<br>
4 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
5 SIGNAL a n d _ p o r t : b i t ;<br>
6 SIGNAL o r _ p o r t : b i t ;<br>
7 SIGNAL x o r _ p o r t : b i t ;<br>
8 SIGNAL mux2x1 : b i t ;<br>
9 BEGIN<br>
10 PROCESS(A, B , B i n v e r t i d o , Op1 ) IS<br>
11 BEGIN<br>
12 ??PORTA AND<br>
13 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
14 ??__ESBMC_assume (A = ’ 1 ’ )<br>
15 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
16 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
17 ELSE<br>
18 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
19 END IF ;<br>
20 . . .<br>
21 ??MUX4X1<br>
22 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
23 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
24 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
25 R e s u l t a d o &lt;= o r _ p o r t ;<br>
26 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
27 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
28 ??@c2vhdl : ASSERT<br>
29 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
30 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
31 ??s e v e r i t y ERROR;<br>
32 ??@c2vhdl :END<br>
33 END IF ;<br>
34 END PROCESS ;<br>
35 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
apenas a: if-else, case e loops. <span class='f1 c_239' id='c_239_1' href='#c_239_2' cs_f='.c_239' >Como trabalho futuro</span>, neste trabalho tem-se buscado<br>
novas abordagens para ampliar o suporte a estruturas não suportadas pelo V2C.<br>
Na tradução é necessário substituir os operadores originais por seus equivalentes em<br>
linguagem C. A excessão são os operadore específicos que gerenciam <span class='f1 c_114' id='c_114_1' href='#c_114_2' cs_f='.c_114' >os valores de</span> bit, tais<br>
como concatenação ou manipulação de partes vertoriais, para os quais são necessários construir<br>
procedimentos especificos em C.<br>
Conforme mostrado na Figura 21, na tradução são gerados vários vetores para suporte<br>
a tradução dos sinais representados no VHDL, sendo eles chg[], old[] e new[]. O vetor<br>
old[] contém o valor do sinais do passo anteriore <span class='f1 c_242' id='c_242_1' href='#c_242_2' cs_f='.c_242' >a partir deste</span> vetor o valor a ser usado nos Confuso<br>
issocálculo é obtido. O vetor new[] representa os novos valores a serem calculados pelos antigose<br>
Qual?<br>
Chapter 4. MÉTODO PROPOSTO 45<br>
o vetor chg[] contém um or exclusivo entre o valor novo e antigo e <span class='f1 c_252' id='c_252_1' href='#c_252_2' cs_f='.c_252' >em caso de</span> alteração entre<br>
os valores é copiado o valor de new[] para old[].<br>
O texto acima está muito confuso, corrigi rapidamente<br>
No código C gerado, os vetores in_data[] e out_data[] contêm os sinais <span class='f1 c_308' id='c_308_1' href='#c_308_2' cs_f='.c_308' >de<br>
entrada e</span> saída, respectivamente. No caso de circuitos sequênciais, o valor do status é inserido<br>
no primeiro (índice 0). A funçãoentão lerá os valores in_data[] e escreverá <span class='f1 c_304' id='c_304_1' href='#c_304_2' cs_f='.c_304' >os resultados do</span> qual?<br>
processamento em out_data[]. Ao final da operações <span class='f1 c_114' id='c_114_1' href='#c_114_2' cs_f='.c_114' >os valores de</span> estado são passado para<br>
out_data[].<br>
Conforme especificado e seguindo os parametros da ferramenta, a mesma realiza a<br>
tradução, mantendo inalterado qualquer fragmento de código que esteja comentado, neste caso,<br>
as assertivas presentes no código VHDL permanecem inalteradas, sendo utilizadas na próxima<br>
etapa do método proposto.<br>
4.4 Instrumentação de código<br>
As assertivas após a tradução permanecem comentadas, sendo necessário prepara-lás, ou<br>
seja traduzi-las, para verificação posterior do código na linguagem em C. Com isso é necessário<br>
uma instrumentação do código para prover suporte as assertivas traduzidas para análise, conforme<br>
apresentado na Figura 16, etapa C.<br>
<span class='f1 c_144' id='c_144_1' href='#c_144_2' cs_f='.c_144' >Todas as etapas</span> da instrumentação são realizados sobre o código C já traduzido. O passo<br>
inicial da instrumentação é a adição da macros no inicio do código C com as definição das<br>
assertivas a serem utilizadas. Na Figura 22 são apresentados os macros utilizadas no código C. A<br>
Linha 1 da figura corresponde a mensagem de erro a ser apresentada e a Linha 2 corresponde<br>
ao modelo da assertiva e a chamanda da macro definida na Linha 1 <span class='f1 c_252' id='c_252_1' href='#c_252_2' cs_f='.c_252' >em caso de</span> falha. Estas<br>
definições para as assertivas também podem ser utilizadas no código C traduzidos sem o uso do<br>
ESBMC.<br>
Figure 22 – Macros das assertivas implementadas em linguagem C<br>
1 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r ,M, __FILE__ , __LINE__ , # # __VA_ARGS__ )<br>
2 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
Fonte: Própria.<br>
O passo seguinte é a identificação das assertivas comentadas <span class='f1 c_216' id='c_216_1' href='#c_216_2' cs_f='.c_216' >ao longo do</span> corpo do<br>
código traduzido, utilizando o exemplo da Figura 23. As assertivas são identificadas através<br>
das tags @c2vhdl:ASSERT e @c2vhdl:END e a busca é realizado através destas tags. Ao<br>
ser encontrado a tag @c2vhdl:ASSERT, é realizado um loop até que seja encontrada a tag<br>
Chapter 4. MÉTODO PROPOSTO 46<br>
@c2vhdl:END e com isso toda a assertiva inserida possa ser passada a função de busca das<br>
informações da assertiva contidas entre as tags apresentadas.<br>
<span class='f1 c_69' id='c_69_1' href='#c_69_2' cs_f='.c_69' >Com os dados</span> das assertivas obtidos é realizado a busca da condição, mensagem e<br>
severidade através dos comandos ??assert, ??report e ??severity respectivamente.<br>
Estas informações são encontradas através do uso e uma Regex no código e que são adicionadas<br>
ao código C seguindo o modelo definido na macro. Este processo é repetido até outra assertiva<br>
ser encontrada ou caso chegue ao fina do código C.<br>
Com a função __ESBMC_assume() ocorre processo semelhante ao das assertivas.<br>
Utilizando novamente uma regex que realiza a busca por esta função no código e é retirado o<br>
comentário da mesma, desta forma a mesma passa a esta acessivél para o ESBMC, visto que a<br>
declaração da mesma já segue o modelo padrão <span class='f1 c_225' id='c_225_1' href='#c_225_2' cs_f='.c_225' >a ser utilizado</span> pelo ESBMC.<br>
Durante a instrumentação de código também é realizado a entrada de sinais não de-<br>
terministicos para variaveis não inicializadas ou argumentos de funções do código C gerado<br>
da tradução, utilizando a função __VERIFIER_nondet_int(). Esta função é utilizada <span class='f1 c_204' id='c_204_1' href='#c_204_2' cs_f='.c_204' >em<br>
todas as</span> variaveis <span class='f1 c_308' id='c_308_1' href='#c_308_2' cs_f='.c_308' >de entrada e</span> também nos sinais criados <span class='f1 c_89' id='c_89_1' href='#c_89_2' cs_f='.c_89' >ao longo da</span> arquitetura. Desta forma,<br>
todas as variavéis necessárias são inicializadas para verificação.<br>
Explicar o funcionamento do nondet com o ESBMC<br>
<span class='f1 c_94' id='c_94_1' href='#c_94_2' cs_f='.c_94' >Em outras palavras</span>, na instrumentação de código é realizado a traduçao das assertivas do<br>
modelo utilizado no código VHDL para <span class='f1 c_170' id='c_170_1' href='#c_170_2' cs_f='.c_170' >para o modelo</span> utilizado em linguagem C, além como de<br>
outras funções que possam ser utilizados pelo VHDL. Ao final da instrumentação o código C<br>
fica disponivel para que possa ser dado como entrada para outras ferramentas de verificação de<br>
código e não apenas o ESBMC.<br>
4.5 Verificação de assertivas usando Model Checker<br>
O model checker adotado no desenvolvimento de método é o ESBMCna versão 3.0.0 referência<br>
e conforme explicado na subsection 2.2.3, esta ferramenta recebe como entrada um código C<br>
ou C++ e devido a isso foi escolhida neste projeto. Nesta seção será apresentado a etapa D do apresentar<br>
outras<br>
vanta-<br>
gens<br>
métod proposto na Figura 16.<br>
Para a verificação, a primeira etapa é a identificação das assertivas no código C analisado,<br>
para isso é utilizado uma opção do ESBMC (??show-claims), mais especificamente as<br>
assertivas instrumentadas no código C analisado. Cada assertiva é identificada através de uma<br>
numeração <span class='f1 c_195' id='c_195_1' href='#c_195_2' cs_f='.c_195' >de acordo com a</span> ordem de busca do código analisado. Cada assertiva encontrada é<br>
armazenada para que seja realizada uma análise individual de cada claim, ou seja, assertiva.<br>
Chapter 4. MÉTODO PROPOSTO 47<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas.<br>
1 VAR<br>
2 c o n t a d o r : i n t e i r o<br>
3 c l a i m : l i s t a<br>
4 c l a i m _ s t r i n g : s t r i n g<br>
5<br>
6 FUNCAO c a l l _ e s b m c : a r q u i v o<br>
7 c o n t a d o r &lt;?0<br>
8 INICIO<br>
9 s a i d a &lt;?f un ca o de g e r a c a o das c l a i m s p e l o ESBMC<br>
10 ENQUANTO c o n t a d o r &lt; s a i d a FACA<br>
11 c o n t a d o r +=2<br>
12 r e g e x p a r a p r o c u r a r c l a i m e numeracao da c l a i m<br>
13 SE e n c o n t r a r c l a i m ENTAO<br>
14 r e g e x p a r a p r o c u r a r a p a l a v r a " a s s e r t i o n "<br>
15 SE e n c o n t r a r a p a l a v r a " a s s e r t i o n " ENTAO<br>
16 c o n t a d o r +=1<br>
17 A d i c i o n a a numeracao da c l a i m na l i s t a<br>
18 FIM?SE<br>
19 FIM?SE<br>
20 FIM?ENQUANTO<br>
21 FIM?FUNCAO<br>
Fonte: Própria.<br>
Na Linha 9 da Figura 24 é apresentado a chamada da ferramenta ESBMC que ocorre e<br>
através da opção ??show-claims lista todas as claims presentes no texto, como apresentado<br>
na Figura 25. Como o ESBMC infere de forma automatica assertivas a serem verificadas no<br>
código. Visando isolar somente as assertivas instrumentadas pelo método proposto, juntamente<br>
com a opção –show-claims é utilizado as opções:<br>
• ??no-pointer-check: para não realizar a checagem de ponteiros no código;<br>
• ??no-div-by-zero-check: para não realizar a checagem de divisões por zero no<br>
código; e<br>
• ??no-bounds-check: para não realizar a checagem de array bounds no código.<br>
Chapter 4. MÉTODO PROPOSTO 48<br>
Figure 25 – Imagem de claims contendo assertivas.<br>
Fonte:Própria<br>
Após a listagem das claims com assertivas ser gerada, outra função, indicada na Figura 26,<br>
é chamada para verificação de cada claim individualmente. Para cada claim, ocorre a chamada do<br>
ESBMC, utilizando as opções ??no-pointer-check, ??no-div-by-zero-check e<br>
??no-bounds-check, juntamente com a opção ??unwind em que realiza o número de<br>
desdobramentos dos laços no código analisado.<br>
Contudo, dependendo da complexidade da assertiva, faz-se necessário aumentar o número<br>
de desdobramentos que, por padrão são dez, conforme análise experimentais. A função é chamada<br>
na Linha 11 da Figura 26 e após a analise da claim é realizado a busca do resultado e exibição<br>
caso seja uma propriedade violada.<br>
Desta forma o ESBMC realiza apenas a checagem necessária dentro da assertiva, evitando<br>
que outros parâmetros sejam verificados, sem a devida necessidade do mesmo. Ao final <span class='f1 c_210' id='c_210_1' href='#c_210_2' cs_f='.c_210' >de todos<br>
os</span> desdobramentos é apresentado o resultado, apresentado na Figura 27, sendo positiva (sem<br>
erros) ou negativa (com violação de propriedades), dependendo da assertiva e do código analisado.<br>
Este processo se repete até a lista de assertivas ser finalizada.<br>
Chapter 4. MÉTODO PROPOSTO 49<br>
Figure 26 – Pseudocódigo da função de análise das claims.<br>
1 VAR<br>
2 c o n t a d o r 1 : i n t e i r o<br>
3 c o n t a d o r 2 : i n t e i r o<br>
4 r e s u l t a d o : l i s t a<br>
5<br>
6 FUNCAO esbmc_c la ims : l i s t a , a r q u i v o<br>
7 c o n t a d o r 1 &lt;?0<br>
8 c o n t a d o r 2 &lt;?0<br>
9 busca p e l o nome da fu nc a o no a r q u i v o<br>
10 ENQUANTO c o n t a d o r &lt; l i s t a FACA<br>
11 s a i d a &lt;?Execu ta comando de a n a l i s e da c l a i m<br>
numerada na l i s t a<br>
12 ENQUANTO c o n t a d o r 2 &lt; s a i d a<br>
13 Regex busca se a p r o p r i e d a d e f o i v i o l a d a<br>
14 SE p r o p r i e d a d e f o i v i o l a d a ENTAO<br>
15 Pu la p a r a l i n h a da v i o l a ç ã o<br>
16 A d i c i o n a o e r r o ao r e s u l t a d o<br>
17 FIM?SE<br>
18 FIM?ENQUANTO<br>
19 FIM?ENQUANTO<br>
20 FIM?FUNCAO<br>
Fonte: Própria.<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta.<br>
Fonte:Própria<br>
Ajustar os códigos, alguns estao muito grandes e com trechos desnecessário, não foi<br>
citado o link do repo da ferramenta<br>
Chapter 4. MÉTODO PROPOSTO 50<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C.<br>
1 void u l a _ t c c ( i n t i n _ d a t a [ ] , i n t o u t _ d a t a [ ] )<br>
2 {<br>
3 i n t _ i _ =0;<br>
4 i n t _c on t_ ;<br>
5 enum s e g n a l e {A, B , B i n v e r t i d o , Op1 , Op2 , R e s u l t a d o , and_po r t , o r _ p o r t ,<br>
6 x o r _ p o r t , mux2x1 , _MAX_} ;<br>
7 i n t o l d [_MAX_ ] ;<br>
8 i n t new [_MAX_ ] ;<br>
9 i n t chg [_MAX_ ] ;<br>
10 new [A] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
11 new [B] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
12 new [ B i n v e r t i d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
13 new [ Op1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
14 new [ Op2 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
15 new [ R e s u l t a d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
16 new [ a n d _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
17 new [ o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
18 new [ x o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
19 new [ mux2x1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
20<br>
21 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
22 {<br>
23 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
24 }<br>
25 new [A] = i n _ d a t a [ 1 ] ;<br>
26 new [B] = i n _ d a t a [ 2 ] ;<br>
27 new [ B i n v e r t i d o ] = i n _ d a t a [ 3 ] ;<br>
28 new [ Op1 ] = i n _ d a t a [ 4 ] ;<br>
29 new [ Op2 ] = i n _ d a t a [ 5 ] ;<br>
30<br>
31 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
32 {<br>
33 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
34 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
35 }<br>
36<br>
37 do {<br>
38 _ co n t _ =0;<br>
39 /? S t a r <span class='f1 c_65' id='c_65_1' href='#c_65_2' cs_f='.c_65' >t o f</span> T r a n s l a t i o n ? /<br>
40<br>
41 /? p0 : ? /<br>
42 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
43 /?PORTA AND ? /<br>
44 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
45 \ \ __ESBMC_assume ( o l d [A] = 1) ;<br>
46 \ \ __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
47 new [ a n d _ p o r t ] = 1 ;<br>
48 }<br>
49 e l s e {<br>
50 new [ a n d _ p o r t ] = 0 ;<br>
51 }<br>
52 /?PORTA OR ? /<br>
53 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
54 new [ a n d _ p o r t ] = 0 ;<br>
55 }<br>
56 e l s e {<br>
57 new [ a n d _ p o r t ] = 1 ;<br>
58 }<br>
59 /?PORTA XOR ? /<br>
60 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
61 new [ x o r _ p o r t ] = 0 ;<br>
62 }<br>
63 e l s e i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==1) ) {<br>
64 new [ x o r _ p o r t ] = 0 ;<br>
65 }<br>
66 e l s e {<br>
67 new [ x o r _ p o r t ] = 1 ;<br>
68 }<br>
69 /? INVERSOR ? /<br>
70 i f ( ( o l d [ B i n v e r t i d o ]==0) ) {<br>
71 i f ( chg [B ] ) {<br>
72 new [ mux2x1 ]= o l d [B ] ;<br>
73 }<br>
74 }<br>
75 e l s e {<br>
76 i f ( chg [B ] ) {<br>
77 new [ mux2x1 ]=~ o l d [B ] ;<br>
78 }<br>
79 }<br>
80 /?MUX4X1 ? /<br>
81 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
82 i f ( chg [ a n d _ p o r t ] ) {<br>
83 new [ R e s u l t a <span class='f1 c_62' id='c_62_1' href='#c_62_2' cs_f='.c_62' >d o ]= o</span> l d [ a n d _ p o r t ] ;<br>
84 \ \ @c2vhdl : ASSERT<br>
85 \ \ a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
86 \ \ r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
87 \ \ s e v e r i t y ERROR;<br>
88 \ \ @c2vhdl :END<br>
89 }<br>
90 }<br>
91 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
92 i f ( chg [ o r _ p o r t ] ) {<br>
93 new [ R e s u l t a <span class='f1 c_62' id='c_62_1' href='#c_62_2' cs_f='.c_62' >d o ]= o</span> l d [ o r _ p o r t ] ;<br>
94 }<br>
95 }<br>
96 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
97 i f ( chg [ x o r _ p o r t ] ) {<br>
98 new [ R e s u l t a <span class='f1 c_62' id='c_62_1' href='#c_62_2' cs_f='.c_62' >d o ]= o</span> l d [ x o r _ p o r t ] ;<br>
99 }<br>
100 }<br>
101 }<br>
102<br>
103 /? End o f T r a n s l a t i o n ? /<br>
104 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
105 {<br>
106 i f ( new [ _ i _ ] ! = o l d [ _ i _ ] ) _ con t_ =1;<br>
107 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
108 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
109 }<br>
110 } whi le ( _c on t_ ) ;<br>
111<br>
112 new [A] &= 0X01 ;<br>
113 new [B] &= 0X01 ;<br>
114 new [ B i n v e r t i d o ] &= 0X01 ;<br>
115 new [ Op1 ] &= 0X01 ;<br>
116 new [ Op2 ] &= 0X01 ;<br>
117 new [ R e s u l t a d o ] &= 0X01 ;<br>
118 new [ a n d _ p o r t ] &= 0X01 ;<br>
119 new [ o r _ p o r t ] &= 0X01 ;<br>
120 new [ x o r _ p o r t ] &= 0X01 ;<br>
121 new [ mux2x1 ] &= 0X01 ;<br>
122<br>
123 o u t _ d a t a [ 0 ] = 0 ; _ i _ =0;<br>
124 o u t _ d a t a [ 0 ] | = new [A] &lt;&lt; _ i _ ; _ i _ +=1;<br>
125 o u t _ d a t a [ 0 ] | = new [B] &lt;&lt; _ i _ ; _ i _ +=1;<br>
126 o u t _ d a t a [ 0 ] | = new [ B i n v e r t i d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
127 o u t _ d a t a [ 0 ] | = new [ Op1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
128 o u t _ d a t a [ 0 ] | = new [ Op2 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
129 o u t _ d a t a [ 0 ] | = new [ R e s u l t a d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
130 o u t _ d a t a [ 0 ] | = new [ a n d _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
131 o u t _ d a t a [ 0 ] | = new [ o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
132 o u t _ d a t a [ 0 ] | = new [ x o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
133 o u t _ d a t a [ 0 ] | = new [ mux2x1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
134<br>
135 o u t _ d a t a [ 1 ] = new [ R e s u l t a d o ] ;<br>
136 }<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 51<br>
Figure 23 – Código com assertivas traduzida para linguagem C<br>
1 # inc lude &lt; s t d i o . h&gt;<br>
2 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r , M , __FILE__ , __LINE__ , ##<br>
__VA_ARGS__ ) / / Update t o p r i n t t h e t r a c e<br>
3 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
4<br>
5 . . .<br>
6<br>
7 do {<br>
8 _co n t _ =0;<br>
9 /? S t a r <span class='f1 c_65' id='c_65_1' href='#c_65_2' cs_f='.c_65' >t o f</span> T r a n s l a t i o n ? /<br>
10 chg [A] = __VERIFIER_nondet_int ( ) ;<br>
11 chg [B] = __VERIFIER_nondet_int ( ) ;<br>
12 chg [ B i n v e r t i d o ] = __VERIFIER_nondet_int ( ) ;<br>
13 chg [ Op1 ] = __VERIFIER_nondet_int ( ) ;<br>
14 chg [ a n d _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
15 chg [ R e s u l t a d o ] = __VERIFIER_nondet_int ( ) ;<br>
16 chg [ o r _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
17 chg [ mux2x1 ] = __VERIFIER_nondet_int ( ) ;<br>
18<br>
19 /? p0 : ? /<br>
20 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
21 /?PORTA AND ? /<br>
22 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
23 __ESBMC_assume ( o l d [A] = 1) ;<br>
24 __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
25 new [ a n d _ p o r t ] = 1 ;<br>
26 }<br>
27 e l s e {<br>
28 new [ a n d _ p o r t ] = 0 ;<br>
29 }<br>
30<br>
31 . . .<br>
32<br>
33 /?MUX4X1 ? /<br>
34 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
35 i f ( chg [ a n d _ p o r t ] ) {<br>
36 new [ R e s u l t a <span class='f1 c_62' id='c_62_1' href='#c_62_2' cs_f='.c_62' >d o ]= o</span> l d [ a n d _ p o r t ] ;<br>
37 __MY_asser t ( new [ R e s u l t a <span class='f1 c_62' id='c_62_1' href='#c_62_2' cs_f='.c_62' >d o ] == 1 , "O r</span> e s u l t a d o é d i f e r e n t e de 0 " ) ;<br>
38 }<br>
39 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
40 i f ( chg [ o r _ p o r t ] ) {<br>
41 new [ R e s u l t a <span class='f1 c_62' id='c_62_1' href='#c_62_2' cs_f='.c_62' >d o ]= o</span> l d [ o r _ p o r t ] ;<br>
42 }<br>
43 }<br>
44 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
45 i f ( chg [ x o r _ p o r t ] ) {<br>
46 new [ R e s u l t a <span class='f1 c_62' id='c_62_1' href='#c_62_2' cs_f='.c_62' >d o ]= o</span> l d [ x o r _ p o r t ] ;<br>
47 }<br>
48 }<br>
49 }<br>
50<br>
51 /? End o f T r a n s l a t i o n ? /<br>
52 . . .<br>
Fonte: Própria.<br>
52<br>
5 CRONOGRAMA<br>
53<br>
6 CONSIDERAÇÕES PARCIAIS E<br>
<span class='f1 c_50' id='c_50_1' href='#c_50_2' cs_f='.c_50' >TRABALHOS FUTUROS<br>
O trabalho</span> aborda <span class='f1 c_202' id='c_202_1' href='#c_202_2' cs_f='.c_202' >o desenvolvimento de um</span> método para análise de circuitos lógicos de-<br>
scrito em VHDL através da aplicação de técnica de transformação de código e a técnica Bounded<br>
Model Cheking. Este método <span class='f1 c_78' id='c_78_1' href='#c_78_2' cs_f='.c_78' >tem como objetivo</span> de explorar os estados alcanç alcançáveis no<br>
circuito, e dessa forma identificar <span class='f1 c_295' id='c_295_1' href='#c_295_2' cs_f='.c_295' >erros que possam</span> resutar em mal funcionamento do sistema.<br>
Entre as dificuldade encontradas, a principal esta ligada <span class='f1 c_319' id='c_319_1' href='#c_319_2' cs_f='.c_319' >a etapa de</span> tradução de código.<br>
Devido a ferramenta utilizada inicialmente conter diversas limitações, a mesma diminui a eficácia<br>
da ferramenta, pois <span class='f1 c_24' id='c_24_1' href='#c_24_2' cs_f='.c_24' >a quantidade de</span> estruturas <span class='f1 c_232' id='c_232_1' href='#c_232_2' cs_f='.c_232' >que podem ser</span> utilizadas é limitada e com isso<br>
limitando também <span class='f1 c_230' id='c_230_1' href='#c_230_2' cs_f='.c_230' >o processo de</span> criação de protótipos.<br>
Os trabalhos futuros é necessário buscar uma nova ferramenta ou método de tradução<br>
que tenha uma gama maior de tradução, seja em estruturas ou palavras reservadas,deste forma<br>
o método desenvlvido torna-se mais eficiente e gerando uma menor intervenção do usuário no<br>
código VHDL. A melhoria na tradução de código também beneficia ageração das assertivas<br>
automáticamente, pois <span class='f1 c_21' id='c_21_1' href='#c_21_2' cs_f='.c_21' >com uma gama</span> maior de estruturas suportadas, mais assertivas podem ser<br>
geradas.<br>
Além disso a geração automática das assertivas é Outro ponto abordado, já sitado anterior-<br>
mente, é a geração automática das assertivas, visto que na estapa atual ainda nõ foi implementado.<br>
Este recuros visa da liberdade ao desenvolvedor promovendo de maneira automática os teste<br>
sobre o código, não necessitando que uma intervenção, tornando a inserção manual apenas em<br>
casos especificos de testes.<br>
54<br>
BIBLIOGRAPHY<br>
ABE, J. Introducao a Logica Para a Ciencia Da Computacao. Arte & Ciência, 2002. ISBN<br>
9788574730455. Disponível em: &lt;https://books.google.com.br/books?id=AgBJdjoNPwUC&gt;.<br>
ACM. 2018. Acessado em: 01 de março de 2018. Disponível em: &lt;http://dl.acm.org/&gt;.<br>
AHO, A. V.; SETHI, R.; ULLMAN, J. D. Compilers: principles, techniques, and tools. [S.l.]:<br>
Addison-wesley Reading, 2007. v. 2.<br>
ALLEN, F. E. Control flow analysis. In: ACM. ACM Sigplan Notices. [S.l.], 1970. v. 5, n. 7, p.<br>
1–19.<br>
BAIER, C.; KATOEN, J.-P.; LARSEN, K. G. Principles of model checking. [S.l.]: MIT press,<br>
2008.<br>
BARA, A. et al. Formal verification of timed vhdl programs. In: IET. FDL. [S.l.], 2010. p.<br>
80–85.<br>
BASILI, V. R.; CALDIERA, G.; ROMBACH, H. D. Experience factory. Encyclopedia of<br>
software engineering, Wiley Online Library, 1994.<br>
BENSALEM, S.; LAKHNECH, Y. Automatic generation of invariants. Formal Methods in<br>
System Design, Springer, v. 15, n. 1, p. 75–92, 1999.<br>
BIERE, A. The aiger and-inverter graph (aig) format. Available at http://fmv.jku.at/aiger, 2016.<br>
BIOLCHINI, J. et al. Systematic review in software engineering. System Engineering and<br>
<span class='f1 c_103' id='c_103_1' href='#c_103_2' cs_f='.c_103' >Computer Science Department</span> COPPE/UFRJ, Technical Report ES, v. 679, n. 05, p. 45, 2005.<br>
BOULE, M.; ZILIC, Z. Incorporating efficient assertion checkers into hardware emulation. In:<br>
IEEE. Computer Design: VLSI in Computers and Processors, 2005. ICCD 2005. <span class='f1 c_40' id='c_40_1' href='#c_40_2' cs_f='.c_40' >Proceedings.<br>
2005 IEEE International Conference on</span>. [S.l.], 2005. p. 221–228.<br>
BOULE, M.; ZILIC, Z. Efficient automata-based assertion-checker synthesis of seres for<br>
hardware emulation. In: IEEE COMPUTER SOCIETY. <span class='f1 c_7' id='c_7_1' href='#c_7_2' cs_f='.c_7' >Proceedings of the</span> 2007 Asia and South<br>
Pacific Design Automation Conference. [S.l.], 2007. p. 324–329.<br>
BRAYTON, R.; MISHCHENKO, A. Abc: An academic industrial-strength verification tool. In:<br>
SPRINGER. Computer Aided Verification. [S.l.], 2010. p. 24–40.<br>
B.V. 2018. Acessado em 1 de março de 2018. Disponível em: &lt;http://www.sciencedirect.com/&gt;.<br>
CABODI, G. et al. Hardware model checking competition 2014: an analysis and comparison of<br>
solvers and benchmarks. Journal on Satisfiability, Boolean Modeling and Computation, v. 9, p.<br>
135–172, 2016.<br>
CAPPELATTI, D. Praticando VHDL. Editora Feevale, 2010. ISBN 9788577171200. Disponível<br>
em: &lt;https://books.google.com.br/books?id=z4\_CYog\_UskC&gt;.<br>
Bibliography 55<br>
CHRISTEN, E.; BAKALAR, K. Vhdl-ams-a hardware description language for analog and<br>
mixed-signal applications. <span class='f1 c_245' id='c_245_1' href='#c_245_2' cs_f='.c_245' >IEEE Transactions on</span> Circuits and Systems II: Analog and <span class='f1 c_113' id='c_113_1' href='#c_113_2' cs_f='.c_113' >Digital<br>
Signal Processing</span>, IEEE, v. 46, n. 10, p. 1263–1272, 1999.<br>
CHU, P. P. RTL hardware design using VHDL: coding for efficiency, portability, and scalability.<br>
[S.l.]: John Wiley & Sons, 2006.<br>
CLARKE, E. et al. Verification of hybrid systems based on counterexample-guided abstraction<br>
refinement. In: SPRINGER. TACAS. [S.l.], 2003. v. 3, p. 192–207.<br>
CLARKE, E. M. The birth of model checking. In: 25 Years of Model Checking. [S.l.]: Springer,<br>
2008. p. 1–26.<br>
CLARKE, E. M.; GRUMBERG, O.; LONG, D. E. Model checking and abstraction. ACM<br>
transactions on Programming Languages and Systems (TOPLAS), ACM, v. 16, n. 5, p.<br>
1512–1542, 1994.<br>
CORDEIRO, L.; FISCHER, B.; MARQUES-SILVA, J. Smt-based bounded model checking for<br>
embedded ansi-c software. <span class='f1 c_245' id='c_245_1' href='#c_245_2' cs_f='.c_245' >IEEE Transactions on</span> Software Engineering, IEEE, v. 38, n. 4, p.<br>
957–974, 2012.<br>
COUSOT, P.; COUSOT, R. A gentle introduction to formal verification of computer systems by<br>
abstract interpretation. [S.l.]: IOS Press, 2010.<br>
DAHAN, A. et al. Combining system level modeling with assertion based verification. In: Sixth<br>
<span class='f1 c_311' id='c_311_1' href='#c_311_2' cs_f='.c_311' >international symposium on</span> quality electronic design (isqed’05). [S.l.: s.n.], 2005. p. 310–315.<br>
ISSN 1948-3287.<br>
D’SILVA, V.; KROENING, D.; WEISSENBACHER, G. A survey of automated techniques<br>
for formal software verification. <span class='f1 c_245' id='c_245_1' href='#c_245_2' cs_f='.c_245' >IEEE Transactions on</span> Computer-Aided Design of Integrated<br>
Circuits and Systems, IEEE, v. 27, n. 7, p. 1165–1178, 2008.<br>
ELSEVIER. 2017. Acessado em: 01 março 2018. Disponível<br>
em: &lt;https://www.elsevier.com/__data/assets/pdf_file/0007/69451/<br>
0597-Scopus-Content-Coverage-Guide-US-LETTER-v4-HI-singles-no-ticks.pdf&gt;.<br>
G1. Acidente foi provocado por falha em circuito eletrônico, diz se-<br>
cretário. 2012. Disponível em: &lt;http://g1.globo.com/sao-paulo/noticia/2012/05/<br>
acidente-foi-provocado-por-falha-em-circuito-eletronico-diz-secretario.html&gt;.<br>
GUGLIELMO, G. D. et al. On the use of assertions for embedded-software dynamic verification.<br>
In: IEEE. Design and Diagnostics of Electronic Circuits & Systems (DDECS), 2012 <span class='f1 c_110' id='c_110_1' href='#c_110_2' cs_f='.c_110' >IEEE 15th<br>
International Symposium on</span>. [S.l.], 2012. p. 330–335.<br>
GUPTA, A. Formal hardware verification methods: A survey. In: SPRINGER. Computer-Aided<br>
Verification. [S.l.], 1992. p. 5–92.<br>
HALDER, A.; VENKATESWARLU, A. A study of petri nets modeling analysis and simulation.<br>
Department of Aerospace Engineering <span class='f1 c_95' id='c_95_1' href='#c_95_2' cs_f='.c_95' >Indian Institute of Technology</span> Kharagpur, India, 2006.<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Interpolation and symbol elimination in vampire.<br>
Automated Reasoning, Springer, p. 188–195, 2010.<br>
Bibliography 56<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Case studies on invariant generation using a<br>
saturation theorem prover. Advances in Artificial Intelligence, Springer, p. 1–15, 2011.<br>
IDOETA, I. V.; CAPUANO, F. G. Elementos de eletrônica digital. [S.l.]: Livros Erica, 1982.<br>
IEC/IEEE International Standard - Behavioural languages - Part 1-1: VHDL Language<br>
Reference Manual. IEC 61691-1-1:2011(E) IEEE Std 1076-2008, p. 1–648, May 2011.<br>
IEEE. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http://ieeexplore.ieee.org/<br>
Xplore/home.jsp&gt;.<br>
IEEE Standard for Property Specification Language (PSL). IEEE Std 1850-2010 (Revision of<br>
IEEE Std 1850-2005), p. 1–182, April 2010.<br>
IEEE Standard for Verilog Hardware Description Language. IEEE Std 1364-2005 (Revision of<br>
IEEE Std 1364-2001), p. 1–560, 2006.<br>
<span class='f1 c_183' id='c_183_1' href='#c_183_2' cs_f='.c_183' >KITCHENHAM, B. Procedures for performing systematic reviews</span>. Keele, UK, Keele University,<br>
v. 33, n. 2004, p. 1–26, 2004.<br>
KITCHENHAM, B. et al. Systematic literature reviews in software engineering–a systematic<br>
literature review. Information and software technology, Elsevier, v. 51, n. 1, p. 7–15, 2009.<br>
KNOOP, J.; RÜTHING, O.; STEFFEN, B. Partial dead code elimination. [S.l.]: ACM, 1994.<br>
v. 29.<br>
KOSCIANSKI, A.; SOARES, M. dos S. Qualidade de Software - 2a Edição: Aprenda as<br>
metodologias e técnicas mais modernas <span class='f1 c_29' id='c_29_1' href='#c_29_2' cs_f='.c_29' >para o desenvolvimento de</span> software. Novatec,<br>
2007. ISBN 9788575221129. Disponível em: &lt;https://books.google.com.br/books?id=<br>
O9aWoUq6L88C&gt;.<br>
KROPF, T. Introduction to Formal Hardware Verification. Springer Berlin Heidelberg,<br>
2013. ISBN 9783662038093. Disponível em: &lt;https://books.google.com.br/books?id=<br>
7ImrCAAAQBAJ&gt;.<br>
MAFRA, S. N.; TRAVASSOS, G. H. Estudos primarios e secundarios apoiando a busca por<br>
evidencia em engenharia de software. Relatorio Tecnico, RT-ES, v. 687, n. 06, 2006.<br>
MUKHERJEE, R. et al. Unbounded safety verification for hardware using software analyzers.<br>
In: EDA CONSORTIUM. <span class='f1 c_7' id='c_7_1' href='#c_7_2' cs_f='.c_7' >Proceedings of the</span> 2016 Conference on Design, Automation & Test in<br>
Europe. [S.l.], 2016. p. 1152–1155.<br>
MUKHERJEE, R.; TAUTSCHNIG, M.; KROENING, D. v2c–a verilog to c translator. In:<br>
SPRINGER. <span class='f1 c_4' id='c_4_1' href='#c_4_2' cs_f='.c_4' >International Conference on</span> Tools and Algorithms for the Construction and<br>
Analysis of Systems. [S.l.], 2016. p. 580–586.<br>
MURATA, T. Petri nets: Properties, analysis and applications. <span class='f1 c_7' id='c_7_1' href='#c_7_2' cs_f='.c_7' >Proceedings of the IEEE</span>, IEEE,<br>
v. 77, n. 4, p. 541–580, 1989.<br>
RAMESH, U. B. K.; SENTILLES, S.; CRNKOVIC, I. Energy management in embedded<br>
systems: Towards a taxonomy. In: IEEE PRESS. <span class='f1 c_7' id='c_7_1' href='#c_7_2' cs_f='.c_7' >Proceedings of the</span> First International<br>
Workshop on Green and Sustainable Software. [S.l.], 2012. p. 41–44.<br>
ROCHA, H. et al. Exploiting safety properties in bounded model checking for test cases<br>
generation of c programs. 2010.<br>
Bibliography 57<br>
ROCHA, H. et al. Model checking embedded c software using k-induction and invariants<br>
(extended version). arXiv preprint arXiv:1509.02471, 2015.<br>
ROCHA, H. O. et al. Verificacao <span class='f1 c_174' id='c_174_1' href='#c_174_2' cs_f='.c_174' >de sistemas de</span> software baseada em transformacoes de codigo<br>
usando bounded model checking. <span class='f1 c_44' id='c_44_1' href='#c_44_2' cs_f='.c_44' >Universidade Federal do Amazonas</span>, 2015.<br>
SARGENT, R. G. Verification and validation of simulation models. In: WINTER SIMULATION<br>
CONFERENCE. <span class='f1 c_7' id='c_7_1' href='#c_7_2' cs_f='.c_7' >Proceedings of the 37th conference on</span> Winter simulation. [S.l.], 2005. p.<br>
130–143.<br>
SEGER, C.-J. An introduction to formal hardware verification. [S.l.]: University of British<br>
Columbia, <span class='f1 c_125' id='c_125_1' href='#c_125_2' cs_f='.c_125' >Department of Computer Science</span>, 1992.<br>
SOMMERVILLE, I. Engenharia de software. PEARSON BRASIL, 2011. ISBN 9788579361081.<br>
Disponível em: &lt;https://books.google.com.br/books?id=H4u5ygAACAAJ&gt;.<br>
SONS, J. W. . 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http:<br>
//onlinelibrary.wiley.com/&gt;.<br>
SOUZA, J. Lógica para Ciência da Computação. Elsevier Brasil, 2017. ISBN 9788535278255.<br>
Disponível em: &lt;https://books.google.com.br/books?id=Ds2sCQAAQBAJ&gt;.<br>
SPRINGER. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;https:<br>
//link.springer.com/&gt;.<br>
SRIKANT, Y.; SHANKAR, P. The Compiler Design Handbook: Optimizations and<br>
Machine Code Generation. CRC Press, 2002. ISBN 9781420040579. Disponível em:<br>
&lt;https://books.google.com.br/books?id=0K\_jIsgyNpoC&gt;.<br>
THOMAS, D.; MOORBY, P. The Verilog R© Hardware Description Language. Springer<br>
US, 2008. ISBN 9780387853444. Disponível em: &lt;https://books.google.com.br/books?id=<br>
DxQGrz7q-SwC&gt;.<br>
TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L. Sistemas digitais: princípios e aplicações. [S.l.]:<br>
Prentice Hall, 2003. v. 8.<br>
TRAVASSOS, G. H. et al. An environment to support large scale experimentation in software<br>
engineering. In: IEEE. Engineering of Complex Computer Systems, 2008. ICECCS 2008. 13<span class='f1 c_137' id='c_137_1' href='#c_137_2' cs_f='.c_137' >th<br>
IEEE International Conference on</span>. [S.l.], 2008. p</div>
<!-- DIVISOR_DIV_CANDIDATE -->

<div class='divisor divisor-texto' id="cand__file8"><hr class='text-separator'><br>Input file: <a href='#'>main.pdf</a> (12773 chunks)<br>File found: <a href='https://books.google.com/' target='_blank'>https://books.google.com/</a> (40 chunks)<br><br>Chunks in common: 0<br>Similarity: 0%<br><br><div class='textInfo'>The following is the content of the document <br>&nbsp;"<b>main.pdf</b>". <br>The terms in red were found in the document <br>&nbsp;"<b>https://books.google.com/</b>".<br><hr class='text-separator'></div>  UNIVERSIDADE FEDERAL DE RORAIMA<br>
PRÓ-REITORIA DE ENSINO E EXTENSÃO<br>
DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código<br>
com Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau<br>
de Bacharel em Ciência da Computação.<br>
Orientador: Dr. Herbert Oliveira Rocha<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau de<br>
Bacharel em Ciência da Computação.<br>
Defendido em 06 de março de 2017 e<br>
aprovado pela seguinte banca examinadora:<br>
Prof. Dr. Herbert Oliveira Rocha<br>
Orientador / Curso de Ciência da Computação -<br>
UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Fazer dedicatória<br>
ACKNOWLEDGEMENTS<br>
Fazer agradecimentos!!<br>
Procurar frase massa!!<br>
ABSTRACT<br>
Fazer resumo!!<br>
Palavras-chaves: ??<br>
ABSTRACT<br>
Fazer Abstract!!<br>
Key-words: ??<br>
LISTA DE FIGURAS<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog. . . . . . . . . . . . . . . . 15<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL. . . . . . . . . . . . . . . . . 16<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade. . . . . . . . . . . . . . . 17<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL. . . . . . . . . . . . . . . . 17<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1. . . . . . . . . . 18<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas. . . . . . . . . 18<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas. . . . . . . . . . 19<br>
Figure 8 – Arvore de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
Figure 9 – Rede de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL. . . . . . . . . . . . . . . . . 27<br>
Figure 11 – Trecho de código em VHDL representando porta AND. . . . . . . . . . . . 28<br>
Figure 12 – Trecho de código traduzido para linguagem C. . . . . . . . . . . . . . . . . 29<br>
Figure 13 – Exemplo de bloco basico de código. . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 14 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 15 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 31<br>
Figure 16 – Ciclo da ferramenta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR. . . . . . . 41<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR. . . . . . . . . . . . . . 42<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume(). . . . . . . . . . . 43<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19. . . . . . . . . . . . . . . 44<br>
Figure 22 – Macros das assertivas implementadas em linguagem C . . . . . . . . . . . . 45<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas. . . . . . . 47<br>
Figure 25 – Imagem de claims contendo assertivas. . . . . . . . . . . . . . . . . . . . . 48<br>
Figure 26 – Pseudocódigo da função de análise das claims. . . . . . . . . . . . . . . . . 49<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta. . . . . . . . . . . . . . 49<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C. . . . . . . . . . . . . 50<br>
Figure 23 – Código com assertivas traduzida para linguagem C . . . . . . . . . . . . . . 51<br>
LISTA DE TABELAS<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM . . . . . . . . . . . . . . . 33<br>
SUMÁRIO<br>
1 INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11<br>
1.1 Definição do problema . . . . . . . . . . . . . . . . . . . . . . . . . . . 12<br>
1.2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13<br>
1.3 Organização do trabalho . . . . . . . . . . . . . . . . . . . . . . . . . 14<br>
2 CONCEITOS E DEFINIÇÕES . . . . . . . . . . . . . . . . . . . . . . 15<br>
2.1 Linguagens de descrição de hardware . . . . . . . . . . . . . . . . . 15<br>
2.1.1 VHSIC Hardware Description Language - VHDL . . . . . . . . . . . . . 16<br>
2.1.2 Portas lógicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18<br>
2.2 Verificação de sistemas . . . . . . . . . . . . . . . . . . . . . . . . . . 19<br>
2.2.1 Diagrama de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.2 Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.3 Bounded Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . 21<br>
2.2.4 Redes de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22<br>
2.2.5 Verificação de hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
2.2.6 Verificação formal de software . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.7 Lógica proposicional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.8 Linguagem de especificação de propriedades . . . . . . . . . . . . . . 26<br>
2.2.9 Verificação baseada em assertivas . . . . . . . . . . . . . . . . . . . . 26<br>
2.2.10 Propriedades de segurança . . . . . . . . . . . . . . . . . . . . . . . . 27<br>
2.3 Técnicas de compiladores . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.1 Transformações de código . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2 Otimização de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2.1 Grafo Acliclico Direcional - GAD . . . . . . . . . . . . . . . . . . . . . . . . 29<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.3 Eliminção de código morto . . . . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.4 Análise do fluxo de dados . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
2.3.2.5 Gerador de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
3 TRABALHOS CORRELATOS . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1 Revisão sistemática . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1.1 Planejamento da Revisão Sistemática . . . . . . . . . . . . . . . . . . 33<br>
3.1.1.1 Procedimentos de Seleção e Critérios . . . . . . . . . . . . . . . . . . . . 35<br>
3.2 Revisão da literatura . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.1 V2c-A verilog to C translator . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.2 Unbounded safety verification for hardware using software analyzers . 37<br>
3.2.3 Formal verification of timed VHDL programs . . . . . . . . . . . . . . . 38<br>
3.2.4 On the use of assertions for embedded-software dynamic verification 38<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation . . 39<br>
4 MÉTODO PROPOSTO . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.1 Visão geral do método . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.2 Preprocessamento do VHDL e inserção de assertivas . . . . . . . 42<br>
4.3 Tradução de código VHDL para a linguagem C . . . . . . . . . . . . 43<br>
4.4 Instrumentação de código . . . . . . . . . . . . . . . . . . . . . . . . 45<br>
4.5 Verificação de assertivas usando Model Checker . . . . . . . . . . 46<br>
5 CRONOGRAMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52<br>
6 CONSIDERAÇÕES PARCIAIS E TRABALHOS FUTUROS . . . . . 53<br>
BIBLIOGRAPHY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54<br>
11<br>
1 INTRODUÇÃO<br>
A complexidade de sistemas computacionais cresce exponencialmente. Muitas compan- Exemplificar<br>
este<br>
cresci-<br>
mento.<br>
hias e organizações estão rotineiramente lidando com software que contém milhares de linhas<br>
de código, escritos por diferentes pessoas, que usam linguagens distintas, ferramentas, estilos e<br>
hardware projetados de diversas formas e combinações (HODER et al., 2011).<br>
No contexto de sistemas compostos de hardware e software, tem-se os sistemas embarca-<br>
dos (SE) que são dispositivos semicondutores com software integrados, os quais se conectam<br>
a outros dispositivos. Usualmente, o principal propósito dos SE é o controle e provimento de<br>
informações para uma função específica (RAMESH et al., 2012).<br>
Os SE são extremamente interativos com seu ambiente, operam geralmente em tempo real<br>
e estão disponíveis continuamente. No entanto, estes sistemas, por possuírem um curto espaço<br>
de tempo para a liberação do produto ao mercado, precisam ser desenvolvidos rapidamente e<br>
atingir um alto nível de qualidade, mas, devido a esta necessidade, os programadores podem<br>
cometer enganos durante a fase de desenvolvimento destes sistemas.<br>
Os SE têm se proliferado em partes consideráveis das atividades do nosso cotidiano,<br>
com a característica de possuir grande quantidade de complexidade e diversidade. Devido a esta<br>
complexidade, erros podem passar despercebidos, causando não apenas penalidades econômicas<br>
e/ou fracassos do produto no mercado, mas principalmente o risco de perda de vidas humanas<br>
(CABODI et al., 2016). Como, por exemplo, o acidente noticiado no (G1, 2012), no qual, de<br>
acordo com o secretário de transportes, uma falha na placa do circuito eletrônico responsável<br>
pelo controle de velocidade dos trens ocasionou a colisão entre duas composições na estação de<br>
metrô de São Paulo.<br>
Segundo ROCHA et al.2015b, para se obter um alto nível de qualidade no desenvolvi-<br>
mento dos sistemas de hardware e software, a execução desses sistemas deve ser controlada e da<br>
mesma forma deve-se buscar meios de garantir que as propriedades definidas sejam atingidas. Por<br>
exemplo, a partir do conhecimento prévio do modo de implementação de determinado hardware,<br>
é possível utilizá-lo de forma mais eficiente. Neste sentido, diversas estratégias de verificação e<br>
de teste estão sendo pesquisadas e aplicadas para garantir a qualidade do software e hardware<br>
(HODER et al., 2010; ROCHA et al., 2010; BRAYTON; MISHCHENKO, 2010; CORDEIRO et<br>
al., 2012; CABODI et al., 2016).<br>
Por este motivo, com o intuito de analisar e otimizar a descrição dos circuitos digitais,<br>
tem-se utilizado as linguagens de descrição de hardware (HDL). Estas se diferem das linguagens<br>
de programação por conseguirem gerar execuções não apenas sequenciais, como também con-<br>
correntes ou paralelas (CHU, 2006). Neste contexto, a VHSIC Hardware Description Language<br>
Chapter 1. INTRODUÇÃO 12<br>
(VHDL) é uma das linguagens de descrição de hardware mais utilizadas atualmente. A descrição<br>
em VHDL pode ser em vários níveis de abstração, sendo o mais alto o nível comportamen-<br>
tal que permite a descrição do circuito através de loops e processos, definido-o na forma de<br>
algoritmo. Como características das linguagens de descrição, o VHDL permite declarações se-<br>
quenciais ou concorrentes onde as declarações continuam ativas e sua ordem torna-se irrelevante<br>
(CAPPELATTI, 2010).<br>
Aliada à linguagem de descrição de hardware, a verificação formal de sistemas computa-<br>
cionais tem desempenhado um papel importante para assegurar a previsibilidade e a confiabili-<br>
dade na concepção de aplicações críticas. E, para isso, tem-se utilizado a técnica denominada<br>
model checking, que é baseada em formalismos matemáticos para provar propriedades de pro-<br>
gramas reativos (BENSALEM; LAKHNECH, 1999). Esta técnica gera uma busca exaustiva no<br>
espaço de estados do modelo para determinar se uma dada propriedade é válida ou não (BAIER<br>
et al., 2008), tendo como principal razão para o seu sucesso o funcionamento completamente<br>
automático, ou seja, sem qualquer intervenção do usuário.<br>
Visando contribuir com a verificação de sistemas embarcados no âmbito de sistemas<br>
computacionais, o contexto deste trabalho está situado no uso de metodologias e técnicas de<br>
verificação formal para programas escritos em VHDL (BIERE, 2016), focando principalmente<br>
no Bounded Model Checking (CORDEIRO et al., 2012; ROCHA et al., 2015a). Este trabalho está<br>
interessado especificamente na parte de: verificação de modelos de hardware descritos em níveis<br>
de circuitos de bits na linguagem VHDL, via transformações de código para gerar modelos (com<br>
assertivas) já suportados por model checkers, como o ESBMC (CORDEIRO et al., 2012).<br>
Dessa forma, o trabalho almeja analisar as propriedades de alcançabilidade para a<br>
identificação de localizações de erro, bem como, assertivas contendo propriedades de segurança.<br>
A propriedade de alcançabilidade ou propriedade do estado de erro é satisfatória (SAT), se um<br>
estado de erro é alcançável. Caso contrário, a propriedade é considerada insatisfatória (UNSAT).<br>
No caso SAT, o model checking também gera um rastreio da validação da propriedade (contra-<br>
exemplo), ou seja, uma sequência de estados que mostra como chegar ao erro a partir de um<br>
ponto inicial.<br>
1.1 Definição do problema<br>
O avanço da tecnologia, principalmente nas áreas de design e fabricação de eletrônicos,<br>
aumentou a importância do hardware nos dias atuais. Cada vez com mais funcionalidades<br>
integradas, aliada a velocidade e circuitos menores, faz com que a complexidade dos sistemas<br>
de hardware aumente. Entretanto, devido à complexidade cada vez maior, a detecção tardia<br>
de erros no sistema pode resultar em perda de produção, mas também custos associados ao<br>
desenvolvimento do sistema(GUPTA, 1992). Devido a isso, a verificação de hardware visa<br>
assegurar que o circuito atinja as especificações para o qual foi projetado, através de técnicas<br>
Chapter 1. INTRODUÇÃO 13<br>
formais ou dinâmicas (BOULE; ZILIC, 2007).<br>
Por esta razão, a utilização de métodos formais tornou-se uma abordagem atraente<br>
para superar as limitações inerentes à validação baseada em simulação. Portanto, a maioria<br>
das empresas de semicondutores têm investigado a sua aplicabilidade. Escolhas individuais de<br>
métodos, ferramentas e áreas de aplicação das empresas têm variado, assim como o seu nível<br>
de sucesso (CABODI et al., 2016). Com os recentes avanços na escalabilidade de automação<br>
dos model checkers e nas equivalências sequenciais de verificação, a maioria das empresas têm<br>
crescido ao contar com essas técnicas(CLARKE, 2008).<br>
O problema considerado neste trabalho é expresso na seguinte questão: Como comple-<br>
mentar e aprimorar a verificação de propriedades de segurança em circuitos lógicos, de tal<br>
forma que uma propriedade possa ser mapeada em um problema de alcançabilidade sim-<br>
bólica, ou seja, se é possível alcançar um estado específico (para uma dada propriedade) a<br>
partir do estado inicial?<br>
1.2 Objetivos<br>
O objetivo principal deste trabalho é projetar e avaliar um método para efetuar verificação<br>
de circuitos, de forma automática, descritos em VHDL com portas lógicas em nível de bit<br>
pela utilização de técnicas de transformação de códigos combinado com a técnica Bounded<br>
Model Checking para exploração de estados alcançáveis no circuito, visando identificar erros ou<br>
comportamentos indevidos ou inesperados que podem resultar no funcionamento incorreto de<br>
um dado sistema.<br>
Os objetivos específicos são:<br>
1. Propor um método para especificar pré e pós-condições de circuitos digitais em nível de<br>
portas lógicas descritos em VHDL;<br>
2. Analisar ferramentas de verificação de modelos que utilizam a técnica Bounded Model<br>
Checking;<br>
3. Especificar uma técnica de conversão de circuitos em linguagem de descrição de hardware<br>
VHDL para um modelo a ser verificado usando a técnica Bounded Model Checking;<br>
4. Desenvolver um método para identificação de estados de erros ou ocorrências indevidas,<br>
de um dado circuito analisado, em modelos de hardware descritos em nível de bit na<br>
linguagem de descrição VHDL.<br>
5. Validar a aplicação do método proposto sobre benchmarks públicos de programas em<br>
VHDL, a fim de examinar a sua eficácia e aplicabilidade.<br>
Chapter 1. INTRODUÇÃO 14<br>
1.3 Organização do trabalho<br>
A introdução deste trabalho apresentou: o contexto, definição do problema, e objetivos<br>
deste trabalho. Os próximos capítulos estão organizados da seguinte forma:<br>
No Capítulo 2 Conceitos e Definições, são apresentados os conceitos abordados neste<br>
trabalho, especificamente: Linguagens de descrição de hardware; Verificação e validação de<br>
sistemas; e Técnicas de compiladores.<br>
No Capítulo 3 Trabalhos Correlatos, serão apresentados o método de pesquisa bibli-<br>
ográfica utilizado, sendo ele a revisão sistemática, seguido do resultado encontrado com esta<br>
pesquisa e, por fim, a contribuição dos artigos utilizados no desenvolvimento do projeto.<br>
No Capítulo 4 Método Proposto, são descritas as etapas de execução do novo método<br>
proposto que consiste na transformação do código, instrumentação de assertivas e verificação de<br>
código utilizando um model checker.<br>
No Capítulo 5, será apresentado o cronograma de atividades a ser realizado na elaboração<br>
do método durante o desenvolvimento do projeto.<br>
E, por fim, no Capítulo 6 Considerações parciais e trabalhos futuros, serão apresentas<br>
as considerações parciais e as sugestões de trabalhos futuros que podem ser desenvolvidos.<br>
15<br>
2 CONCEITOS E DEFINIÇÕES<br>
Este capítulo tem apresenta os principais conceitos e definições abordados neste tra-<br>
balho, tais como: Linguagens de descrição de hardware, Verificação de sistemas e Técnicas de<br>
Compiladores.<br>
2.1 Linguagens de descrição de hardware<br>
As linguagens de descrição de hardware (HDL) foram desenvolvidas com o intuito de<br>
auxiliar a criação de circuitos lógicos com grande número de elementos e com uma gama de<br>
abstrações lógicas e eletrônicas (THOMAS; MOORBY, 2008). Entre os exemplos, podemos<br>
citar: VDHL (IEC/IEEE. . . , 2011), Verilog (IEEE. . . , 2006) e SystemC (??).<br>
Segundo CHRISTEN; BAKALAR,1999, linguagens de descrição de hardware são lingua-<br>
gens de programação utilizadas com o intuito de descrever o comportamento de um determinado<br>
circuito, técnica conhecida como modelagem. Os modelos descritos em HDL são utilizados<br>
como entrada para um simulador, onde o mesmo pode ter seu comportamento analisado.<br>
As HDL’s trazem consigo diversas vantagens, entre elas códigos independentes de tec-<br>
nologia e fabricante, podendo ser portáteis e reutilizáveis (CAPPELATTI, 2010). As linguagens<br>
mais modernas, tais como VHDL e Verilog, possuem suporte tanto a descrição do circuito pro-<br>
priamente dito, quanto ao comportamento que o mesmo deve exercer (CHRISTEN; BAKALAR,<br>
1999).<br>
A Verilog, como já citado, é uma linguagem de descrição de hardware que fornece<br>
diversos níveis de abstração para desenvolvimento de sistemas digitais(THOMAS; MOORBY,<br>
2008). A linguagem foi desenvolvida para ser simples e efetiva nos diversos níveis de abstração<br>
incluindo o suporte ao desenvolvimento, verificação, síntese e testes de software (IEEE. . . , 2006).<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog.<br>
1 p r i m i t i v e m u l t i p l e x e r ( mux , c o n t r o l , dataA , da taB ) ;<br>
2 o u t p u t mux ;<br>
3 i n p u t c o n t r o l , dataA , da taB ;<br>
4 e n d p r i m i t i v e<br>
Fonte: Adaptado de (IEEE. . . , 2006).<br>
Na Figura 1 apresenta um exemplo de multiplexador descrito em Verilog utilizando a<br>
estrutura de modelagem, chamada UDP que permite a criação de novos primitivas para serem<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 16<br>
utilizada. Apresenta uma saída apenas(mux) e três entradas sendo uma de controle(control) e<br>
duas de dados(dataA e dataB).<br>
A VHDL é uma linguagem de descrição de hardware amplamente utilizada, concebida<br>
na década de 80, devido uma necessidade do Departamento de Defesa dos Estados Unidos<br>
da América (CAPPELATTI, 2010). Assim como a Verilog, esta linguagem também suporta o<br>
desenvolvimento, a verificação, a síntese, e os testes de hardware (IEC/IEEE. . . , 2011).<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL.<br>
1 l i b r a r y IEEE ;<br>
2 use IEEE . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 use IEEE . s t d _ l o g i c _ u n s i g n e d . a l l ;<br>
4 e n t i t y mux2x1 i s<br>
5 p o r t ( s e l : i n STD_LOGIC ;<br>
6 a , b : i n STD_LOGIC ;<br>
7 y : o u t STD_LOGIC ) ;<br>
8 end mux2x1 ;<br>
9<br>
10 a r c h i t e c t u r e d a t a f l o w of mux2x1 i s b e g i n<br>
11 y &lt;= ( a AND NOT s e l ) OR ( b AND s e l ) ;<br>
12 end d a t a f l o w .<br>
Fonte: (CAPPELATTI, 2010).<br>
Na Figura 2 está descrito um multiplexador de duas entradas descrito em VHDL, apre-<br>
sentando na parte inicial as bibliotecas e na entidade(entity) a declaração das variáveis utilizadas.<br>
Na arquitetura(architecture) apresenta o funcionamento do multiplexador, relacionando en-<br>
tradas e saídas conforme tenham sido declarados. Este conceitos serão melhor apresentados na<br>
subsection 2.1.1.<br>
Conforme apresentado nas Figura 1 e Figura 2, ambas as linguagens apresentam difer-<br>
enças no modelos de declaração e utilização para descrição de hardware. Para este trabalho foi<br>
escolhido a VHDL devido a linguagem apresentar um melhor escopo para análise, facilitando o<br>
trabalho de análise proposto para este projeto.<br>
2.1.1 VHSIC Hardware Description Language - VHDL<br>
Revisar textos e verificar a necessidade de mais exemplo<br>
VHDL é uma linguagem de descrição de hardware destinada a ser utilizada em todas<br>
as etapas da criação de sistemas eletrônicos, sendo elas: desenvolvimento; verificação; síntese;<br>
e, teste de circuitos (IEC/IEEE. . . , 2011). Segundo (CAPPELATTI, 2010), a VHDL apresenta<br>
três principais pilares: abstração, que consiste na descrição com diferentes níveis de detalhes;<br>
modularidade, que permite a divisão do projeto em vários blocos ou módulos para posterior<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 17<br>
interconexão; e hierarquia, permite que módulos possam ser compostos por submódulos e, os<br>
mesmos tenham níveis de abstração diferentes, dependendo da necessidade do projeto. Devido a<br>
esta versatilidade que a linguagem VHDL foi selecionada para o trabalho proposto.<br>
Segundo IEC/IEEE. . . ,2011, é necessário um padrão para formatação da descrição em<br>
VHDL: Entity (Pinos de entrada/saída) e Architecture (Arquitetura). A Entity ou entidade repre-<br>
senta o bloco onde são declaradas as entradas e as saídas do circuito utilizadas em todo o sistema,<br>
conforme apresentado na Figura 3. A Architecture ou arquitetura, apresentado na Figura 4, define<br>
a relação entre entradas e saídas declaradas na entidade, podendo tais especificações serem<br>
completas ou parciais. Assim como em outras linguagens, bibliotecas podem ser adicionadas,<br>
para que novas funções e atributos possam ser utilizados no projeto.<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade.<br>
1 l i b r a r y i e e e ;<br>
2 use IEEE . STD_LOGIC_1164 . ALL<br>
3<br>
4 ENTITY f u l l _ a d d e r IS PORT(<br>
5 x1 , x2 , c i n : i n s t d _ l o g i c ;<br>
6 S , c o u n t : o u t s t d _ l o g i c ) ;<br>
7 END f u l l _ a d d e r ;<br>
Fonte: Própria.<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL.<br>
1 ARCHITECTURE b e h a v i o r a l OF f u l l _ a d d e r IS<br>
2 BEGIN<br>
3 s &lt;=x1 XOR x2 XOR c i n ;<br>
4 cout &lt;=( x1 AND x2 ) OR ( x1 AND c i n ) OR ( b<br>
AND c i n ) ;<br>
5 END b e h a v i o r a l ;<br>
Fonte: Própria.<br>
Segundo CAPPELATTI,2010 uma descrição em VHDL pode conter diferentes níveis de<br>
abstração:<br>
• Comportamental: Permite descrever o circuito através de laços e processos. O circuito<br>
é definido em forma de um algoritmo, utilizando construção similares as utilizadas em<br>
linguagem de programação.<br>
• Transferência de registradores: Englobando a representação do dispositivo em nível de<br>
transferência entre registradores, que consiste na utilização de funções lógicas combina-<br>
cionais e de registradores.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 18<br>
• Estrutural: O circuito é descrito mais próximo da implementação real, podendo ser<br>
definidas portas lógicas com atrasos unitários ou com atrasos detalhados.<br>
2.1.2 Portas lógicas<br>
Segundo (IDOETA; CAPUANO, 1982), o conceito de portas lógicas é baseado na<br>
conhecida álgebra de Boole ou álgebra booleana, desenvolvida pelo matemático inglês George<br>
Boole em 1854. A álgebra booleana é representada por apenas dois valores, sendo eles o 0 e 1 e,<br>
através disso, expressa a relação entre entrada e saída dentro de um circuito. As portas lógicas<br>
podem ser construídas a partir de diodos, transistores e resistores interconectados de modo que a<br>
saída seja o resultante de uma operação lógica básica realizada sobre as entradas (TOCCI et al.,<br>
2003). A Figura 5 apresenta um exemplo de álgebra booleana sem a utilização de diagramas.<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1.<br>
Fonte: (TOCCI et al., 2003)<br>
Ainda segundo TOCCI et al.,2003, devido a esta característica, a álgebra booleana possui<br>
três operações básicas, OR (ou), AND (e) e NOT (não). Tal conjunto de operações também é<br>
denominado de operações booleanas e, por meio da utilização de tabelas verdade é possível<br>
descrever as saídas baseando-se nas entradas e na operação aplicada. Cada operação booleana<br>
possui sua tabela verdade ( Figura 6), bem como sua representação em forma de diagrama.<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas.<br>
Fonte: (TOCCI et al., 2003)<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 19<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas.<br>
Fonte: (TOCCI et al., 2003)<br>
A Figura 7 apresenta um circuito lógico formado pelas portas básicas da álgebra booleana.<br>
O circuito apresenta três entradas representadas pelas letras A, B e C, mas também formada<br>
por duas portas AND, uma porta NOT e uma porta OR. Cada uma destas portas representando<br>
operações a serem realizadas, podendo receber como entrada um valor inicial ou resultante de<br>
outra porta, como no exemplo ocorre com a última porta AND.<br>
Entetanto, segundo (KROPF, 2013), a análise de circuitos é extremamente complexa,<br>
resultando em um problema NP-Completo, algoritmos possuem tempo de execução exponencial.<br>
Contudo, este tempo de execução exponencial é uma complexidade exponencial para o pior caso,<br>
resultando crescimento exponencial da execução a medida que o tamanho do problema aumenta.<br>
Ainda, segundo (KROPF, 2013) a avaliação das funções booleanas podem ser ver-<br>
dadeiras(True) ou falso(False), com isso, para um função com n variáveis, apresenta 2n possibili-<br>
dades de avaliação. Utilizando o exemplo da Figura 7 que apresenta 3 entradas, logo apresenta 8<br>
possibilidade de avaliação ao final e este número aumenta à medida que o número de variáveis<br>
tambe aumenta<br>
2.2 Verificação de sistemas<br>
No contexto de verificação de sistemas, faz-se necessário a diferenciação entre verificação<br>
e validação. Verificação e validação possuem o intuíto de mostrar que determinado sistema fun-<br>
cione conforme o especificado, além de satisfazer as especificações do cliente (SOMMERVILLE,<br>
2011).<br>
Segundo (SARGENT, 2005), verificação é o processo de determinar se um modelo<br>
computacional obtido por discretização de um modelo matemático de um evento físico e o<br>
código que implementa o modelo computacional pode ser usado para representar o modelo<br>
matemático do evento com precisão suficiente e validação é o processo de determinar se um<br>
modelo matemático de um evento físico representa o evento físico real com precisão suficiente.<br>
A verificação consite identificação de erros e provavéis problemas que um componente<br>
pronto possa apresentar, enquanto a validação busca analisar se tal componete esta seguindo<br>
os requisitos pré-definidos para sua construção (KOSCIANSKI; SOARES, 2007). O teste de<br>
programa, na qual o software é executado com dados de teste é a principal forma de validação,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 20<br>
porém, tecnicas de verificação, tais como, inspeção e revisões também podem integrar a etapa de<br>
validação (SOMMERVILLE, 2011).<br>
2.2.1 Diagrama de decisão binária<br>
Um diagrama de decisão binária(DDB) pode ser definido como um grafo aciclico para<br>
representação de funcões boolenas. Existe uma ordem rigorosa na ocorrência de variáveis à me-<br>
dida que se percorre o grafo da raiz para a folha. Dado como exemplo a formula f=(a?b)?(c?d)<br>
e utilizando a ordenação de variavél a &lt; b &lt; c &lt; d, na Figura 8. Dada a atribuição de valores<br>
booleanos as variaveis a, b, c e d, pode-se decidir se a atribuição torna a fórmula verdadeira<br>
atravessando o início do gráfico na raiz e ramificação em cada nó. Definindo a, c e d = 1 e c = 0<br>
leva a folha de rótulo 1, portanto, a fórmula é verdadeira para essa tarefa (CLARKE et al., 1994).<br>
Figure 8 – Arvore de decisão binária<br>
Fonte: (CLARKE et al., 1994)<br>
Adicionar mais detalhes e descrever onde DDB é utilizado.<br>
O DDB permite o teste eficiente de satisfabilidade, validade e eficiência (KROPF, 2013).<br>
O uso e DDB em conjunto com Model Checking e técnicas de abstração permitiu o aumento na<br>
capacidade de verificação, de modo que sistemas mais realistas podessem ser verificados(??)<br>
2.2.2 Model Checking<br>
Model checking é uma técnica de verificação formal que explora todos os possíveis<br>
estados do sistema, de modo a provar se um modelo satisfaz determinada propriedade. Pode ser<br>
aplicada em uma ampla gama de aplicações, tais como sistema embarcados, design de hardware<br>
e engenharia de software (BAIER et al., 2008).<br>
Entre as vantagens da utilização de Model Checking estão:<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 21<br>
• Possuem suporte a verificação parcial, em outras palavras, a verificação individual de<br>
propriedades, permitido foco primeiro as propriedades essenciais(BAIER et al., 2008).<br>
• Não requer qualquer interação do usuário, nem um alto grau de especialização para o uso<br>
de model checking(BAIER et al., 2008).<br>
• Possui como base a teoria de grafos, estruturas de dados e lógica no desenvolvimento da<br>
solução(BAIER et al., 2008).<br>
• Útil para fins de depuração, pois formece informações em caso de uma propriedade seja<br>
invalidada(BAIER et al., 2008).<br>
Por outro lado, apresenta também algumas desvantagens:<br>
• Sofre do problema de explosão de espaço de estados, ou seja, a quantidade de estados<br>
necessários pode ser maior que a memória disponivel pelo sistema(BAIER et al., 2008).<br>
• Faz a verificação apenas dos requisios declarados, logo, não a garantia de integridade.<br>
Baseado nisso, a validade de propriedades não verificadas não pode ser julgada(BAIER et<br>
al., 2008).<br>
• A verificação de modelos geralmente não é computável, isso deve-se a questões de decidi-<br>
bilidade utilizada (BAIER et al., 2008).<br>
Outras técnicas foram implementadas em conjuntos com Model checkings com o intuito<br>
de aumentas a capacidade de verificação, como a técnica SAT na qual não sofre do problema de<br>
explosão de estados existente usando DDB. A técnica SAT em conjuto com Model Checking é<br>
conhecida como Bounded Model Checking (??).<br>
2.2.3 Bounded Model Checking<br>
Segundo ROCHA et al., Bounded Model Checking (BMC) é um tipo especial de Model<br>
Checking que usualmente adota o método de satisfabilidade booleana, o qual tem sido introduzido<br>
como uma técnica complementar para diagrama de decisão binaria para aliviar o problema da<br>
explosão de estados, visto que a técnica de Model Checking busca todos os estados possíveis<br>
para verificação.<br>
Bounded Model Checking é uma técnica para a verificação de uma dada propriedade<br>
em uma determinada profundidade do sistema analisado. Logo, dado um sistema de transições<br>
M, uma propriedade ?, e um limite (bound) k, o BMC desenrola o sistema k vezes e traduz o<br>
sistema em uma condição de verificação(CV) ? tal que ? é satisfeito se e somente se ? tem um<br>
contra-exemplo de profundidade menor ou igual a k (ROCHA et al., 2015b).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 22<br>
O Extended SMT-Based Bounded Model Checker (ESBMC) é um Bounded Model<br>
Checking baseado em satisfabilidade booleana (SAT) que permite verificação aritmética de Já tem<br>
su-<br>
porte<br>
a<br>
SMT<br>
adi-<br>
cionar<br>
ao<br>
texto<br>
overflow e undeflow, segurança de ponteiros, limite de array, de gerar propriedades de segurança<br>
em programas em C/C++. ESBMC utiliza uma versão modificada do CBMC no front-end para<br>
analisar o código ANSI-C e para gerar as condições de verificação através de execução simbólica<br>
(CORDEIRO et al., 2012; ROCHA et al., 2015b).<br>
No ESBMC, o programa analisado é modelado em um sistema de transição de estados,<br>
conforme a trupla: M = (S,R, S0), o qual é gerado um grafo de controle de fluxo (GFC), onde<br>
S representa o conjunto de estados, R ? SxS representa as transições e S ? S representa<br>
o conjuto de estados iniciais. Um estado s ? S consiste no valor do contador de programa<br>
(PC) e os valores de todas as variáveis dos programas. O estado inicial S0 atribui o inicio do<br>
programa GFC ao PC, desta forma o ESBMC identifica as transições, conforme a formula lógica,<br>
?=(Si,Si+1) que captura as retrições sobre os valores correspondntes do PC e das variáveis do<br>
programa (CORDEIRO et al., 2012).<br>
Segundo o site do ESBMC(??), a ferramenta permite ao usuário indicar propriedades<br>
adicionaisusando assertivas que também são verificadas. O ESBMC converte as condições Descrever<br>
quais<br>
pro-<br>
priedades<br>
o<br>
esbmc<br>
su-<br>
porta<br>
usando diferentes técnicas de backgroundpara posteriormente passar para verificador SMT. Outra<br>
apresentar<br>
exem-<br>
plo<br>
vantagem é a ferramenta permitir verificação de software single-thread e multi-thread.<br>
Descrever qual a razão da escolha para o trabalho, apresentar resultados do SV-COMP<br>
dos últimos 3 anos<br>
2.2.4 Redes de petri<br>
Apresentar definição formal para RP<br>
corrigir o texto abaixo RP não é uma ferramenta e sim um método de modelagem<br>
Redes de petri são utilizadas como ferramentas de modelagem gráfica com propriedades<br>
matemática. Como ferramenta gráfica são utilizadas como comunicação visual, como fluxogra-<br>
mas, por exemplo, e como ferramenta matemática podem configurar modelos matemáticos que<br>
regem o comportamento dos sistemas. A grade premissa desta ferramenta é descrever sistemas<br>
de processamento de informações caracterizados como concorrentes, assíncronos, distribuídos,<br>
paralelos, não deterministas e/ou estocásticos (MURATA, 1989).<br>
As redes de petri são representados como grafos direcionais compostos por nós e arcos,<br>
conforme apresentado na Figura 9. Os nós representam as transições e eventos e os arcos<br>
representam os pesos. Dentro desta representação, os arcos e eventos são componentes passivos<br>
enquanto as transições são ativos. A principal vantagem da utilização das redes de petri esta<br>
relacionado ao chamado "Token game" que consiste no comportamento da rede de petri, em<br>
outras palavras, representa o funcionamento do sistema representado pela rede(HALDER;<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 23<br>
VENKATESWARLU, 2006).<br>
Figure 9 – Rede de petri<br>
Fonte: (HALDER; VENKATESWARLU, 2006)<br>
Descrever o funcionamento da RP apresentado na IMG<br>
Descrever quais propriedades podem ser verificadas com RP e onde será utilizado no seu<br>
trabalho.<br>
2.2.5 Verificação de hardware<br>
Para a verificação de hardware diversas técnicas têm sido propostas (). Por meio da Apresentar<br>
exem-<br>
plos<br>
com<br>
refer-<br>
ências<br>
simulação, visa assegurar que uma implemetação, descrição do hardware em qualquer qualquer<br>
nível de abstração da hierarquia de hardware, atinja suas especificações, propriedades que devem<br>
ser respeitadas para que a corretude do mesmo seja comprovada (GUPTA, 1992). A Verificação<br>
formal de hardware consiste na utilização de técnicas para corretude de circuitos lógicos, ou<br>
seja, consiste na utilização de modelos matemáticos para descrição de propriedade e/ou de<br>
comportamento de um dado sistema (KROPF, 2013).<br>
Entre as abordagens utilizadas na verificação formal de hardware consiste tanto na imple-<br>
mentação quanto a especificação estarem descritas em lógica formal, neste caso a corretude será<br>
obtida através da comprovada relação entre a implementação e a especificação (SEGER, 1992).<br>
A especificação formal consiste na descrição do comportamento, bem como, das propriedades<br>
do sistema em linguagem matemática, tornando-se crucial para o processo de verificação. Na<br>
implementação formal, o nível de abstração, tais como, Gate level e RTL são importantes infor-<br>
mações para o desenvolvimento do formalismo, bem como as classes, por exemplo se o circuito<br>
é sequencial ou combinacional, se utiliza pipeline, etc (KROPF, 2013).<br>
Apresentar um exemplo de RTL<br>
A utilização de Model Checking também se faz presente nos modelos formais de ver-<br>
ificação de hardware, onde apenas é utilizado o comportamento dos circuitos na verificação,<br>
de modo a verificar a se as propriedades presentes são satisfeitas. Para isso, são utilizados os<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 24<br>
conceitos da lógica proposicional, que por meio da utilização de fórmulas que representem as<br>
propriedades dos estados, é possível realizar as verificações necessárias (SEGER, 1992).<br>
Apresentar um exemplo com um circuito e como este pode ser verificando com model<br>
checking<br>
2.2.6 Verificação formal de software<br>
Observa-se que o uso de verificacão de software tem sido feito aplicado em muitas áreas,<br>
tais como, infraestruturas industriais de missão critica e de segurança. Logo, existe a necessidade<br>
de garantir a corretude destes sistemas. Devido a isso, a verificação formal tem sido utilizada em<br>
três principais abordagens, sendo elas (COUSOT; COUSOT, 2010; D’SILVA et al., 2008):<br>
Apresentar exemplos para os métodos apresentados abaixo<br>
• Métodos dedutivos: Produzem provas matemáticas formais de corretude usando provadores<br>
de teoremas ou assistentes de prova para execução da prova e necessitam da interação<br>
humana para prover os argumentos (COUSOT; COUSOT, 2010);<br>
• Verificação de modelos: Exploram exaustivamente modelos de execuções de programa,<br>
que podem ser sujeitos a explosão combinatória, necessário a intervenção humana para<br>
geração dos modelos (ROCHA et al., 2015b);<br>
• Analise estática: Engloba diversas técnicas para calcular automaticamente informações<br>
sobre o comportamento de um programa sem executá-lo, sendo utilizado em otimização<br>
de código e verificação em compiladres (D’SILVA et al., 2008).<br>
Segundo ROCHA et al., na verificação formal de software apresentam-se dificuldades,<br>
tais como: quais as propriedades são de interesse na verificação em tempo de execução; e<br>
impossibilidade matemática de provar a corretude de propriedades não triviais no comportamento<br>
de programas (COUSOT; COUSOT, 2010).<br>
2.2.7 Lógica proposicional<br>
A lógica proposicional é uma linguagem formal onde é definida um alfabeto e conectivos<br>
proposicionais, e um conjunto de regras gramaticais, as quais serão utilizadas para construção<br>
das proposições (SOUZA, 2017). Porém apesar de importante, ela é limitada, não podendo<br>
expressar sentenças elementares importantes, tais como a da aritmética elementar. Por exemplo:<br>
1. Todos são mortais.<br>
2. Alguém é bondoso.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 25<br>
Na lógica preposicional, não poderiam ser analisadas, pois não teria como decompor<br>
ambas em sentença e assim não teria como analisar as diferenças entre ambas(ABE, 2002).<br>
Contudo, no exemplo: Existem cavalos com patas verdes. A relação criada pela frase poderia a<br>
ser analisada pela lógica proposicional(ABE, 2002). Descrever<br>
como<br>
seria<br>
está<br>
analise<br>
Segundo SOUZA, alfabeto da lógica proposicional é formado por símbolo de pontuação,<br>
símbolos proposicionais e conectivos proposicionais, onde cada um apresenta uma função em<br>
específico, sendo:<br>
• Símbolos de pontuação: Apenas dois símbolos de pontuação são utilizados o "(" e o ")".<br>
• Símbolos proposicionais: São utilizados para representar as proposições, onde um sím-<br>
bolo P pode ser utilizado para representar uma proposição qualquer, por exemplo: P="Está<br>
chovendo". O conjunto de símbolos proposicionais é infinito e enumerável, sendo possível<br>
representar infinitos e enumerável conjunto de proposições.<br>
• Conectivos proposicionais: São os símbolos usando frequentemente na matemática. Os<br>
símbolos recebem a seguinte denominação:<br>
1. ¬: Representa a partícula de negação, ou seja, "Não".<br>
2. ?: Representa a partícula "Ou"<br>
3. ?: Representa a partícula "E"<br>
4. ?: Representa a partícula "Se então ou implica".<br>
5. ?: Representa a partícula "Se, e somente se".<br>
Ainda segundo SOUZA, existem as fórmulas que são constituídas de forma indutiva, a<br>
partir de símbolos do alfabeto conforme as regras apresentadas abaixo:<br>
• Todo o símbolo preposicional é uma fórmula<br>
• Se H é uma fórmula, então (¬H), a negação de H, é uma fórmula.<br>
• Se H e G são fórmulas, então a disjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a conjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o antecedente e G consequente da fórmula.<br>
• Se H e G são fórmulas, então a bi-implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o lado esquerdo e G o lado direito da fórmula.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 26<br>
2.2.8 Linguagem de especificação de propriedades<br>
Linguagem de especificação de propriedades, do inglês Property Specification Language<br>
- PSL, é uma notação formal para especificação de comportamento em sistemas eletrônicos,<br>
compatível com as linguagens VHDL, Verilog, SystemC e SystemVerilog. Destina-se a utilização Adicionar<br>
refer-<br>
ência<br>
a cada<br>
Ling<br>
citada<br>
para a especificação funcional, mas também para entrada de ferramentas de verificação. A<br>
especificação do PSL é a utilização de assertivas sobre propriedades de um sistema, sendo estas<br>
propriedades constituídas de três elementos: expressões boolenas, expressões sequenciais e<br>
operadores temporais (IEEE. . . , 2010).<br>
Corrigir a apresentação da citação IEEE... estranho<br>
Segundo (IEEE. . . , 2010), o PSL foi totalmente desenvolvida com o intuito fornecer<br>
leitura e escrita de fácil entendimento, sintaxe concisa, semântica formal e rigorosamente bem<br>
definida e ser matematicamente precisa, visto a utilização da mesma em processo de verificação.<br>
O PSL pode ser utilizado para capturar requisitos relativos ao comportamento total do projeto,<br>
bem como, sobre o modo que o mesmo deverá operar no ambiente, ms também para capturar<br>
requisitos comportamentais e os pressupostos que surgem durante o processo de design. Ambas<br>
podem ser utilizadas para verificação de sistemas.<br>
Apresentar exemplos de uso da PSL<br>
2.2.9 Verificação baseada em assertivas<br>
Verificação baseada em assertivas, do inglês Assertion-Based Verification - ABV, é um<br>
paradigma de verificação igualente adequado para verificação formal e abordagens baseadas em<br>
simulação (BOULE; ZILIC, 2005) e em conjunto com a tecnica de PSL tem ganhado aceitação<br>
como um método essencial para verificação funcional do hardware (DAHAN et al., 2005).<br>
Na ABV as assertivas são declaração adicionadas ao projeto com o intuito de especificar<br>
o comportamento do projeto (BOULE; ZILIC, 2005), podendo escritos em PSL ou em SVA<br>
(System Verilog Assertions). No caso deste projeto será utilizado a PSL, devido a mesma ser<br>
utilizada juntamente com a linguagem VHDL.<br>
Com a utilização de ABV o circuito pode ser verificado usando técnicas de simulação<br>
e/ou verificação, por exemplo, model checking, para garantir que o mesmo esteja de acordo<br>
com o pretendido projeto (DAHAN et al., 2005). Na Figura 19 apresenta o modelo de assertiva<br>
utilizada no projeto, utilizando de um modelo próprio para assertivas, unindo as funcionalidades<br>
já existentes nas assertivas do VHDL, mas também novas (serão apresentadas nas próximas<br>
seções), fornecendo assim mais propriedades a serem analisadas.<br>
Descrever qual o objetivo da assert apresentado<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 27<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 e n t i t y AND_ent i s<br>
5 p o r t ( x , y : i n b i t ;<br>
6 F : o u t b i t<br>
7 ) ;<br>
8 end AND_ent ;<br>
9<br>
10 a r c h i t e c t u r e behav1 of AND_ent i s<br>
11 b e g i n<br>
12 ??@c2vhdl : ASSERT<br>
13 ??a s s e r t n o t ( x= ’ 0 ’ and y= ’ 1 ’ )<br>
14 ?? r e p o r t " Both v a l u e s o f s i g n a l s x and y a r e e q u a l t o 1 "<br>
15 ??s e v e r i t y ERROR;<br>
16 ??@c2vhdl :END<br>
17<br>
18 p r o c e s s ( x , y )<br>
19 b e g i n<br>
20 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
21 F &lt;= ’ 1 ’ ;<br>
22 e l s e<br>
23 F &lt;= ’ 0 ’ ;<br>
24 end i f ;<br>
25 end p r o c e s s ; 4<br>
26 end behav1 ;<br>
Fonte: Própria.<br>
2.2.10 Propriedades de segurança<br>
Propriedades de segurança é um meio de validação do comportamento de um determinado<br>
sistema, de modo que se uma dada propriedade de segurança for violada, então através de<br>
uma execução finita, é possível verificar tal erro. Algumas propriedades de segurança, no<br>
entanto, podem impor requisitos em fragmentos de caminho finito e não podem ser verificadas<br>
considerando apenas os estados alcançáveis. (BAIER et al., 2008).<br>
Segundo (CLARKE et al., 2003), podemos definir uma propriedade de segurança como:<br>
dado um sistema de transições ST = (S, S0, E), seja um conjunto B ? S que especifica um<br>
conjunto de maus estados tais que S0 ?B = ?, pode-se dizer que ST é seguro com relação a B,<br>
denotado por ST |= AG¬B se não existe um caminho no sistema de transição do estado inicial<br>
S0 até o estado B, de outro modo é dito que ST não é seguro.<br>
Adicionar exemplos de propriedades de segurança em hardware<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 28<br>
2.3 Técnicas de compiladores<br>
Compiladores são sistemas de software utilizados para tradução de uma linguagem de<br>
programação para outra, ou seja, o programa da linguagem fonte é lido e traduzido para um<br>
código equivalente na outra linguagem, ou linguagem alvo. Geralmente utilizada para transformar<br>
trechos de código em uma linguagem a ser executada pelo computador (AHO et al., 2007).<br>
Diversas técnicas podem ser utilizadas nas diversas etapas, até que o código seja traduzido,<br>
tais como LL(1) e LR na análise sintática; eliminação de código morto; propagação de constante<br>
e Peephole na otimização de código(AHO et al., 2007). Neste projeto serão focados as áreas de<br>
transformações de código e otimização de código.<br>
2.3.1 Transformações de código<br>
Transformações de código correspondem a uma complexa função que envolve analise de<br>
fluxo de dados e modificação completa do programa que são parte integral da alta performance e<br>
sistemas computacionais. Podem ser classificados em transformações escalares que reduzem<br>
o número de instruções a serem executadas no programa ou transformações paralelas que<br>
maximizam o paralelismo (SRIKANT; SHANKAR, 2002).<br>
A Figura 11 representa o trecho de código apresentado na Figura 19. O trecho representa<br>
o comportamento das entradas, neste caso de um código da porta AND. E a figura Figura 12<br>
representa a tradução deste trecho em código na linguagem C. Esta tradução foi realizada pela<br>
ferramenta V2C, utilizada neste projeto. Adicionar<br>
refer-<br>
ência<br>
Figure 11 – Trecho de código em VHDL representando porta AND.<br>
1 p r o c e s s ( x , y )<br>
2 b e g i n<br>
3 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
4 F &lt;= ’ 1 ’ ;<br>
5 e l s e<br>
6 F &lt;= ’ 0 ’ ;<br>
7 end i f ;<br>
8 end p r o c e s s ;<br>
Fonte: Própria.<br>
Expandir esta seção. Apresentar propriedades de transformação e técnicas para avaliar a<br>
transformação<br>
2.3.2 Otimização de código<br>
A otimização de código consiste na melhoria do código intermediário gerado pelos<br>
algoritmos de compilação com o objetivo de obter um menor tempo de execução do programa,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 29<br>
Figure 12 – Trecho de código traduzido para linguagem C.<br>
1 /? S t a r t o f T r a n s l a t i o n ? /<br>
2 /? p0 : ? /<br>
3 i f ( chg [ x ] | | chg [ y ] ) {<br>
4 i f ( ( ( o l d [ x ]==1) && ( o l d [ y ]==1) ) ) {<br>
5 new [ f ] = 1 ;<br>
6 }<br>
7 e l s e {<br>
8 new [ f ] = 0 ;<br>
9 }<br>
10 }<br>
11 /? End o f T r a n s l a t i o n ? /<br>
Fonte: Própria.<br>
porém outros fatores podem ser introduzidos, como algoritmos menores. Este fato não implica<br>
em afirmar que o melhor código é gerado, visto que dada a complexidade, raramente pode ser<br>
obtido que o código gerado pode ser o melhor possível (AHO et al., 2007).<br>
Segundo AHO et al., otimização local de código consiste na otimização de um bloco<br>
básico de código, ou seja, a otimização ocorre em um trecho especifico de código. Os blocos<br>
básicos são trecho onde não ocorrem saltos ou loops, para nenhuma outra parte do código. A<br>
otimização global de código é baseado na analise do fluxo de dados, de modo que ocorra as<br>
elminação de instruções não necessárias ou substituição mais facil. A otimização global consite<br>
na analise completa do código. Neste sentido, nas próximas seções serão apresentadas algumas<br>
importantes técnicas de otimizações.<br>
2.3.2.1 Grafo Acliclico Direcional - GAD<br>
Grafo Aciclico Direcional é utilizado para diversos fins dentro da estrutura de compi-<br>
ladores, principalmente para geração da parse tree otimização de código. Pode ser usado na<br>
representação de instruções unicas blocos básicos de código(AHO et al., 2007). O uso de GAD<br>
permite a melhoria de de código, tais como:<br>
• Elminação de subexpressões locais comuns, ou seja, expressões que o valor já foi com-<br>
putado anteriomente;<br>
• Eliminação de código morto;<br>
• Reordernamento de declarações buscando reduzir o tempo que o valor temporário necessita<br>
ser preservado em um registro;<br>
A Figura 13 apresenta um bloco básico com algumas instruções, no caso apresentando<br>
são 4 operações entre somas e multiplicação e a partir deste bloco a Figura 14 apresenta o GDA<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 30<br>
Figure 13 – Exemplo de bloco basico de código.<br>
1 a = b + c<br>
2 b = a ? d<br>
3 c = b + c<br>
4 d = a ? d<br>
Fonte: (AHO et al., 2007)<br>
Figure 14 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
deste trecho de código. Nele apresenta cada nó como uma operação especifica e os terminais<br>
como as parcelas das operações.<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC<br>
Grafo de fluxo de controle corresponde a um grafo direcionado, no qual cada nó rep-<br>
resenta blocos básicos e cada aresta representa os caminhos de fluxo entre os blocos basi-<br>
cos (ALLEN, 1970). É importante ressaltar que saltos determinam o final de um determinado<br>
bloco básico, ou seja, saltos indicam um caminho para uma nova região de código básico (AHO<br>
et al., 2007).<br>
Apresentar um exemplo de como e utilizado em código<br>
2.3.2.3 Eliminção de código morto<br>
A eliminacação de código morto é uma técnica que busca a eficiência de um programa<br>
evitando a execução de instruções não necessária em tempo de execução (KNOOP et al., 1994).<br>
O código morto consiste em instruções que não serão alcançáveis durante o fluxo do programa,<br>
sendo esta técnica basicamente a retirada de qualquer variável que não será utilizada em qualquer<br>
outro nó do grafo (AHO et al., 2007).<br>
A utilização de GAD corresponde na eliminação de qualquer nó raiz, ou seja, nó sem<br>
ancestrais, as quais não esteja ativa anexada a mesma. A execução repetida desta operação<br>
removerá todos os nós correspondentes a código morto (AHO et al., 2007).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 31<br>
Figure 15 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
Na Figura 15, supondo que os nós a, b e c estejam ativa, porém o nó énão esteja, o último Corrigir<br>
nó é?pode ser eliminado imediatamente. Os nós restantes continuam no GDA, a menos que não tenho<br>
variáveis ativas atreladas aos nós (AHO et al., 2007).<br>
2.3.2.4 Análise do fluxo de dados<br>
Análise de fluxo de dados refere-se ao conjunto de técnicas que derivam informações<br>
sobre o fluxo de dados ao longo dos caminhos de execução do programa. Para análise do<br>
programa, é necessário considerar todas as posiveis execuções através do grafo de fluxo de<br>
controle (AHO et al., 2007).<br>
Apresentar exemplos<br>
2.3.2.5 Gerador de código<br>
O gerador de código é responsavél pela tradução final do programa-fonte para o programa-<br>
alvo, o mesmo recebe como entrada um código intermediário juntamente com a tabela de<br>
símbolos. Faz-se necessário que o programa-fonte tenha sido analisado sintatica e lexicamente,<br>
assim evitando que erros possam ser passados para o programa-alvo, por outro lado a existência<br>
de uma nível de otimização, faz-se opicional neste caso (AHO et al., 2007).<br>
O gerador de código possui três tarefas primarias, sendo as mesmas seleção de instrução,<br>
alocação de registros e atribuições. A seleção de instruções envolve a escolha das instruções<br>
apropriadas da máquina-alvo para implementar as declarações do código intermediario. A<br>
atribuição e atribuição de registros envolve a decisão sobre os valores a serem registrados nos<br>
registros(AHO et al., 2007).<br>
Apresentar exemplo<br>
32<br>
3 TRABALHOS CORRELATOS<br>
Sugiro apenas mencionar que foi feito a revisão sistemática; o que já foi feito e os resul-<br>
tados. As outras seções sobre RS e mover para apêndice.<br>
3.1 Revisão sistemática<br>
A revisão sistemática consiste é um método de identificação, análise e interpretação de<br>
pesquisas relevantes em determinada área ou questão de pesquisa. Para execução da revisão sis-<br>
temática se requer um esforço maior, em comparação as pesquisas tradicionais, sendo necessário<br>
seguir uma sequência de passos metodológicos sobre a área ou questão de pesquisa ao qual<br>
deseja ser feita a pesquisa (KITCHENHAM, 2004).<br>
Para a execução da revisão sistemática, é necessário um esforço considerável, se com-<br>
parado a uma revisão informal a literatura. Enquanto que a revisão de literatura informal é<br>
conduzida de forma ad-hoc, sem planejamento e critérios de seleção estabelecidos a priori,<br>
a revisão sistemática requer um protocolo formal bem definido, com uma sequência de pas-<br>
sos metodológicos, para conduzir uma pesquisa sobre o tema ao qual deseja-se realizar a<br>
pesquisa (MAFRA; TRAVASSOS, 2006).<br>
A aplicação da revisão sistemática requer que seja seguido um conjunto bem definido e<br>
sequêncial de passos, seguindo um protocolo de pesquisa desenvolvido previamente. Através<br>
deste método é possível realizar uma extensa pesquisa, contemplando uma grande quantidade<br>
de informações sobre o assunto pesquisado (MAFRA; TRAVASSOS, 2006). Este protocolo é<br>
construído considerando um tema específico que representa o elemento central da investigação,<br>
onde os passos da pesquisa, as estratégias definidas para coletar as evidências e o foco das<br>
questões de pesquisa são definidas explicitamente, de tal forma que outros pesquisadores sejam<br>
capazes de reproduzir o mesmo protocolo de pesquisa (BIOLCHINI et al., 2005).<br>
Segundo MAFRA; TRAVASSOS, o processo para a condução de revisões sistemáticas<br>
envolve três etapas:<br>
1. Planejamento da Revisão: os objetivos da pesquisa são listados e o protocolo da revisão<br>
é definido.<br>
2. Condução da Revisão:nesta atividade, as fontes para a revisão sistemática são sele-<br>
cionadas, os estudos primários são identificados, selecionados e avaliados de acordo com<br>
os critérios de inclusão, exclusão, e de qualidade estabelecidos durante o protocolo da<br>
revisão.<br>
Chapter 3. TRABALHOS CORRELATOS 33<br>
3. Análise dos Resultados: os dados dos estudos são extraídos e sintetizados para análise e<br>
apresentação dos resultados.<br>
Vale ressaltar que como o objetivo deste trabalho é realizar um estudo exploratório de<br>
caracterização de área podemos dizer que esta revisão sistemática se caracteriza como uma quasi-<br>
sistemática (TRAVASSOS et al., 2008), pois segue o mesmo processo da revisão sistemática e<br>
preserva o rigor e mesmo formalismo para as fases metodológicas de elaboração de protocolo e<br>
execução da revisão, mas sem a aplicação de uma meta-análise a princípio, que pode ser aplicada<br>
posteriormente.<br>
3.1.1 Planejamento da Revisão Sistemática<br>
Objetivo: Este estudo tem o objetivo esquematizado a partir da estrutura do paradigma<br>
GQM (do ingles Goal,Question and Metric)(BASILI et al., 1994).<br>
Analisar Publicações científicas através de um estudo baseado em revisão sis-<br>
temática<br>
Com propósito de Identifica-las<br>
Com relação as Vantagens e desvantagens da utilização de assertiva e transformações<br>
de código na verificação do código na linguagem de descrição VHDL<br>
Do ponto de vista do Pesquisador<br>
No contexto Acadêmico ou industrial para verificação de assertivas na linguagem<br>
de descrição VHDL<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM<br>
Formulação da Pergunta: Buscamos respostas para as seguintes perguntas:<br>
• Q1: Quais são os métodos para verificação de circuitos lógicos descritos na linguagem de<br>
programação VHDL?<br>
– Q1.1: Foi desenvolvido e está disponível alguma ferramenta para aplicação do<br>
método?<br>
– Q1.2: Qual a técnica de exploração de estados para circuitos lógicos?<br>
– Q1.3: O método proposto é baseado em técnicas de verificação de software?<br>
– Q1.4: Como o método proposto valida pré e pós condições no programa?<br>
– Q1.3: Foi utilizado algum benchmark de programas em VHDL para experimentação<br>
e o mesmo encontra-se disponível?<br>
– Q1.4: Quais as perspectivas futuras para melhorar da aplicação do método proposto?<br>
Escopo da pesquisa:Na delimitação do escopo da pesquisa foram estabelecidos critérios,<br>
buscando garantir a viabilidade da execução, acessibilidade dos dados e abrangência do estudo re-<br>
alizado. A pesquisa dar-se-á a partir de bibliotecas digitais através das suas respectivas máquinas<br>
Chapter 3. TRABALHOS CORRELATOS 34<br>
de busca e, quando os dados não estiverem disponíveis eletronicamente, através de consultas<br>
manuais.<br>
Critérios de Seleção de Fontes. Para as bibliotecas digitais é desejado:<br>
• Possuir uma máquina de busca que permita o uso de expressões lógicas ou mecanismo<br>
equivalente.<br>
• Incluir em sua base, publicações de exatas ou correlatas que possuam relação direta com o<br>
tema a ser pesquisado<br>
• As máquinas de busca deverão permitir a busca no texto completo das publicações.<br>
Segundo ROCHA et al., os mecanismos de busca utilizados devem garantir resultados<br>
únicos através da busca de um mesmo conjunto de palavras-chaves (string de busca). Quando<br>
isto não for possível, deve-se estudar e documentar uma forma de minimizar os potenciais efeitos<br>
colaterais desta limitação.<br>
Métodos de Busca das Publicações. As fontes digitais foram acessadas via Web, através<br>
de expressões de busca pré-estabelecidas. A biblioteca digital consultada foi a Scopus, acessível<br>
em http://www.scopus.com. Segundo a editora ELSEVIER, a Scopus é uma das maiores bases<br>
de dados de resumos e citações da literatura de pesquisa peer-reviewed com mais de 22, 800<br>
títulos de mais de 5, 000 editoras internacionais abrangendo as áreas de tecnologia, medicina,<br>
artes, ciências sócias e com atualizações diárias. Entre as editoras podemos citar: Springer<br>
(SPRINGER, 2018); IEEE Xplore Digital Library (IEEE, 2018);ACM Digital Library (ACM,<br>
2018) ; ScienceDirect/Elsevier (B.V, 2018); Wiley Online Library (SONS, 2018); dentre outras.<br>
String de Busca. A string de busca foi definida segundo o padrão PICO (do inglês<br>
Population, Intervention, Comparison, Outcomes) (KITCHENHAM et al., 2009), conforme a<br>
estrutura abaixo:<br>
• População: Trabalhos publicados em conferências e periódicos que relacionam verificação<br>
de propriedades de circuitos lógicos em códigos para a descrição de hardware.<br>
• Intervenção: Verificação de propriedades relacionadas a verificação de circuitos para as<br>
diferentes estruturas das linguagens de descrição de hardware;<br>
• Comparação: análise de cobertura e suporte das abordagens identificadas para a verificação<br>
de propriedades das linguagens de descrição de hardware;<br>
• Resultados: a partir da descrição das abordagens pretende-se verificar a cobertura que cada<br>
abordagem apresenta na manipulação das diferentes estruturas da linguagem de descrição<br>
de hardware para a verificação de propriedades baseada em assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 35<br>
Segundo ROCHA et al., como este estudo representa um estudo de mapeamento/caracteri-<br>
zação, a string de busca foi definida de acordo com dois aspectos: População e Intervenção, como<br>
é apresentado na estrutura abaixo. Posteriormente esta mesma string de busca será executada<br>
na biblioteca Scopus para busca de artigos e publicações de modo a gerar uma interseção entre<br>
população e intervenção.<br>
• População: publicações que fazem referência a verificação de propriedades de circuitos<br>
lógicos e sinônimos:<br>
– Palavras-chaves: "circuit checker" OR "circuit verification" OR "contract based<br>
verification" OR "code analysis" OR "static analysis" OR "dynamic analysis" OR<br>
"safety verification" OR "RTL analysis" OR "program analysis" OR "property veri-<br>
fication" OR "formal verification" OR "model checking" OR "model checker" OR<br>
"hardware checker" OR "hardware verification" OR "validity checker" OR "hard-<br>
ware assertion" OR "assertion checker" OR "assert verification" OR "assertion-based<br>
verification" OR "assertion based verification" OR "assertion-based design" OR "bit<br>
level verification"<br>
• Intervenção: Verificação de circuitos e sinônimos:<br>
– Palavras-chaves:"hardware statement" OR "hardware code" OR "hardware source<br>
code" OR "hardware semantics" OR "hardware property" OR "logical gates" OR<br>
"sequential circuit" OR "parallel circuit" OR "real circuits" OR "complex circuits"<br>
OR "control circuitry" OR ”software netlist” OR “hardware emulation” OR “silicon<br>
debug”<br>
3.1.1.1 Procedimentos de Seleção e Critérios<br>
A estratégia de busca será aplicada por um pesquisador para identificar as publicações<br>
em potencial. A seleção das publicações dar-se-á em 2 etapas, conforme apresentado a seguir.<br>
1. Seleção e catalogação preliminar dos dados coletados: A seleção preliminar das publi-<br>
cações será feita a partir da aplicação da string de busca na biblioteca Scopus, o resultado<br>
desta busca corresponde a seleção preliminar. Todas as publicações serão armazenadas<br>
para análise posterior;<br>
2. Seleção dos dados relevantes - [1 filtro]: A seleção preliminar com o uso da expressão<br>
de busca não garante que todo o material coletado seja útil no contexto da pesquisa, pois a<br>
aplicação das expressões de busca é restrita ao aspecto sintático. Por isso, é necessário a<br>
criação de filtros de exclusão e inclusão, de modo a classificar os artigos e publicações que<br>
se enquadram no contexto da pesquisa realizada. Nesta epata apenas serão lidos o título,<br>
abstracts, e palavras-chaves e classificar de acordo com os filtros, ou seja, se será aceito ou<br>
excluído. Devem ser excluídas as publicações contidas no conjunto preliminar que:<br>
Chapter 3. TRABALHOS CORRELATOS 36<br>
• CE1-01: Não serão selecionadas publicações em que as palavras-chave da busca<br>
não apareçam no título, resumo e/ou texto da publicação (excluem-se os seguintes<br>
campos: as seções de agradecimentos, biografia dos autores, referências bibliográficas<br>
e anexas).<br>
• CE1-02: Não serão selecionadas publicações em que descrevam e/ou apresentam<br>
‘keynote speeches’, tutoriais, cursos e similares.<br>
• CE1-03: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação/validação de códigos para descrição de hardware.<br>
• CE1-04: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação de código de descrição de hardware baseado em assertivas ou propriedades<br>
de verificação de hardware.<br>
Podem ser incluídas apenas as publicações contidas no conjunto preliminar que:<br>
• CI1-01:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita uma abordagem para verificação<br>
de código de descrição de hardware baseado em assertivas ou propriedades de<br>
verificação de hardware.<br>
• CI1-02:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita recomendações de melhoria<br>
na utilização de abordagens para verificação de código de descrição de hardware<br>
baseado em assertivas ou propriedades de verificação de hardware.<br>
3. Seleção dos dados relevantes - [2 filtro]: Apesar do 1o filtro limitar o universo de busca,<br>
infelizmente não há garantias de que todo material selecionado no filtro anterior seja útil<br>
no contexto da pesquisa. Neste caso, novos filtros são gerados, buscando, da mesma forma<br>
que o primeiro filtro, classificar os artigos e publicações que se enquadram no contexto<br>
da pesquisa. Para este filtro é necessário a leitura na integras dos artigos selecionados<br>
anteriormente. O objetivo é identificar que relacionam assertivas e/ou propriedade de<br>
verificação de hardware.<br>
• CS2 -ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware e não citam assertivas<br>
• CS2 +ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware, mas citam assertivas<br>
• CS2 -ASS +VER_HARD: Não devem ser selecionadas publicações que contextual-<br>
izam verificação de hardware, mas citam assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 37<br>
Dessa forma, todas as publicações devem respeitar o critério abaixo:<br>
• CS3 +ASS +VER_HARD: Serão selecionadas publicações que contextualizam<br>
verificação de hardware e citam assertivas em seu contexto.<br>
Devido ao tempo necessário para o desenvolvimento execução dos filtros da revisão<br>
sistemática serem extensos, apenas o primeiro filtro foi executado neste projeto, mesmo que<br>
os parâmetros para o segundo filtro já tenho sido desenvolvidos. Em contra partida foram<br>
selecionados 6 artigos que serviram como ferramentas de estudo para o desenvolvimento da<br>
metodologia que será apesentada no Capítulo 4.<br>
3.2 Revisão da literatura<br>
Nesta sessão serão apresentados trabalho relevantes para o desenvolvimento do método<br>
proposto que foram identificados utlizando a revisão sistemática mencionado anteriormente.<br>
Os artigos apresentam técnicas de transformações de código, utilização de Assertion-Based<br>
Verification e PSL para verificação de hardware.<br>
3.2.1 V2c-A verilog to C translator<br>
O artigo de MUKHERJEE et al. apresenta uma ferramenta implementada em C++<br>
chamada v2c para transformação de código da linguagem de descrição Verilog para linguagem<br>
de programação C. A ferramenta é executada a nível de palavra, visto que esta abordagem garante<br>
uma aumento na escalabilidade, mas também proporionando que técnicas, como interpolaçãoe adicionar<br>
refer-<br>
ência<br>
aceleração de looppossam ser utilizadas para verificação, algo inviavél, caso a tradução fosse<br>
adicionar<br>
refer-<br>
ência<br>
executada a nível de bit. O sistema recebe como entrada um código em Verilg, onde são aplicadas<br>
regras semânticas e mapeando os bit de operação, chamado software netlist. Após isso, o código<br>
intermediário é convertido para C.<br>
A contribuição deste trabalhoconsiste na utilização de transformações de código como<br>
Qual<br>
tra-<br>
balho?<br>
base principal e partindo deste pressuposto torna-se vantajoso devido a utilização de outras<br>
ferramentas que não apresente suporte a certas linguagens, tais com a ferramenta ESBMC,<br>
utilizada neste trabalho, não apresenta suporte a VHDL, porém apresenta suporte as linguagens<br>
C/C++. Em outras palavras, a contribuição deste trabalhofoi a utilização de traduções de códigos<br>
Qual<br>
tra-<br>
balho?<br>
e utilizado este conceito como modelo de entrada para analise de circuitos.<br>
3.2.2 Unbounded safety verification for hardware using software ana-<br>
lyzers<br>
No artigo de MUKHERJEE et al. foi apresentado uma metodologia que aborda a utiliza-<br>
ção de técnicas e analisadores de software, com o objetivo de de abordar a análise de circuitos e<br>
Chapter 3. TRABALHOS CORRELATOS 38<br>
com isso trançar um paralelo entre as abordagens. Para testes foram utilizadas três metodologias<br>
de análise, usando interpolação, k-inductione tecnologias hibrídas. Como resultante dos testes, foi adicionar<br>
refer-<br>
ência<br>
adicionar<br>
refer-<br>
ência<br>
observado as principais causas de erros, por exemplo, bits não preciso e no caso das operações<br>
a bit-level ocorria perda de informações. Também foi obeservado que apesar de não serem<br>
otimizadas para análises de hardware, alguns analisadores de softaware podem, dependendo da<br>
técnica utilizada no analisador, ser utilizada para analise de hardware.<br>
Descrever<br>
qual<br>
o mo-<br>
tivo.<br>
A utilização de técnicas de análise de software para o desenvolvimento de análise de<br>
hardware é o foco a ser abordado neste neste trabalho de maneira prática, utilizando os princípio<br>
analisados por (MUKHERJEE et al., 2016a). Neste contexto, o objetivo deste trabalho é a<br>
utilização de técnicas de software para análise de circuitos, diferente do artigo apresentado acima<br>
que busca utilização uma abordagem mais complexa provando a possibilidade da utilização de<br>
técnicas de analise de software no contexto da verificação de hardware.<br>
A última frase está confusa, no meu entedimento é o mesmo sentido.<br>
3.2.3 Formal verification of timed VHDL programs<br>
No trabalho apresentado por BARA et al. é proposto uma abordagem para a análise<br>
de tempo relacionado a cada porta lógica dentro de um dado circuito analisado. A abordagem<br>
apresenta a tradução de um circuito lógico codificado em VHDL para um formalismo baseado<br>
em automato de tempo. Tal formalismo é representado por uma automato de estados finitos referência<br>
com relogios simbólicos que evoluem em taxa uniforme. A tradução é executada de modo<br>
automatico, baseado na emulação da propagação de cada transação ao longo de cada sinal, o<br>
seja, são automatos programados e cronometrados do circuito. Após a tradução para automato, a<br>
analise é feita pela ferramenta UPPALque é um model checking de verificação de propriedades referência<br>
de tempo. Seguindo esta metodologia a análise pode ser extraida de modo independente de cada<br>
bloco, desta forma a análise é feita de forma mais precisa, podendo ser analisado inumeros<br>
fatores, tais como limites de intervalo e sinal de correlação.<br>
O artigo apresenta uma abordagem de tempo, que torna-se interessante adição ao método.<br>
Porém até o momento a função não foi implementada ficando a trabalho futuros.<br>
Expandir o texto acima, exemplo, descrever como o método poderia ser incluindo no seu<br>
TCC.<br>
3.2.4 On the use of assertions for embedded-software dynamic verifica-<br>
tion<br>
Em GUGLIELMO et al. é apresentado uma metodologia para a integração dinamica de<br>
Assertion-Based Verification para várias fases da análise da verificação de fluxo em sistemas<br>
embarcados, por exemplo, emulação, diagnosticos e Debug, mas também um ferramenta chamada<br>
Chapter 3. TRABALHOS CORRELATOS 39<br>
RadCheck. O metodo de aplicação, chamado V-model é dividido em fases de verificação em<br>
paralelo com as fases de design do circuito. Com base no V-model, o método é aplicado, iniciando<br>
com o nível de sistema e as especificação do sistema, neste caso especificado usando PSL.<br>
Neste nível é especificado todas as funcionalidades gerais da aplicação. No nível de integração<br>
visa investigar problemas de interação que possam ocorrer, definindo propriedades que cobrem<br>
incrementalmente as unidades estruturais interativas de aplicação. No nível de unidade descrevem<br>
comportamentos internos e são definidas através de parâmetros de entrada/saída das unidade e<br>
estruturas de dados internas.<br>
A contribuição deste projeto está relacionado a utilização de assertivas no contexto da<br>
verificação de software. As assertivas são o principal meio de análise proposto neste projeto,<br>
visto que estas mesma assertivas serão analisadas pelo ESBMC. Aliado a isso em GUGLIELMO<br>
et al. é apresentado modelos de utilização de assertivas no processo de verificação de hardware,<br>
e tais assertivas foram adaptadas para um modelo proposto neste trabalho.<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation<br>
No trabalho de BOULE; ZILIC é apresentado uma ferramenta de geração de assertivas<br>
no contexto da emulação de circuitos, de modo que estas assertivas descrita em PSL possam<br>
transformadas para o modelo de linguagem de descrição de hardware. Inicialmente é realizada<br>
toda análise de cada assertiva e a mesma é traduzida em partes, levando em consideração os<br>
operadores e cada estrutura, por exemplo if-else, utilizado na declaração da assertiva.<br>
Apresentar um exemplo para explicar o texto acima<br>
trabalho de BOULE; ZILIC consolida e apresenta aspectos importantes, tais como a<br>
utilização de uma ferramenta para geração de assertivas, o que torna-se no contexto deste projeto,<br>
extremamente importante, visto que o modelo adotado atualmente consiste tanto na geração<br>
automática das assertivas, bem como a inserção manual por parte do usuário.<br>
40<br>
4 MÉTODO PROPOSTO<br>
Este Capítulo descreve o método proposto neste trabalho, baseado transformações de<br>
código para análise de circuitos lógicos descritos em VHDL utilizando Bounded Model Checking,<br>
neste caso o model checker ESBMC.<br>
4.1 Visão geral do método<br>
O método proposto consiste inicialmente em receber como entrada um circuito lógico<br>
descrito em VHDL, onde uma dada propriedade representada em uma assertiva será analisada,<br>
as assertivas serão inseridas de automaticamente pelo método ou pelo próprio usuário do método.<br>
O código VHDL analisado posteriomente é traduzido para linguagem C e recebe uma instrumen-<br>
tação de código (com funções especificas suportadas pelo método) para a posterior validação do<br>
mesmo. O Código em C automaticamente gerado, já instrumentado, será processado e analisado<br>
pelo ESBMC de acordo com as assertivas inseridas e ao final é apresentado o resultado. Caso<br>
alguma das assertivas seja violada, um contra-exemplo é apresentado ao usuário. Uma visão<br>
geral do método proposto é apresentado na Figura 16 e nas sessões a seguir serão apresentados<br>
cada etapa do método proposto neste trabalho.<br>
Figure 16 – Ciclo da ferramenta<br>
Fonte: Própria<br>
Com o intuito de auxiliar nas explicações apresentadas nas próximas sessões, o código<br>
na Figura 17 será utilizado nas explanações, bem como será apresentado todas as alterações do<br>
mesmo, conforme cada etapa do método.<br>
Chapter 4. MÉTODO PROPOSTO 41<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 ENTITY U l a _ t c c IS<br>
5 PORT(A, B , B i n v e r t i d o , Op1 , Op2 : IN BIT ;<br>
6 R e s u l t a d o :OUT BIT ) ;<br>
7 END U l a _ t c c ;<br>
8<br>
9 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
10 SIGNAL a n d _ p o r t : b i t ;<br>
11 SIGNAL o r _ p o r t : b i t ;<br>
12 SIGNAL x o r _ p o r t : b i t ;<br>
13 SIGNAL mux2x1 : b i t ;<br>
14 BEGIN<br>
15 PROCESS(A, B , B i n v e r t i d o , Op1 )<br>
16 BEGIN<br>
17 ??PORTA AND<br>
18 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
19 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
20 ELSE<br>
21 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
22 END IF ;<br>
23 ??PORTA OR<br>
24 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
25 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
26 ELSE<br>
27 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
28 END IF ;<br>
29 ??PORTA XOR<br>
30 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
31 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
32 ELSIF (A = ’ 1 ’ and mux2x1 = ’ 1 ’ ) THEN<br>
33 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
34 ELSE<br>
35 x o r _ p o r t &lt;= ’ 1 ’ ;<br>
36 END IF ;<br>
37 ??INVERSOR<br>
38 IF ( B i n v e r t i d o = ’ 0 ’ ) THEN<br>
39 mux2x1 &lt;= B ;<br>
40 ELSE<br>
41 mux2x1 &lt;= NOT B ;<br>
42 END IF ;<br>
43 ??MUX4X1<br>
44 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
45 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
46 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
47 R e s u l t a d o &lt;= o r _ p o r t ;<br>
48 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
49 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
50 END IF ;<br>
51 END PROCESS ;<br>
52 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 42<br>
4.2 Preprocessamento do VHDL e inserção de assertivas<br>
A fase inicial do método consiste no preprocessamento do código VHDL com as an-<br>
otações de código pelo usuário ou pelo método proposto de forma automática, incluindo as<br>
assertivas, conforme a Figura 16, na etapa A. O método não realiza qualquer tipo de verificação<br>
sobre o código VHDL, apenas utiliza o mesmo como entrada juntamente com as assertivas<br>
inseridas. Toda verificação é realizada sobre o código em linguagem C, que será traduzido a<br>
partir do código VHDL analisado, nas próximas etapas do método proposto. Vale ressaltar que<br>
mesmo a linguagem VHDL tendo um modelo de assertivas padrão, para o método tornou-se<br>
necessário a criação de um modelo (baseado em comentários) para que as funções do model<br>
checker adotado fossem suportadas, como a geração de valores não deterministicos.<br>
As assertivas manuais são adicionadas entre as tags @c2vhdl:ASSERT e @c2vhdl:END<br>
e todo trecho de código entre estas tags deve estar comentado, desta forma não apresentará<br>
erro na tradução do código em linguagem C, bem como na sintetização do código VHDL. Nas<br>
assertivas são incluidas as funções necessárias para a análise utilizando a ferramenta ESBMC. A<br>
assertiva apresenta três informações principais, sendo elas: condição, mensagem e gravidade.<br>
Ajustar está assertiva. Para quem não vê o código todo, ela não faz sentido<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR.<br>
1 ??@c2vhdl : ASSERT<br>
2 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ )<br>
3 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 "<br>
4 ??s e v e r i t y ERROR;<br>
5 ??@c2vhdl :END<br>
Fonte: Própria.<br>
A condição (na linha 2 da Figura 19) representa a assertiva propriamente dita e que será<br>
analisado pela aplicação. A condição será precedida de??assert e seguido ou não da palavra<br>
not, com isso a assertiva pode assumir valor negativo, conforme necessidade do usuário. Na<br>
Figura 19 a assertiva busca verificar se a variavél Resultado terá valor igual a 1. Qual a<br>
razão<br>
para<br>
isso,<br>
ex-<br>
plique!<br>
A mensagem (??report na linha 3 da Figura 19) é definida pelo usuário e será<br>
apresentado caso a assertiva apresente falha, assim a mensagem pode ser utilizada como um meio<br>
de depuração das propriedades validadas. A severidade (severity na linha 4 da Figura 19)<br>
pode ser definida como error, que representa um erro fatal e parada da verificação. A severidade<br>
do tipo warning que representa um erro não fatal, contabiliza as falhas das assertivas, porém<br>
não causa a parada da verificação. As mensagens futuramente pode ser integradas um framework<br>
para teste de unidade, contudo está é uma etapa ainda em planejamento neste trabalho.<br>
Juntamente com as assertivas outra função que pode ser utilizada é a função __ESBMC<br>
Chapter 4. MÉTODO PROPOSTO 43<br>
_assume() suportada pelo model checker ESBMC. Esta função utilizada em conjuto com a<br>
ferramenta ESBMC permite que durante a verificação uma variavél possa ter uma valor setado<br>
durante o tempo de execução da verificação. A importância desta função é fazer verificações onde<br>
se conhece os valores de entrada juntamente com o valor resultante, por exemplo, na verificação<br>
de portas lógicas.<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume().<br>
1 ??__ESBMC_assume (A = ’ 1 ’ )<br>
2 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
Fonte: Própria.<br>
A assertivas que serão verificadas são automáticas traduzidas a partir das entradas do<br>
código VHDL. Seja no modelo manual (assertivas escritas pelo usuário) ou automático (inferidas<br>
pelo método proposto por meio de análise estática), as entradas são mapeadas para serem<br>
utilizados na etapa de instrumentação. Desta forma, tais entradas podem ser utilizadas para gerar<br>
essas assertivas e então serem adicionadas diretamente ao código em linguagem C durante a fase<br>
de instrumentação.<br>
A Figura 20 apresenta o código juntamente com as assertivas conforme o padrão salien-<br>
tado na section 4.2. Neste exemplo foi implementado utilizado a inserção manual das assertivas<br>
e também da função __ESBMC_assume(), entretanto o objetivo é automatizar estas funções<br>
durante a execução da ferramenta.<br>
4.3 Tradução de código VHDL para a linguagem C<br>
Nesta etapa a tradução do código VHDL para linguagem C é executada, conforme<br>
apresentado na Figura 16, etapa B. A partir deste ponto, a ferramenta é executada de maneira<br>
propriamente dita, tendo todo o processo automatizado até a apresentação do resultado. Para<br>
esta etapa do método foi selecionado a ferramenta V2Cque realiza a tradução de VHDL para Adicionar<br>
refer-<br>
ência<br>
Linguagem C.<br>
A ferramenta V2C apresenta diversas vantagens em relação a equivalência de tradução<br>
de linguagens, contudo V2C apresenta certas limitação na tradução do código VHDL, em outras<br>
palavras, a mesma não reconhece algumas estruturas especificas do VHDL. A ferramenta aceita<br>
apenas entradas e saídas do tipo: bit, std_ulogic, qsim_state, std_ulogic_vector<br>
e interger. Na parte de arquitetura, a ferramenta aceita uma gama maior de estruturas, tra-<br>
balhando com expressoões do tipo: signal, variable, integers, strings e caracteres.<br>
Em expreções condicionais os operandos são AND, OR, NOT &lt;=, =&gt;,=,&lt;,&gt; e &lt;&gt;. Aceita<br>
também a estrutura de process, além da estutura block. A estrutura process é limitada<br>
Chapter 4. MÉTODO PROPOSTO 44<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 . . .<br>
4 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
5 SIGNAL a n d _ p o r t : b i t ;<br>
6 SIGNAL o r _ p o r t : b i t ;<br>
7 SIGNAL x o r _ p o r t : b i t ;<br>
8 SIGNAL mux2x1 : b i t ;<br>
9 BEGIN<br>
10 PROCESS(A, B , B i n v e r t i d o , Op1 ) IS<br>
11 BEGIN<br>
12 ??PORTA AND<br>
13 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
14 ??__ESBMC_assume (A = ’ 1 ’ )<br>
15 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
16 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
17 ELSE<br>
18 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
19 END IF ;<br>
20 . . .<br>
21 ??MUX4X1<br>
22 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
23 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
24 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
25 R e s u l t a d o &lt;= o r _ p o r t ;<br>
26 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
27 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
28 ??@c2vhdl : ASSERT<br>
29 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
30 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
31 ??s e v e r i t y ERROR;<br>
32 ??@c2vhdl :END<br>
33 END IF ;<br>
34 END PROCESS ;<br>
35 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
apenas a: if-else, case e loops. Como trabalho futuro, neste trabalho tem-se buscado<br>
novas abordagens para ampliar o suporte a estruturas não suportadas pelo V2C.<br>
Na tradução é necessário substituir os operadores originais por seus equivalentes em<br>
linguagem C. A excessão são os operadore específicos que gerenciam os valores de bit, tais<br>
como concatenação ou manipulação de partes vertoriais, para os quais são necessários construir<br>
procedimentos especificos em C.<br>
Conforme mostrado na Figura 21, na tradução são gerados vários vetores para suporte<br>
a tradução dos sinais representados no VHDL, sendo eles chg[], old[] e new[]. O vetor<br>
old[] contém o valor do sinais do passo anteriore a partir deste vetor o valor a ser usado nos Confuso<br>
issocálculo é obtido. O vetor new[] representa os novos valores a serem calculados pelos antigose<br>
Qual?<br>
Chapter 4. MÉTODO PROPOSTO 45<br>
o vetor chg[] contém um or exclusivo entre o valor novo e antigo e em caso de alteração entre<br>
os valores é copiado o valor de new[] para old[].<br>
O texto acima está muito confuso, corrigi rapidamente<br>
No código C gerado, os vetores in_data[] e out_data[] contêm os sinais de<br>
entrada e saída, respectivamente. No caso de circuitos sequênciais, o valor do status é inserido<br>
no primeiro (índice 0). A funçãoentão lerá os valores in_data[] e escreverá os resultados do qual?<br>
processamento em out_data[]. Ao final da operações os valores de estado são passado para<br>
out_data[].<br>
Conforme especificado e seguindo os parametros da ferramenta, a mesma realiza a<br>
tradução, mantendo inalterado qualquer fragmento de código que esteja comentado, neste caso,<br>
as assertivas presentes no código VHDL permanecem inalteradas, sendo utilizadas na próxima<br>
etapa do método proposto.<br>
4.4 Instrumentação de código<br>
As assertivas após a tradução permanecem comentadas, sendo necessário prepara-lás, ou<br>
seja traduzi-las, para verificação posterior do código na linguagem em C. Com isso é necessário<br>
uma instrumentação do código para prover suporte as assertivas traduzidas para análise, conforme<br>
apresentado na Figura 16, etapa C.<br>
Todas as etapas da instrumentação são realizados sobre o código C já traduzido. O passo<br>
inicial da instrumentação é a adição da macros no inicio do código C com as definição das<br>
assertivas a serem utilizadas. Na Figura 22 são apresentados os macros utilizadas no código C. A<br>
Linha 1 da figura corresponde a mensagem de erro a ser apresentada e a Linha 2 corresponde<br>
ao modelo da assertiva e a chamanda da macro definida na Linha 1 em caso de falha. Estas<br>
definições para as assertivas também podem ser utilizadas no código C traduzidos sem o uso do<br>
ESBMC.<br>
Figure 22 – Macros das assertivas implementadas em linguagem C<br>
1 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r ,M, __FILE__ , __LINE__ , # # __VA_ARGS__ )<br>
2 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
Fonte: Própria.<br>
O passo seguinte é a identificação das assertivas comentadas ao longo do corpo do<br>
código traduzido, utilizando o exemplo da Figura 23. As assertivas são identificadas através<br>
das tags @c2vhdl:ASSERT e @c2vhdl:END e a busca é realizado através destas tags. Ao<br>
ser encontrado a tag @c2vhdl:ASSERT, é realizado um loop até que seja encontrada a tag<br>
Chapter 4. MÉTODO PROPOSTO 46<br>
@c2vhdl:END e com isso toda a assertiva inserida possa ser passada a função de busca das<br>
informações da assertiva contidas entre as tags apresentadas.<br>
Com os dados das assertivas obtidos é realizado a busca da condição, mensagem e<br>
severidade através dos comandos ??assert, ??report e ??severity respectivamente.<br>
Estas informações são encontradas através do uso e uma Regex no código e que são adicionadas<br>
ao código C seguindo o modelo definido na macro. Este processo é repetido até outra assertiva<br>
ser encontrada ou caso chegue ao fina do código C.<br>
Com a função __ESBMC_assume() ocorre processo semelhante ao das assertivas.<br>
Utilizando novamente uma regex que realiza a busca por esta função no código e é retirado o<br>
comentário da mesma, desta forma a mesma passa a esta acessivél para o ESBMC, visto que a<br>
declaração da mesma já segue o modelo padrão a ser utilizado pelo ESBMC.<br>
Durante a instrumentação de código também é realizado a entrada de sinais não de-<br>
terministicos para variaveis não inicializadas ou argumentos de funções do código C gerado<br>
da tradução, utilizando a função __VERIFIER_nondet_int(). Esta função é utilizada em<br>
todas as variaveis de entrada e também nos sinais criados ao longo da arquitetura. Desta forma,<br>
todas as variavéis necessárias são inicializadas para verificação.<br>
Explicar o funcionamento do nondet com o ESBMC<br>
Em outras palavras, na instrumentação de código é realizado a traduçao das assertivas do<br>
modelo utilizado no código VHDL para para o modelo utilizado em linguagem C, além como de<br>
outras funções que possam ser utilizados pelo VHDL. Ao final da instrumentação o código C<br>
fica disponivel para que possa ser dado como entrada para outras ferramentas de verificação de<br>
código e não apenas o ESBMC.<br>
4.5 Verificação de assertivas usando Model Checker<br>
O model checker adotado no desenvolvimento de método é o ESBMCna versão 3.0.0 referência<br>
e conforme explicado na subsection 2.2.3, esta ferramenta recebe como entrada um código C<br>
ou C++ e devido a isso foi escolhida neste projeto. Nesta seção será apresentado a etapa D do apresentar<br>
outras<br>
vanta-<br>
gens<br>
métod proposto na Figura 16.<br>
Para a verificação, a primeira etapa é a identificação das assertivas no código C analisado,<br>
para isso é utilizado uma opção do ESBMC (??show-claims), mais especificamente as<br>
assertivas instrumentadas no código C analisado. Cada assertiva é identificada através de uma<br>
numeração de acordo com a ordem de busca do código analisado. Cada assertiva encontrada é<br>
armazenada para que seja realizada uma análise individual de cada claim, ou seja, assertiva.<br>
Chapter 4. MÉTODO PROPOSTO 47<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas.<br>
1 VAR<br>
2 c o n t a d o r : i n t e i r o<br>
3 c l a i m : l i s t a<br>
4 c l a i m _ s t r i n g : s t r i n g<br>
5<br>
6 FUNCAO c a l l _ e s b m c : a r q u i v o<br>
7 c o n t a d o r &lt;?0<br>
8 INICIO<br>
9 s a i d a &lt;?f un ca o de g e r a c a o das c l a i m s p e l o ESBMC<br>
10 ENQUANTO c o n t a d o r &lt; s a i d a FACA<br>
11 c o n t a d o r +=2<br>
12 r e g e x p a r a p r o c u r a r c l a i m e numeracao da c l a i m<br>
13 SE e n c o n t r a r c l a i m ENTAO<br>
14 r e g e x p a r a p r o c u r a r a p a l a v r a " a s s e r t i o n "<br>
15 SE e n c o n t r a r a p a l a v r a " a s s e r t i o n " ENTAO<br>
16 c o n t a d o r +=1<br>
17 A d i c i o n a a numeracao da c l a i m na l i s t a<br>
18 FIM?SE<br>
19 FIM?SE<br>
20 FIM?ENQUANTO<br>
21 FIM?FUNCAO<br>
Fonte: Própria.<br>
Na Linha 9 da Figura 24 é apresentado a chamada da ferramenta ESBMC que ocorre e<br>
através da opção ??show-claims lista todas as claims presentes no texto, como apresentado<br>
na Figura 25. Como o ESBMC infere de forma automatica assertivas a serem verificadas no<br>
código. Visando isolar somente as assertivas instrumentadas pelo método proposto, juntamente<br>
com a opção –show-claims é utilizado as opções:<br>
• ??no-pointer-check: para não realizar a checagem de ponteiros no código;<br>
• ??no-div-by-zero-check: para não realizar a checagem de divisões por zero no<br>
código; e<br>
• ??no-bounds-check: para não realizar a checagem de array bounds no código.<br>
Chapter 4. MÉTODO PROPOSTO 48<br>
Figure 25 – Imagem de claims contendo assertivas.<br>
Fonte:Própria<br>
Após a listagem das claims com assertivas ser gerada, outra função, indicada na Figura 26,<br>
é chamada para verificação de cada claim individualmente. Para cada claim, ocorre a chamada do<br>
ESBMC, utilizando as opções ??no-pointer-check, ??no-div-by-zero-check e<br>
??no-bounds-check, juntamente com a opção ??unwind em que realiza o número de<br>
desdobramentos dos laços no código analisado.<br>
Contudo, dependendo da complexidade da assertiva, faz-se necessário aumentar o número<br>
de desdobramentos que, por padrão são dez, conforme análise experimentais. A função é chamada<br>
na Linha 11 da Figura 26 e após a analise da claim é realizado a busca do resultado e exibição<br>
caso seja uma propriedade violada.<br>
Desta forma o ESBMC realiza apenas a checagem necessária dentro da assertiva, evitando<br>
que outros parâmetros sejam verificados, sem a devida necessidade do mesmo. Ao final de todos<br>
os desdobramentos é apresentado o resultado, apresentado na Figura 27, sendo positiva (sem<br>
erros) ou negativa (com violação de propriedades), dependendo da assertiva e do código analisado.<br>
Este processo se repete até a lista de assertivas ser finalizada.<br>
Chapter 4. MÉTODO PROPOSTO 49<br>
Figure 26 – Pseudocódigo da função de análise das claims.<br>
1 VAR<br>
2 c o n t a d o r 1 : i n t e i r o<br>
3 c o n t a d o r 2 : i n t e i r o<br>
4 r e s u l t a d o : l i s t a<br>
5<br>
6 FUNCAO esbmc_c la ims : l i s t a , a r q u i v o<br>
7 c o n t a d o r 1 &lt;?0<br>
8 c o n t a d o r 2 &lt;?0<br>
9 busca p e l o nome da fu nc a o no a r q u i v o<br>
10 ENQUANTO c o n t a d o r &lt; l i s t a FACA<br>
11 s a i d a &lt;?Execu ta comando de a n a l i s e da c l a i m<br>
numerada na l i s t a<br>
12 ENQUANTO c o n t a d o r 2 &lt; s a i d a<br>
13 Regex busca se a p r o p r i e d a d e f o i v i o l a d a<br>
14 SE p r o p r i e d a d e f o i v i o l a d a ENTAO<br>
15 Pu la p a r a l i n h a da v i o l a ç ã o<br>
16 A d i c i o n a o e r r o ao r e s u l t a d o<br>
17 FIM?SE<br>
18 FIM?ENQUANTO<br>
19 FIM?ENQUANTO<br>
20 FIM?FUNCAO<br>
Fonte: Própria.<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta.<br>
Fonte:Própria<br>
Ajustar os códigos, alguns estao muito grandes e com trechos desnecessário, não foi<br>
citado o link do repo da ferramenta<br>
Chapter 4. MÉTODO PROPOSTO 50<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C.<br>
1 void u l a _ t c c ( i n t i n _ d a t a [ ] , i n t o u t _ d a t a [ ] )<br>
2 {<br>
3 i n t _ i _ =0;<br>
4 i n t _c on t_ ;<br>
5 enum s e g n a l e {A, B , B i n v e r t i d o , Op1 , Op2 , R e s u l t a d o , and_po r t , o r _ p o r t ,<br>
6 x o r _ p o r t , mux2x1 , _MAX_} ;<br>
7 i n t o l d [_MAX_ ] ;<br>
8 i n t new [_MAX_ ] ;<br>
9 i n t chg [_MAX_ ] ;<br>
10 new [A] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
11 new [B] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
12 new [ B i n v e r t i d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
13 new [ Op1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
14 new [ Op2 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
15 new [ R e s u l t a d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
16 new [ a n d _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
17 new [ o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
18 new [ x o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
19 new [ mux2x1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
20<br>
21 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
22 {<br>
23 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
24 }<br>
25 new [A] = i n _ d a t a [ 1 ] ;<br>
26 new [B] = i n _ d a t a [ 2 ] ;<br>
27 new [ B i n v e r t i d o ] = i n _ d a t a [ 3 ] ;<br>
28 new [ Op1 ] = i n _ d a t a [ 4 ] ;<br>
29 new [ Op2 ] = i n _ d a t a [ 5 ] ;<br>
30<br>
31 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
32 {<br>
33 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
34 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
35 }<br>
36<br>
37 do {<br>
38 _ co n t _ =0;<br>
39 /? S t a r t o f T r a n s l a t i o n ? /<br>
40<br>
41 /? p0 : ? /<br>
42 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
43 /?PORTA AND ? /<br>
44 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
45 \ \ __ESBMC_assume ( o l d [A] = 1) ;<br>
46 \ \ __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
47 new [ a n d _ p o r t ] = 1 ;<br>
48 }<br>
49 e l s e {<br>
50 new [ a n d _ p o r t ] = 0 ;<br>
51 }<br>
52 /?PORTA OR ? /<br>
53 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
54 new [ a n d _ p o r t ] = 0 ;<br>
55 }<br>
56 e l s e {<br>
57 new [ a n d _ p o r t ] = 1 ;<br>
58 }<br>
59 /?PORTA XOR ? /<br>
60 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
61 new [ x o r _ p o r t ] = 0 ;<br>
62 }<br>
63 e l s e i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==1) ) {<br>
64 new [ x o r _ p o r t ] = 0 ;<br>
65 }<br>
66 e l s e {<br>
67 new [ x o r _ p o r t ] = 1 ;<br>
68 }<br>
69 /? INVERSOR ? /<br>
70 i f ( ( o l d [ B i n v e r t i d o ]==0) ) {<br>
71 i f ( chg [B ] ) {<br>
72 new [ mux2x1 ]= o l d [B ] ;<br>
73 }<br>
74 }<br>
75 e l s e {<br>
76 i f ( chg [B ] ) {<br>
77 new [ mux2x1 ]=~ o l d [B ] ;<br>
78 }<br>
79 }<br>
80 /?MUX4X1 ? /<br>
81 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
82 i f ( chg [ a n d _ p o r t ] ) {<br>
83 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
84 \ \ @c2vhdl : ASSERT<br>
85 \ \ a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
86 \ \ r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
87 \ \ s e v e r i t y ERROR;<br>
88 \ \ @c2vhdl :END<br>
89 }<br>
90 }<br>
91 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
92 i f ( chg [ o r _ p o r t ] ) {<br>
93 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
94 }<br>
95 }<br>
96 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
97 i f ( chg [ x o r _ p o r t ] ) {<br>
98 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
99 }<br>
100 }<br>
101 }<br>
102<br>
103 /? End o f T r a n s l a t i o n ? /<br>
104 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
105 {<br>
106 i f ( new [ _ i _ ] ! = o l d [ _ i _ ] ) _ con t_ =1;<br>
107 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
108 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
109 }<br>
110 } whi le ( _c on t_ ) ;<br>
111<br>
112 new [A] &= 0X01 ;<br>
113 new [B] &= 0X01 ;<br>
114 new [ B i n v e r t i d o ] &= 0X01 ;<br>
115 new [ Op1 ] &= 0X01 ;<br>
116 new [ Op2 ] &= 0X01 ;<br>
117 new [ R e s u l t a d o ] &= 0X01 ;<br>
118 new [ a n d _ p o r t ] &= 0X01 ;<br>
119 new [ o r _ p o r t ] &= 0X01 ;<br>
120 new [ x o r _ p o r t ] &= 0X01 ;<br>
121 new [ mux2x1 ] &= 0X01 ;<br>
122<br>
123 o u t _ d a t a [ 0 ] = 0 ; _ i _ =0;<br>
124 o u t _ d a t a [ 0 ] | = new [A] &lt;&lt; _ i _ ; _ i _ +=1;<br>
125 o u t _ d a t a [ 0 ] | = new [B] &lt;&lt; _ i _ ; _ i _ +=1;<br>
126 o u t _ d a t a [ 0 ] | = new [ B i n v e r t i d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
127 o u t _ d a t a [ 0 ] | = new [ Op1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
128 o u t _ d a t a [ 0 ] | = new [ Op2 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
129 o u t _ d a t a [ 0 ] | = new [ R e s u l t a d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
130 o u t _ d a t a [ 0 ] | = new [ a n d _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
131 o u t _ d a t a [ 0 ] | = new [ o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
132 o u t _ d a t a [ 0 ] | = new [ x o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
133 o u t _ d a t a [ 0 ] | = new [ mux2x1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
134<br>
135 o u t _ d a t a [ 1 ] = new [ R e s u l t a d o ] ;<br>
136 }<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 51<br>
Figure 23 – Código com assertivas traduzida para linguagem C<br>
1 # inc lude &lt; s t d i o . h&gt;<br>
2 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r , M , __FILE__ , __LINE__ , ##<br>
__VA_ARGS__ ) / / Update t o p r i n t t h e t r a c e<br>
3 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
4<br>
5 . . .<br>
6<br>
7 do {<br>
8 _co n t _ =0;<br>
9 /? S t a r t o f T r a n s l a t i o n ? /<br>
10 chg [A] = __VERIFIER_nondet_int ( ) ;<br>
11 chg [B] = __VERIFIER_nondet_int ( ) ;<br>
12 chg [ B i n v e r t i d o ] = __VERIFIER_nondet_int ( ) ;<br>
13 chg [ Op1 ] = __VERIFIER_nondet_int ( ) ;<br>
14 chg [ a n d _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
15 chg [ R e s u l t a d o ] = __VERIFIER_nondet_int ( ) ;<br>
16 chg [ o r _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
17 chg [ mux2x1 ] = __VERIFIER_nondet_int ( ) ;<br>
18<br>
19 /? p0 : ? /<br>
20 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
21 /?PORTA AND ? /<br>
22 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
23 __ESBMC_assume ( o l d [A] = 1) ;<br>
24 __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
25 new [ a n d _ p o r t ] = 1 ;<br>
26 }<br>
27 e l s e {<br>
28 new [ a n d _ p o r t ] = 0 ;<br>
29 }<br>
30<br>
31 . . .<br>
32<br>
33 /?MUX4X1 ? /<br>
34 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
35 i f ( chg [ a n d _ p o r t ] ) {<br>
36 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
37 __MY_asser t ( new [ R e s u l t a d o ] == 1 , "O r e s u l t a d o é d i f e r e n t e de 0 " ) ;<br>
38 }<br>
39 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
40 i f ( chg [ o r _ p o r t ] ) {<br>
41 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
42 }<br>
43 }<br>
44 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
45 i f ( chg [ x o r _ p o r t ] ) {<br>
46 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
47 }<br>
48 }<br>
49 }<br>
50<br>
51 /? End o f T r a n s l a t i o n ? /<br>
52 . . .<br>
Fonte: Própria.<br>
52<br>
5 CRONOGRAMA<br>
53<br>
6 CONSIDERAÇÕES PARCIAIS E<br>
TRABALHOS FUTUROS<br>
O trabalho aborda o desenvolvimento de um método para análise de circuitos lógicos de-<br>
scrito em VHDL através da aplicação de técnica de transformação de código e a técnica Bounded<br>
Model Cheking. Este método tem como objetivo de explorar os estados alcanç alcançáveis no<br>
circuito, e dessa forma identificar erros que possam resutar em mal funcionamento do sistema.<br>
Entre as dificuldade encontradas, a principal esta ligada a etapa de tradução de código.<br>
Devido a ferramenta utilizada inicialmente conter diversas limitações, a mesma diminui a eficácia<br>
da ferramenta, pois a quantidade de estruturas que podem ser utilizadas é limitada e com isso<br>
limitando também o processo de criação de protótipos.<br>
Os trabalhos futuros é necessário buscar uma nova ferramenta ou método de tradução<br>
que tenha uma gama maior de tradução, seja em estruturas ou palavras reservadas,deste forma<br>
o método desenvlvido torna-se mais eficiente e gerando uma menor intervenção do usuário no<br>
código VHDL. A melhoria na tradução de código também beneficia ageração das assertivas<br>
automáticamente, pois com uma gama maior de estruturas suportadas, mais assertivas podem ser<br>
geradas.<br>
Além disso a geração automática das assertivas é Outro ponto abordado, já sitado anterior-<br>
mente, é a geração automática das assertivas, visto que na estapa atual ainda nõ foi implementado.<br>
Este recuros visa da liberdade ao desenvolvedor promovendo de maneira automática os teste<br>
sobre o código, não necessitando que uma intervenção, tornando a inserção manual apenas em<br>
casos especificos de testes.<br>
54<br>
BIBLIOGRAPHY<br>
ABE, J. Introducao a Logica Para a Ciencia Da Computacao. Arte & Ciência, 2002. ISBN<br>
9788574730455. Disponível em: &lt;https://books.google.com.br/books?id=AgBJdjoNPwUC&gt;.<br>
ACM. 2018. Acessado em: 01 de março de 2018. Disponível em: &lt;http://dl.acm.org/&gt;.<br>
AHO, A. V.; SETHI, R.; ULLMAN, J. D. Compilers: principles, techniques, and tools. [S.l.]:<br>
Addison-wesley Reading, 2007. v. 2.<br>
ALLEN, F. E. Control flow analysis. In: ACM. ACM Sigplan Notices. [S.l.], 1970. v. 5, n. 7, p.<br>
1–19.<br>
BAIER, C.; KATOEN, J.-P.; LARSEN, K. G. Principles of model checking. [S.l.]: MIT press,<br>
2008.<br>
BARA, A. et al. Formal verification of timed vhdl programs. In: IET. FDL. [S.l.], 2010. p.<br>
80–85.<br>
BASILI, V. R.; CALDIERA, G.; ROMBACH, H. D. Experience factory. Encyclopedia of<br>
software engineering, Wiley Online Library, 1994.<br>
BENSALEM, S.; LAKHNECH, Y. Automatic generation of invariants. Formal Methods in<br>
System Design, Springer, v. 15, n. 1, p. 75–92, 1999.<br>
BIERE, A. The aiger and-inverter graph (aig) format. Available at http://fmv.jku.at/aiger, 2016.<br>
BIOLCHINI, J. et al. Systematic review in software engineering. System Engineering and<br>
Computer Science Department COPPE/UFRJ, Technical Report ES, v. 679, n. 05, p. 45, 2005.<br>
BOULE, M.; ZILIC, Z. Incorporating efficient assertion checkers into hardware emulation. In:<br>
IEEE. Computer Design: VLSI in Computers and Processors, 2005. ICCD 2005. Proceedings.<br>
2005 IEEE International Conference on. [S.l.], 2005. p. 221–228.<br>
BOULE, M.; ZILIC, Z. Efficient automata-based assertion-checker synthesis of seres for<br>
hardware emulation. In: IEEE COMPUTER SOCIETY. Proceedings of the 2007 Asia and South<br>
Pacific Design Automation Conference. [S.l.], 2007. p. 324–329.<br>
BRAYTON, R.; MISHCHENKO, A. Abc: An academic industrial-strength verification tool. In:<br>
SPRINGER. Computer Aided Verification. [S.l.], 2010. p. 24–40.<br>
B.V. 2018. Acessado em 1 de março de 2018. Disponível em: &lt;http://www.sciencedirect.com/&gt;.<br>
CABODI, G. et al. Hardware model checking competition 2014: an analysis and comparison of<br>
solvers and benchmarks. Journal on Satisfiability, Boolean Modeling and Computation, v. 9, p.<br>
135–172, 2016.<br>
CAPPELATTI, D. Praticando VHDL. Editora Feevale, 2010. ISBN 9788577171200. Disponível<br>
em: &lt;https://books.google.com.br/books?id=z4\_CYog\_UskC&gt;.<br>
Bibliography 55<br>
CHRISTEN, E.; BAKALAR, K. Vhdl-ams-a hardware description language for analog and<br>
mixed-signal applications. IEEE Transactions on Circuits and Systems II: Analog and Digital<br>
Signal Processing, IEEE, v. 46, n. 10, p. 1263–1272, 1999.<br>
CHU, P. P. RTL hardware design using VHDL: coding for efficiency, portability, and scalability.<br>
[S.l.]: John Wiley & Sons, 2006.<br>
CLARKE, E. et al. Verification of hybrid systems based on counterexample-guided abstraction<br>
refinement. In: SPRINGER. TACAS. [S.l.], 2003. v. 3, p. 192–207.<br>
CLARKE, E. M. The birth of model checking. In: 25 Years of Model Checking. [S.l.]: Springer,<br>
2008. p. 1–26.<br>
CLARKE, E. M.; GRUMBERG, O.; LONG, D. E. Model checking and abstraction. ACM<br>
transactions on Programming Languages and Systems (TOPLAS), ACM, v. 16, n. 5, p.<br>
1512–1542, 1994.<br>
CORDEIRO, L.; FISCHER, B.; MARQUES-SILVA, J. Smt-based bounded model checking for<br>
embedded ansi-c software. IEEE Transactions on Software Engineering, IEEE, v. 38, n. 4, p.<br>
957–974, 2012.<br>
COUSOT, P.; COUSOT, R. A gentle introduction to formal verification of computer systems by<br>
abstract interpretation. [S.l.]: IOS Press, 2010.<br>
DAHAN, A. et al. Combining system level modeling with assertion based verification. In: Sixth<br>
international symposium on quality electronic design (isqed’05). [S.l.: s.n.], 2005. p. 310–315.<br>
ISSN 1948-3287.<br>
D’SILVA, V.; KROENING, D.; WEISSENBACHER, G. A survey of automated techniques<br>
for formal software verification. IEEE Transactions on Computer-Aided Design of Integrated<br>
Circuits and Systems, IEEE, v. 27, n. 7, p. 1165–1178, 2008.<br>
ELSEVIER. 2017. Acessado em: 01 março 2018. Disponível<br>
em: &lt;https://www.elsevier.com/__data/assets/pdf_file/0007/69451/<br>
0597-Scopus-Content-Coverage-Guide-US-LETTER-v4-HI-singles-no-ticks.pdf&gt;.<br>
G1. Acidente foi provocado por falha em circuito eletrônico, diz se-<br>
cretário. 2012. Disponível em: &lt;http://g1.globo.com/sao-paulo/noticia/2012/05/<br>
acidente-foi-provocado-por-falha-em-circuito-eletronico-diz-secretario.html&gt;.<br>
GUGLIELMO, G. D. et al. On the use of assertions for embedded-software dynamic verification.<br>
In: IEEE. Design and Diagnostics of Electronic Circuits & Systems (DDECS), 2012 IEEE 15th<br>
International Symposium on. [S.l.], 2012. p. 330–335.<br>
GUPTA, A. Formal hardware verification methods: A survey. In: SPRINGER. Computer-Aided<br>
Verification. [S.l.], 1992. p. 5–92.<br>
HALDER, A.; VENKATESWARLU, A. A study of petri nets modeling analysis and simulation.<br>
Department of Aerospace Engineering Indian Institute of Technology Kharagpur, India, 2006.<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Interpolation and symbol elimination in vampire.<br>
Automated Reasoning, Springer, p. 188–195, 2010.<br>
Bibliography 56<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Case studies on invariant generation using a<br>
saturation theorem prover. Advances in Artificial Intelligence, Springer, p. 1–15, 2011.<br>
IDOETA, I. V.; CAPUANO, F. G. Elementos de eletrônica digital. [S.l.]: Livros Erica, 1982.<br>
IEC/IEEE International Standard - Behavioural languages - Part 1-1: VHDL Language<br>
Reference Manual. IEC 61691-1-1:2011(E) IEEE Std 1076-2008, p. 1–648, May 2011.<br>
IEEE. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http://ieeexplore.ieee.org/<br>
Xplore/home.jsp&gt;.<br>
IEEE Standard for Property Specification Language (PSL). IEEE Std 1850-2010 (Revision of<br>
IEEE Std 1850-2005), p. 1–182, April 2010.<br>
IEEE Standard for Verilog Hardware Description Language. IEEE Std 1364-2005 (Revision of<br>
IEEE Std 1364-2001), p. 1–560, 2006.<br>
KITCHENHAM, B. Procedures for performing systematic reviews. Keele, UK, Keele University,<br>
v. 33, n. 2004, p. 1–26, 2004.<br>
KITCHENHAM, B. et al. Systematic literature reviews in software engineering–a systematic<br>
literature review. Information and software technology, Elsevier, v. 51, n. 1, p. 7–15, 2009.<br>
KNOOP, J.; RÜTHING, O.; STEFFEN, B. Partial dead code elimination. [S.l.]: ACM, 1994.<br>
v. 29.<br>
KOSCIANSKI, A.; SOARES, M. dos S. Qualidade de Software - 2a Edição: Aprenda as<br>
metodologias e técnicas mais modernas para o desenvolvimento de software. Novatec,<br>
2007. ISBN 9788575221129. Disponível em: &lt;https://books.google.com.br/books?id=<br>
O9aWoUq6L88C&gt;.<br>
KROPF, T. Introduction to Formal Hardware Verification. Springer Berlin Heidelberg,<br>
2013. ISBN 9783662038093. Disponível em: &lt;https://books.google.com.br/books?id=<br>
7ImrCAAAQBAJ&gt;.<br>
MAFRA, S. N.; TRAVASSOS, G. H. Estudos primarios e secundarios apoiando a busca por<br>
evidencia em engenharia de software. Relatorio Tecnico, RT-ES, v. 687, n. 06, 2006.<br>
MUKHERJEE, R. et al. Unbounded safety verification for hardware using software analyzers.<br>
In: EDA CONSORTIUM. Proceedings of the 2016 Conference on Design, Automation & Test in<br>
Europe. [S.l.], 2016. p. 1152–1155.<br>
MUKHERJEE, R.; TAUTSCHNIG, M.; KROENING, D. v2c–a verilog to c translator. In:<br>
SPRINGER. International Conference on Tools and Algorithms for the Construction and<br>
Analysis of Systems. [S.l.], 2016. p. 580–586.<br>
MURATA, T. Petri nets: Properties, analysis and applications. Proceedings of the IEEE, IEEE,<br>
v. 77, n. 4, p. 541–580, 1989.<br>
RAMESH, U. B. K.; SENTILLES, S.; CRNKOVIC, I. Energy management in embedded<br>
systems: Towards a taxonomy. In: IEEE PRESS. Proceedings of the First International<br>
Workshop on Green and Sustainable Software. [S.l.], 2012. p. 41–44.<br>
ROCHA, H. et al. Exploiting safety properties in bounded model checking for test cases<br>
generation of c programs. 2010.<br>
Bibliography 57<br>
ROCHA, H. et al. Model checking embedded c software using k-induction and invariants<br>
(extended version). arXiv preprint arXiv:1509.02471, 2015.<br>
ROCHA, H. O. et al. Verificacao de sistemas de software baseada em transformacoes de codigo<br>
usando bounded model checking. Universidade Federal do Amazonas, 2015.<br>
SARGENT, R. G. Verification and validation of simulation models. In: WINTER SIMULATION<br>
CONFERENCE. Proceedings of the 37th conference on Winter simulation. [S.l.], 2005. p.<br>
130–143.<br>
SEGER, C.-J. An introduction to formal hardware verification. [S.l.]: University of British<br>
Columbia, Department of Computer Science, 1992.<br>
SOMMERVILLE, I. Engenharia de software. PEARSON BRASIL, 2011. ISBN 9788579361081.<br>
Disponível em: &lt;https://books.google.com.br/books?id=H4u5ygAACAAJ&gt;.<br>
SONS, J. W. . 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http:<br>
//onlinelibrary.wiley.com/&gt;.<br>
SOUZA, J. Lógica para Ciência da Computação. Elsevier Brasil, 2017. ISBN 9788535278255.<br>
Disponível em: &lt;https://books.google.com.br/books?id=Ds2sCQAAQBAJ&gt;.<br>
SPRINGER. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;https:<br>
//link.springer.com/&gt;.<br>
SRIKANT, Y.; SHANKAR, P. The Compiler Design Handbook: Optimizations and<br>
Machine Code Generation. CRC Press, 2002. ISBN 9781420040579. Disponível em:<br>
&lt;https://books.google.com.br/books?id=0K\_jIsgyNpoC&gt;.<br>
THOMAS, D.; MOORBY, P. The Verilog R© Hardware Description Language. Springer<br>
US, 2008. ISBN 9780387853444. Disponível em: &lt;https://books.google.com.br/books?id=<br>
DxQGrz7q-SwC&gt;.<br>
TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L. Sistemas digitais: princípios e aplicações. [S.l.]:<br>
Prentice Hall, 2003. v. 8.<br>
TRAVASSOS, G. H. et al. An environment to support large scale experimentation in software<br>
engineering. In: IEEE. Engineering of Complex Computer Systems, 2008. ICECCS 2008. 13th<br>
IEEE International Conference on. [S.l.], 2008. p</div>
<!-- DIVISOR_DIV_CANDIDATE -->

<div class='divisor divisor-texto' id="cand__file9"><hr class='text-separator'><br>Input file: <a href='#'>main.pdf</a> (12773 chunks)<br>File found: <a href='http://www2.pcs.usp.br/~labdig/material/intro-hdl.pdf' target='_blank'>http://www2.pcs.usp.br/~labdig/material/intro-hdl.pdf</a> (3756 chunks)<br><br>Chunks in common: 132<br>Similarity: 0.8%<br><br><div class='textInfo'>The following is the content of the document <br>&nbsp;"<b>main.pdf</b>". <br>The terms in red were found in the document <br>&nbsp;"<b>http://www2.pcs.usp.br/~labdig/material/intro-hdl.pdf</b>".<br><hr class='text-separator'></div>  UNIVERSIDADE FEDERAL DE RORAIMA<br>
PRÓ-REITORIA DE ENSINO E EXTENSÃO<br>
DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código<br>
com Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau<br>
de Bacharel em Ciência da Computação.<br>
Orientador: Dr. Herbert Oliveira Rocha<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau de<br>
Bacharel em Ciência da Computação.<br>
Defendido em 06 de março de 2017 e<br>
aprovado pela seguinte banca examinadora:<br>
Prof. Dr. Herbert Oliveira Rocha<br>
Orientador / Curso de Ciência da Computação -<br>
UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Fazer dedicatória<br>
ACKNOWLEDGEMENTS<br>
Fazer agradecimentos!!<br>
Procurar frase massa!!<br>
ABSTRACT<br>
Fazer resumo!!<br>
Palavras-chaves: ??<br>
ABSTRACT<br>
Fazer Abstract!!<br>
Key-words: ??<br>
LISTA DE FIGURAS<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog. . . . . . . . . . . . . . . . 15<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL. . . . . . . . . . . . . . . . . 16<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade. . . . . . . . . . . . . . . 17<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL. . . . . . . . . . . . . . . . 17<br>
Figure 5 – Exemplo de algebra booleana, onde <span class='f1 c_81' id='c_81_1' href='#c_81_2' cs_f='.c_81' >A=0, B=1, C</span>=1 e D=1. . . . . . . . . . 18<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas. . . . . . . . . 18<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas. . . . . . . . . . 19<br>
Figure 8 – Arvore de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
Figure 9 – Rede de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL. . . . . . . . . . . . . . . . . 27<br>
Figure 11 – Trecho de código em VHDL representando porta AND. . . . . . . . . . . . 28<br>
Figure 12 – Trecho de código traduzido para linguagem C. . . . . . . . . . . . . . . . . 29<br>
Figure 13 – Exemplo de bloco basico de código. . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 14 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 15 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 31<br>
Figure 16 – Ciclo da ferramenta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR. . . . . . . 41<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR. . . . . . . . . . . . . . 42<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume(). . . . . . . . . . . 43<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19. . . . . . . . . . . . . . . 44<br>
Figure 22 – Macros das assertivas implementadas em linguagem C . . . . . . . . . . . . 45<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas. . . . . . . 47<br>
Figure 25 – Imagem de claims contendo assertivas. . . . . . . . . . . . . . . . . . . . . 48<br>
Figure 26 – Pseudocódigo da função de análise das claims. . . . . . . . . . . . . . . . . 49<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta. . . . . . . . . . . . . . 49<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C. . . . . . . . . . . . . 50<br>
Figure 23 – Código com assertivas traduzida para linguagem C . . . . . . . . . . . . . . 51<br>
LISTA DE TABELAS<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM . . . . . . . . . . . . . . . 33<br>
SUMÁRIO<br>
1 INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11<br>
1.1 Definição do problema . . . . . . . . . . . . . . . . . . . . . . . . . . . 12<br>
1.2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13<br>
1.3 Organização do trabalho . . . . . . . . . . . . . . . . . . . . . . . . . 14<br>
2 CONCEITOS E DEFINIÇÕES . . . . . . . . . . . . . . . . . . . . . . 15<br>
2.1 Linguagens de descrição de hardware . . . . . . . . . . . . . . . . . 15<br>
2.1.1 <span class='f1 c_76' id='c_76_1' href='#c_76_2' cs_f='.c_76' >VHSIC Hardware Description Language</span> - VHDL . . . . . . . . . . . . . 16<br>
2.1.2 Portas lógicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18<br>
2.2 Verificação de sistemas . . . . . . . . . . . . . . . . . . . . . . . . . . 19<br>
2.2.1 Diagrama de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.2 Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.3 Bounded Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . 21<br>
2.2.4 Redes de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22<br>
2.2.5 Verificação de hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
2.2.6 Verificação formal de software . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.7 Lógica proposicional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.8 Linguagem de especificação de propriedades . . . . . . . . . . . . . . 26<br>
2.2.9 Verificação baseada em assertivas . . . . . . . . . . . . . . . . . . . . 26<br>
2.2.10 Propriedades de segurança . . . . . . . . . . . . . . . . . . . . . . . . 27<br>
2.3 Técnicas de compiladores . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.1 Transformações de código . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2 Otimização de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2.1 Grafo Acliclico Direcional - GAD . . . . . . . . . . . . . . . . . . . . . . . . 29<br>
2.3.2.2 Grafo <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >de Fluxo de</span> Controle - GFC . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.3 Eliminção de código morto . . . . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.4 Análise <span class='f1 c_63' id='c_63_1' href='#c_63_2' cs_f='.c_63' >do fluxo de dados</span> . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
2.3.2.5 Gerador de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
3 TRABALHOS CORRELATOS . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1 Revisão sistemática . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1.1 Planejamento da Revisão Sistemática . . . . . . . . . . . . . . . . . . 33<br>
3.1.1.1 Procedimentos de Seleção e Critérios . . . . . . . . . . . . . . . . . . . . 35<br>
3.2 Revisão da literatura . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.1 V2c-A verilog to C translator . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.2 Unbounded safety verification for hardware using software analyzers . 37<br>
3.2.3 Formal verification of timed VHDL programs . . . . . . . . . . . . . . . 38<br>
3.2.4 On the use of assertions for embedded-software dynamic verification 38<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation . . 39<br>
4 MÉTODO PROPOSTO . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.1 Visão geral do método . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.2 Preprocessamento do VHDL e inserção de assertivas . . . . . . . 42<br>
4.3 Tradução de código VHDL para a linguagem C . . . . . . . . . . . . 43<br>
4.4 Instrumentação de código . . . . . . . . . . . . . . . . . . . . . . . . 45<br>
4.5 Verificação de assertivas usando Model Checker . . . . . . . . . . 46<br>
5 CRONOGRAMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52<br>
6 CONSIDERAÇÕES PARCIAIS E TRABALHOS FUTUROS . . . . . 53<br>
BIBLIOGRAPHY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54<br>
11<br>
1 INTRODUÇÃO<br>
A complexidade de sistemas computacionais cresce exponencialmente. Muitas compan- Exemplificar<br>
este<br>
cresci-<br>
mento.<br>
hias e organizações estão rotineiramente lidando com software que contém milhares de linhas<br>
de código, escritos por diferentes pessoas, que usam linguagens distintas, ferramentas, estilos e<br>
hardware projetados de diversas formas e combinações (HODER et al., 2011).<br>
No contexto de sistemas compostos de hardware e software, tem-se os sistemas embarca-<br>
dos (SE) que são dispositivos semicondutores com software integrados, os quais se conectam<br>
a outros dispositivos. Usualmente, o principal propósito dos SE é o controle e provimento de<br>
informações para uma função específica (RAMESH et al., 2012).<br>
Os SE são extremamente interativos com seu ambiente, operam geralmente em tempo real<br>
e estão disponíveis continuamente. No entanto, estes sistemas, por possuírem um curto espaço<br>
de tempo para a liberação do produto ao mercado, precisam ser desenvolvidos rapidamente e<br>
atingir um alto nível de qualidade, mas, devido a esta necessidade, os programadores podem<br>
cometer enganos durante a fase de desenvolvimento destes sistemas.<br>
Os SE têm se proliferado em partes consideráveis das atividades do nosso cotidiano,<br>
com a característica de possuir grande quantidade de complexidade e diversidade. Devido a esta<br>
complexidade, erros podem passar despercebidos, causando não apenas penalidades econômicas<br>
e/ou fracassos do produto no mercado, mas principalmente o risco de perda de vidas humanas<br>
(CABODI et al., 2016). Como, por exemplo, o acidente noticiado no (G1, 2012), no qual, de<br>
acordo com o secretário de transportes, uma falha na placa do circuito eletrônico responsável<br>
pelo controle de velocidade dos trens ocasionou a colisão entre duas composições na estação de<br>
metrô de São Paulo.<br>
Segundo ROCHA et al.2015b, para se obter um alto nível de qualidade no desenvolvi-<br>
mento dos sistemas de hardware e software, a execução desses sistemas deve ser controlada e <span class='f1 c_73' id='c_73_1' href='#c_73_2' cs_f='.c_73' >da<br>
mesma forma</span> deve-se buscar meios de garantir que as propriedades definidas sejam atingidas. Por<br>
exemplo, a partir do conhecimento prévio do modo de implementação de determinado hardware,<br>
é possível utilizá-lo de forma mais eficiente. Neste sentido, diversas estratégias de verificação e<br>
de teste estão sendo pesquisadas e aplicadas para garantir a qualidade do software e hardware<br>
(HODER et al., 2010; ROCHA et al., 2010; BRAYTON; MISHCHENKO, 2010; CORDEIRO et<br>
al., 2012; CABODI et al., 2016).<br>
Por este motivo, com o intuito de analisar e otimizar a descrição dos circuitos digitais,<br>
tem-se utilizado <span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >as linguagens de</span> descrição <span class='f1 c_39' id='c_39_1' href='#c_39_2' cs_f='.c_39' >de hardware (HDL</span>). Estas se diferem <span class='f1 c_46' id='c_46_1' href='#c_46_2' cs_f='.c_46' >das linguagens<br>
de</span> programação por conseguirem gerar execuções não apenas sequenciais, como também con-<br>
correntes ou paralelas (CHU, 2006). Neste contexto, a <span class='f1 c_76' id='c_76_1' href='#c_76_2' cs_f='.c_76' >VHSIC Hardware Description Language</span><br>
Chapter 1. INTRODUÇÃO 12<br>
(VHDL) é uma <span class='f1 c_46' id='c_46_1' href='#c_46_2' cs_f='.c_46' >das linguagens de</span> descrição <span class='f1 c_7' id='c_7_1' href='#c_7_2' cs_f='.c_7' >de hardware mais</span> utilizadas atualmente. A descrição<br>
em VHDL pode ser em vários níveis de abstração, sendo o mais alto o nível comportamen-<br>
tal que permite a descrição do circuito através de loops e processos, definido-o na forma de<br>
algoritmo. Como características <span class='f1 c_46' id='c_46_1' href='#c_46_2' cs_f='.c_46' >das linguagens de</span> descrição, o VHDL permite declarações se-<br>
quenciais ou concorrentes onde as declarações continuam ativas e sua ordem torna-se irrelevante<br>
(CAPPELATTI, 2010).<br>
Aliada à linguagem de descrição de hardware, a verificação formal de sistemas computa-<br>
cionais tem desempenhado um papel importante para assegurar a previsibilidade e a confiabili-<br>
dade na concepção de aplicações críticas. E, para isso, tem-se utilizado a técnica denominada<br>
model checking, que é baseada em formalismos matemáticos para provar propriedades de pro-<br>
gramas reativos (BENSALEM; LAKHNECH, 1999). Esta técnica gera uma busca exaustiva no<br>
espaço de estados do modelo para determinar se uma dada propriedade é válida ou não (BAIER<br>
et al., 2008), tendo como principal razão para o seu sucesso o funcionamento completamente<br>
automático, ou seja, sem qualquer intervenção do usuário.<br>
Visando contribuir com a verificação de sistemas embarcados no âmbito de sistemas<br>
computacionais, o contexto deste trabalho está situado no uso de metodologias e técnicas de<br>
verificação formal para programas escritos em VHDL (BIERE, 2016), focando principalmente<br>
no Bounded Model Checking (CORDEIRO et al., 2012; ROCHA et al., 2015a). Este trabalho está<br>
interessado especificamente na parte de: verificação de modelos de hardware descritos em níveis<br>
de circuitos de bits na linguagem VHDL, via transformações de código para gerar modelos (com<br>
assertivas) já suportados por model checkers, como o ESBMC (CORDEIRO et al., 2012).<br>
Dessa forma, o trabalho almeja analisar as propriedades de alcançabilidade para a<br>
identificação de localizações de erro, bem como, assertivas contendo propriedades de segurança.<br>
A propriedade de alcançabilidade ou propriedade do estado de erro é satisfatória (SAT), se um<br>
estado de erro é alcançável. Caso contrário, a propriedade é considerada insatisfatória (UNSAT).<br>
No caso SAT, o model checking também gera um rastreio da validação da propriedade (contra-<br>
exemplo), ou seja, uma sequência de estados que mostra como chegar ao erro <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >a partir de um</span><br>
ponto inicial.<br>
1.1 Definição do problema<br>
O avanço da tecnologia, principalmente nas áreas de design e fabricação de eletrônicos,<br>
aumentou a importância do hardware nos dias atuais. <span class='f1 c_42' id='c_42_1' href='#c_42_2' cs_f='.c_42' >Cada vez com</span> mais funcionalidades<br>
integradas, aliada a velocidade e circuitos menores, <span class='f1 c_75' id='c_75_1' href='#c_75_2' cs_f='.c_75' >faz com que a</span> complexidade dos sistemas<br>
de hardware aumente. Entretanto, devido à complexidade cada vez maior, a detecção tardia<br>
de erros no sistema pode resultar em perda de produção, mas também custos associados ao<br>
desenvolvimento do sistema(GUPTA, 1992). Devido a isso, a verificação de hardware visa<br>
assegurar que o circuito atinja as especificações para o qual foi projetado, através de técnicas<br>
Chapter 1. INTRODUÇÃO 13<br>
formais ou dinâmicas (BOULE; ZILIC, 2007).<br>
Por esta razão, a utilização de métodos formais tornou-se uma abordagem atraente<br>
para superar as limitações inerentes à validação baseada em simulação. Portanto, a maioria<br>
das empresas de semicondutores têm investigado a sua aplicabilidade. Escolhas individuais de<br>
métodos, ferramentas e áreas de aplicação das empresas têm variado, assim como o seu nível<br>
de sucesso (CABODI et al., 2016). Com os recentes avanços na escalabilidade de automação<br>
dos model checkers e nas equivalências sequenciais de verificação, a maioria das empresas têm<br>
crescido ao contar com essas técnicas(CLARKE, 2008).<br>
O problema considerado neste trabalho é expresso na seguinte questão: Como comple-<br>
mentar e aprimorar a verificação de propriedades de segurança em circuitos lógicos, de tal<br>
<span class='f1 c_122' id='c_122_1' href='#c_122_2' cs_f='.c_122' >forma que uma</span> propriedade possa ser mapeada em um problema de alcançabilidade sim-<br>
bólica, ou seja, se é possível alcançar um estado específico (para uma dada propriedade) a<br>
partir do estado inicial?<br>
1.2 Objetivos<br>
O objetivo principal deste trabalho é projetar e avaliar um método para efetuar verificação<br>
de circuitos, de forma automática, descritos em VHDL com portas lógicas em nível de bit<br>
pela utilização de técnicas de transformação de códigos combinado com a técnica Bounded<br>
Model Checking para exploração de estados alcançáveis no circuito, visando identificar erros ou<br>
comportamentos indevidos ou inesperados que podem resultar no funcionamento incorreto de<br>
um dado sistema.<br>
Os objetivos específicos são:<br>
1. Propor um método para especificar pré e pós-condições de circuitos digitais em nível de<br>
portas lógicas descritos em VHDL;<br>
2. Analisar ferramentas de verificação de modelos que utilizam a técnica Bounded Model<br>
Checking;<br>
3. Especificar uma técnica de conversão de circuitos em linguagem de descrição de hardware<br>
VHDL para um modelo a ser verificado usando a técnica Bounded Model Checking;<br>
4. Desenvolver um método para identificação de estados de erros ou ocorrências indevidas,<br>
de um dado circuito analisado, em modelos de hardware descritos em nível de bit na<br>
linguagem de descrição VHDL.<br>
5. Validar a aplicação do método proposto sobre benchmarks públicos de programas em<br>
VHDL, a fim de examinar a sua eficácia e aplicabilidade.<br>
Chapter 1. INTRODUÇÃO 14<br>
1.3 Organização do trabalho<br>
A introdução deste trabalho apresentou: o contexto, definição do problema, e objetivos<br>
deste trabalho. Os próximos capítulos estão organizados da seguinte forma:<br>
No Capítulo 2 Conceitos e Definições, são apresentados os conceitos abordados neste<br>
trabalho, especificamente: Linguagens de descrição de hardware; Verificação e validação de<br>
sistemas; e Técnicas de compiladores.<br>
No Capítulo 3 Trabalhos Correlatos, serão apresentados o método de pesquisa bibli-<br>
ográfica utilizado, sendo ele a revisão sistemática, seguido do resultado encontrado com esta<br>
pesquisa e, por fim, a contribuição dos artigos utilizados no desenvolvimento do projeto.<br>
No Capítulo 4 Método Proposto, são descritas as etapas de execução do novo método<br>
proposto que consiste na transformação do código, instrumentação de assertivas e verificação de<br>
código utilizando um model checker.<br>
No Capítulo 5, será apresentado o cronograma de atividades a ser realizado na elaboração<br>
do método durante <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >o desenvolvimento do</span> projeto.<br>
E, por fim, no Capítulo 6 Considerações parciais e trabalhos futuros, serão apresentas<br>
as considerações parciais e as sugestões de trabalhos futuros que podem ser desenvolvidos.<br>
15<br>
2 CONCEITOS E DEFINIÇÕES<br>
Este capítulo tem apresenta os principais conceitos e definições abordados neste tra-<br>
balho, tais como: Linguagens de descrição de hardware, Verificação de sistemas e Técnicas de<br>
Compiladores.<br>
2.1 Linguagens de descrição de hardware<br>
<span class='f1 c_23' id='c_23_1' href='#c_23_2' cs_f='.c_23' >As linguagens de</span> descrição <span class='f1 c_39' id='c_39_1' href='#c_39_2' cs_f='.c_39' >de hardware (HDL</span>) foram desenvolvidas com o intuito de<br>
auxiliar a criação de circuitos lógicos com grande número de elementos e com uma gama de<br>
abstrações lógicas e eletrônicas (THOMAS; MOORBY, 2008). Entre os exemplos, podemos<br>
citar: VDHL (IEC/IEEE. . . , 2011), Verilog (IEEE. . . , 2006) e SystemC (??).<br>
Segundo CHRISTEN; BAKALAR,1999, linguagens de descrição de hardware são lingua-<br>
gens de programação utilizadas com o intuito de descrever o comportamento de um determinado<br>
circuito, técnica conhecida como modelagem. Os modelos descritos em HDL são utilizados<br>
<span class='f1 c_6' id='c_6_1' href='#c_6_2' cs_f='.c_6' >como entrada para</span> um simulador, onde o mesmo pode ter seu comportamento analisado.<br>
As HDL’s trazem consigo diversas vantagens, entre elas códigos independentes de tec-<br>
nologia e fabricante, podendo ser portáteis e reutilizáveis (CAPPELATTI, 2010). As linguagens<br>
mais modernas, tais como <span class='f1 c_93' id='c_93_1' href='#c_93_2' cs_f='.c_93' >VHDL e Verilog</span>, possuem suporte tanto a descrição do circuito pro-<br>
priamente dito, quanto ao comportamento que o mesmo deve exercer (CHRISTEN; BAKALAR,<br>
1999).<br>
A Verilog, como já citado, é uma linguagem de descrição de hardware que fornece<br>
diversos níveis de abstração para desenvolvimento de sistemas digitais(THOMAS; MOORBY,<br>
2008). A linguagem foi desenvolvida para ser simples e efetiva nos diversos níveis de abstração<br>
incluindo o suporte ao desenvolvimento, verificação, síntese e testes de software (IEEE. . . , 2006).<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog.<br>
1 p r i m i t i v e m u l t i p l e x e r ( mux , c o n t r o l , dataA , da taB ) ;<br>
2 o u t p u t mux ;<br>
3 i n p u t c o n t r o l , dataA , da taB ;<br>
4 e n d p r i m i t i v e<br>
Fonte: Adaptado de (IEEE. . . , 2006).<br>
Na Figura 1 apresenta <span class='f1 c_10' id='c_10_1' href='#c_10_2' cs_f='.c_10' >um exemplo de</span> multiplexador descrito em Verilog utilizando a<br>
estrutura de modelagem, chamada UDP que permite a criação de novos primitivas para serem<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 16<br>
utilizada. Apresenta uma saída apenas(mux) e três entradas sendo uma de controle(control) e<br>
duas de dados(dataA e dataB).<br>
A VHDL é uma linguagem de descrição de hardware amplamente utilizada, concebida<br>
na década de 80, devido uma necessidade do Departamento de Defesa dos Estados Unidos<br>
da América (CAPPELATTI, 2010). Assim como a Verilog, esta linguagem também suporta o<br>
desenvolvimento, a verificação, a síntese, e os testes de hardware (IEC/IEEE. . . , 2011).<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL.<br>
1 l i b r a r y <span class='f1 c_79' id='c_79_1' href='#c_79_2' cs_f='.c_79' >IEEE ;<br>
2 use IEEE</span> . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 use IEEE . s t d _ l o g i c _ u n s i g n e d . a l l ;<br>
4 e n t i t y mux2x1 i s<br>
5 p o r t ( s e l : i n STD_LOGIC ;<br>
6 a , b : i n STD_LOGIC ;<br>
7 y : o u t <span class='f1 c_99' id='c_99_1' href='#c_99_2' cs_f='.c_99' >STD_LOGIC ) ;<br>
8 end</span> mux2x1 ;<br>
9<br>
10 a r c h i t e c t u r e d a t a f l o w of mux2x1 i s b e g i n<br>
11 y &lt;= ( a AND NOT s e l ) OR ( b AND s e l ) ;<br>
12 end d a t a f l o w .<br>
Fonte: (CAPPELATTI, 2010).<br>
Na Figura 2 está descrito um multiplexador de duas entradas descrito em VHDL, apre-<br>
sentando na parte inicial as bibliotecas e na entidade(entity) a declaração das variáveis utilizadas.<br>
Na arquitetura(architecture) apresenta <span class='f1 c_52' id='c_52_1' href='#c_52_2' cs_f='.c_52' >o funcionamento do</span> multiplexador, relacionando en-<br>
tradas e saídas conforme tenham sido declarados. Este conceitos serão melhor apresentados na<br>
subsection 2.1.1.<br>
Conforme apresentado nas Figura 1 e Figura 2, <span class='f1 c_80' id='c_80_1' href='#c_80_2' cs_f='.c_80' >ambas as linguagens</span> apresentam difer-<br>
enças no modelos de declaração e utilização para descrição <span class='f1 c_106' id='c_106_1' href='#c_106_2' cs_f='.c_106' >de hardware. Para</span> este trabalho foi<br>
escolhido a VHDL devido a linguagem apresentar um melhor escopo para análise, facilitando o<br>
trabalho de análise proposto para este projeto.<br>
2.1.1 <span class='f1 c_76' id='c_76_1' href='#c_76_2' cs_f='.c_76' >VHSIC Hardware Description Language</span> - VHDL<br>
Revisar textos e verificar a necessidade de mais exemplo<br>
VHDL é uma linguagem de descrição de hardware destinada a ser utilizada em todas<br>
as etapas da criação de sistemas eletrônicos, sendo elas: desenvolvimento; verificação; síntese;<br>
e, teste de circuitos (IEC/IEEE. . . , 2011). Segundo (CAPPELATTI, 2010), a VHDL apresenta<br>
três principais pilares: abstração, que consiste na descrição com diferentes níveis de detalhes;<br>
modularidade, que permite a divisão do projeto em vários blocos ou módulos para posterior<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 17<br>
interconexão; e hierarquia, permite que módulos possam ser compostos por submódulos e, os<br>
mesmos tenham níveis de abstração diferentes, dependendo da necessidade do projeto. Devido a<br>
esta versatilidade que <span class='f1 c_128' id='c_128_1' href='#c_128_2' cs_f='.c_128' >a linguagem VHDL foi</span> selecionada para o trabalho proposto.<br>
Segundo IEC/IEEE. . . ,2011, é necessário um padrão para formatação da descrição em<br>
VHDL: Entity (Pinos de entrada/saída) e Architecture (Arquitetura). A Entity ou entidade repre-<br>
senta o bloco onde são declaradas <span class='f1 c_124' id='c_124_1' href='#c_124_2' cs_f='.c_124' >as entradas e as</span> saídas do circuito utilizadas em todo o sistema,<br>
conforme <span class='f1 c_117' id='c_117_1' href='#c_117_2' cs_f='.c_117' >apresentado na Figura 3. A</span> Architecture ou arquitetura, <span class='f1 c_117' id='c_117_1' href='#c_117_2' cs_f='.c_117' >apresentado na Figura</span> 4, define<br>
a relação entre entradas e saídas declaradas na entidade, podendo tais especificações serem<br>
completas ou parciais. Assim como em outras linguagens, bibliotecas podem ser adicionadas,<br>
para que novas funções e atributos possam ser utilizados no projeto.<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade.<br>
1 l i b r a r y i e e e ;<br>
2 <span class='f1 c_15' id='c_15_1' href='#c_15_2' cs_f='.c_15' >use IEEE . STD_LOGIC_1164 . ALL</span><br>
3<br>
4 ENTITY f u l l _ a d d e r IS PORT(<br>
5 x1 , x2 , c i n : i n s t d _ l o g i c ;<br>
6 S , c o u n t : o u t s t d _ l o g i c ) ;<br>
7 END f u l l _ a d d e r ;<br>
Fonte: Própria.<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL.<br>
1 ARCHITECTURE b e h a v i o r a l OF f u l l _ a d d e r IS<br>
2 BEGIN<br>
3 s &lt;=x1 XOR x2 XOR c i n ;<br>
4 cout &lt;=( x1 AND x2 ) OR ( x1 AND c i n ) OR ( b<br>
AND c i n ) ;<br>
5 END b e h a v i o r a l ;<br>
Fonte: Própria.<br>
Segundo CAPPELATTI,2010 uma descrição em VHDL pode conter diferentes níveis de<br>
abstração:<br>
• Comportamental: Permite descrever o circuito através de laços e processos. O circuito<br>
é definido em forma <span class='f1 c_110' id='c_110_1' href='#c_110_2' cs_f='.c_110' >de um algoritmo</span>, utilizando construção similares as utilizadas em<br>
linguagem de programação.<br>
• Transferência de registradores: Englobando a representação do dispositivo em nível de<br>
transferência entre registradores, que consiste na utilização de funções lógicas combina-<br>
cionais e de registradores.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 18<br>
• Estrutural: O circuito é descrito mais próximo da implementação real, podendo ser<br>
definidas portas lógicas com atrasos unitários ou com atrasos detalhados.<br>
2.1.2 Portas lógicas<br>
Segundo (IDOETA; CAPUANO, 1982), o conceito de portas lógicas é baseado na<br>
conhecida álgebra de Boole ou álgebra booleana, desenvolvida pelo matemático inglês George<br>
Boole em 1854. A álgebra booleana é representada por apenas dois valores, sendo eles o 0 e 1 e,<br>
através disso, expressa a relação entre entrada e saída <span class='f1 c_31' id='c_31_1' href='#c_31_2' cs_f='.c_31' >dentro de um circuito</span>. As portas lógicas<br>
podem ser construídas <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >a partir de</span> diodos, transistores e resistores interconectados de modo que a<br>
saída seja o resultante de uma operação lógica básica realizada sobre as entradas (TOCCI et al.,<br>
2003). A Figura 5 apresenta <span class='f1 c_10' id='c_10_1' href='#c_10_2' cs_f='.c_10' >um exemplo de</span> álgebra booleana sem a utilização de diagramas.<br>
Figure 5 – Exemplo de algebra booleana, onde <span class='f1 c_81' id='c_81_1' href='#c_81_2' cs_f='.c_81' >A=0, B=1, C</span>=1 e D=1.<br>
Fonte: (TOCCI et al., 2003)<br>
Ainda segundo TOCCI et al.,2003, devido a esta característica, a álgebra booleana possui<br>
três operações básicas, OR (ou), AND (e) e NOT (não). Tal conjunto de operações também é<br>
denominado de operações booleanas e, por meio da utilização de tabelas verdade é possível<br>
descrever as saídas baseando-se nas entradas e na operação aplicada. Cada operação booleana<br>
possui sua tabela verdade ( Figura 6), bem como sua representação em forma de diagrama.<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas.<br>
Fonte: (TOCCI et al., 2003)<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 19<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas.<br>
Fonte: (TOCCI et al., 2003)<br>
A Figura 7 apresenta um circuito lógico formado pelas portas básicas da álgebra booleana.<br>
O circuito apresenta três entradas representadas pelas letras <span class='f1 c_89' id='c_89_1' href='#c_89_2' cs_f='.c_89' >A, B e</span> C, mas também formada<br>
por duas portas AND, uma porta NOT e uma porta OR. Cada uma destas portas representando<br>
operações a serem realizadas, podendo receber como entrada um valor inicial ou resultante de<br>
outra porta, como no exemplo ocorre com a última porta AND.<br>
Entetanto, segundo (KROPF, 2013), a análise de circuitos é extremamente complexa,<br>
resultando em um problema NP-Completo, algoritmos possuem tempo de execução exponencial.<br>
Contudo, este tempo de execução exponencial é uma complexidade exponencial para o pior caso,<br>
resultando crescimento exponencial da execução a medida que o tamanho do problema aumenta.<br>
Ainda, segundo (KROPF, 2013) a avaliação das funções booleanas podem ser ver-<br>
dadeiras(True) ou falso(False), com isso, para um função com n variáveis, apresenta 2n possibili-<br>
dades de avaliação. Utilizando o exemplo da Figura 7 que apresenta 3 entradas, logo apresenta 8<br>
possibilidade de avaliação ao final e este número aumenta à medida que o número de variáveis<br>
tambe aumenta<br>
2.2 Verificação de sistemas<br>
No contexto de verificação de sistemas, faz-se necessário a diferenciação entre verificação<br>
e validação. Verificação e validação possuem o intuíto de mostrar que determinado sistema fun-<br>
cione conforme o especificado, além de satisfazer as especificações do cliente (SOMMERVILLE,<br>
2011).<br>
Segundo (SARGENT, 2005), verificação é <span class='f1 c_45' id='c_45_1' href='#c_45_2' cs_f='.c_45' >o processo de</span> determinar se um modelo<br>
computacional obtido por discretização de um modelo matemático de um evento físico e o<br>
código <span class='f1 c_11' id='c_11_1' href='#c_11_2' cs_f='.c_11' >que implementa o</span> modelo computacional <span class='f1 c_129' id='c_129_1' href='#c_129_2' cs_f='.c_129' >pode ser usado para</span> representar o modelo<br>
matemático do evento com precisão suficiente e validação é <span class='f1 c_45' id='c_45_1' href='#c_45_2' cs_f='.c_45' >o processo de</span> determinar se um<br>
modelo matemático de um evento físico representa o evento físico real com precisão suficiente.<br>
A verificação consite identificação de erros e provavéis problemas que um componente<br>
pronto possa apresentar, enquanto a validação busca analisar se tal componete esta seguindo<br>
os requisitos pré-definidos para sua construção (KOSCIANSKI; SOARES, 2007). O teste de<br>
programa, na qual o software é executado com dados de teste é a principal forma de validação,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 20<br>
porém, tecnicas de verificação, tais como, inspeção e revisões também podem integrar a etapa de<br>
validação (SOMMERVILLE, 2011).<br>
2.2.1 Diagrama de decisão binária<br>
<span class='f1 c_115' id='c_115_1' href='#c_115_2' cs_f='.c_115' >Um diagrama de</span> decisão binária(DDB) pode ser definido como um grafo aciclico para<br>
representação de funcões boolenas. Existe uma ordem rigorosa na ocorrência de variáveis à me-<br>
dida que se percorre o grafo da raiz para a folha. Dado como exemplo a formula f=(<span class='f1 c_81' id='c_81_1' href='#c_81_2' cs_f='.c_81' >a?b)?(c</span>?d)<br>
e utilizando a ordenação de variavél a &lt; b &lt; c &lt; d, na Figura 8. Dada a atribuição de valores<br>
booleanos as variaveis <span class='f1 c_81' id='c_81_1' href='#c_81_2' cs_f='.c_81' >a, b, c</span> e d, pode-se decidir se a atribuição torna a fórmula verdadeira<br>
atravessando o início do gráfico na raiz e ramificação em cada nó. Definindo a, c e d = 1 e c = 0<br>
leva a folha de rótulo 1, portanto, a fórmula é verdadeira para essa tarefa (CLARKE et al., 1994).<br>
Figure 8 – Arvore de decisão binária<br>
Fonte: (CLARKE et al., 1994)<br>
Adicionar mais detalhes e descrever onde DDB é utilizado.<br>
O DDB permite o teste eficiente de satisfabilidade, validade e eficiência (KROPF, 2013).<br>
O uso e DDB <span class='f1 c_56' id='c_56_1' href='#c_56_2' cs_f='.c_56' >em conjunto com</span> Model Checking e técnicas de abstração permitiu o aumento na<br>
capacidade de verificação, de modo que sistemas mais realistas podessem ser verificados(??)<br>
2.2.2 Model Checking<br>
Model checking é uma técnica de verificação formal que explora todos os possíveis<br>
estados do sistema, de modo a provar se um modelo satisfaz determinada propriedade. Pode ser<br>
aplicada em uma ampla gama de aplicações, tais como sistema embarcados, design de hardware<br>
e engenharia de software (BAIER et al., 2008).<br>
Entre as vantagens da utilização de Model Checking estão:<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 21<br>
• Possuem suporte a verificação parcial, em outras palavras, a verificação individual de<br>
propriedades, permitido foco primeiro as propriedades essenciais(BAIER et al., 2008).<br>
• Não requer qualquer interação do usuário, nem um alto grau de especialização <span class='f1 c_113' id='c_113_1' href='#c_113_2' cs_f='.c_113' >para o uso<br>
de</span> model checking(BAIER et al., 2008).<br>
• Possui como base a teoria de grafos, estruturas de dados e lógica no desenvolvimento da<br>
solução(BAIER et al., 2008).<br>
• Útil para fins de depuração, pois formece informações em caso de uma propriedade seja<br>
invalidada(BAIER et al., 2008).<br>
<span class='f1 c_19' id='c_19_1' href='#c_19_2' cs_f='.c_19' >Por outro lado</span>, apresenta também algumas desvantagens:<br>
• Sofre do problema de explosão de espaço de estados, ou seja, a quantidade de estados<br>
necessários pode ser maior que a memória disponivel pelo sistema(BAIER et al., 2008).<br>
• Faz a verificação apenas dos requisios declarados, logo, não a garantia de integridade.<br>
Baseado nisso, a validade de propriedades não verificadas não pode ser julgada(BAIER et<br>
al., 2008).<br>
• A verificação de modelos geralmente não é computável, isso deve-se a questões de decidi-<br>
bilidade utilizada (BAIER et al., 2008).<br>
Outras técnicas foram implementadas em conjuntos com Model checkings com o intuito<br>
de aumentas a capacidade de verificação, como a técnica SAT na qual não sofre do problema de<br>
explosão de estados existente usando DDB. A técnica SAT em conjuto com Model Checking é<br>
conhecida como Bounded Model Checking (??).<br>
2.2.3 Bounded Model Checking<br>
Segundo ROCHA et al., Bounded Model Checking (BMC) é um tipo especial de Model<br>
Checking que usualmente adota o método de satisfabilidade booleana, o qual tem sido introduzido<br>
como uma técnica complementar para diagrama de decisão binaria para aliviar o problema da<br>
explosão de estados, visto que a técnica de Model Checking busca todos os estados possíveis<br>
para verificação.<br>
Bounded Model Checking é uma técnica para a verificação de uma dada propriedade<br>
em uma determinada profundidade do sistema analisado. Logo, dado <span class='f1 c_105' id='c_105_1' href='#c_105_2' cs_f='.c_105' >um sistema de</span> transições<br>
M, uma propriedade ?, e um limite (bound) k, o BMC desenrola o sistema k vezes e traduz o<br>
sistema em uma condição de verificação(CV) ? tal que ? é satisfeito se e somente se ? tem um<br>
contra-exemplo de profundidade menor ou igual a k (ROCHA et al., 2015b).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 22<br>
O Extended SMT-Based Bounded Model Checker (ESBMC) é um Bounded Model<br>
Checking baseado em satisfabilidade booleana (SAT) que permite verificação aritmética de Já tem<br>
su-<br>
porte<br>
a<br>
SMT<br>
adi-<br>
cionar<br>
ao<br>
texto<br>
overflow e undeflow, segurança de ponteiros, limite de array, de gerar propriedades de segurança<br>
em programas em C/C++. ESBMC utiliza uma versão modificada do CBMC no front-end para<br>
analisar o código ANSI-C e para gerar as condições de verificação através de execução simbólica<br>
(CORDEIRO et al., 2012; ROCHA et al., 2015b).<br>
No ESBMC, o programa analisado é modelado <span class='f1 c_90' id='c_90_1' href='#c_90_2' cs_f='.c_90' >em um sistema de</span> transição de estados,<br>
conforme a trupla: M = (S,R, S0), o qual é gerado um grafo <span class='f1 c_77' id='c_77_1' href='#c_77_2' cs_f='.c_77' >de controle de</span> fluxo (GFC), onde<br>
<span class='f1 c_5' id='c_5_1' href='#c_5_2' cs_f='.c_5' >S representa o</span> conjunto de estados, R ? SxS representa as transições e S ? <span class='f1 c_5' id='c_5_1' href='#c_5_2' cs_f='.c_5' >S representa<br>
o</span> conjuto de estados iniciais. Um estado s ? S consiste no valor do contador de programa<br>
(PC) e os valores de todas as variáveis dos programas. O estado inicial S0 atribui o inicio do<br>
programa GFC ao PC, desta forma o ESBMC identifica as transições, conforme a formula lógica,<br>
?=(Si,Si+1) que captura as retrições sobre os valores correspondntes do PC e das variáveis do<br>
programa (CORDEIRO et al., 2012).<br>
Segundo o site do ESBMC(??), a ferramenta permite ao usuário indicar propriedades<br>
adicionaisusando assertivas que também são verificadas. O ESBMC converte as condições Descrever<br>
quais<br>
pro-<br>
priedades<br>
o<br>
esbmc<br>
su-<br>
porta<br>
usando diferentes técnicas de backgroundpara posteriormente passar para verificador SMT. Outra<br>
apresentar<br>
exem-<br>
plo<br>
vantagem é a ferramenta permitir verificação de software single-thread e multi-thread.<br>
Descrever qual a razão da escolha para o trabalho, apresentar resultados do SV-COMP<br>
dos últimos 3 anos<br>
2.2.4 Redes de petri<br>
Apresentar definição formal para RP<br>
corrigir o texto abaixo RP não é uma ferramenta e sim um método de modelagem<br>
Redes de petri são utilizadas como ferramentas de modelagem gráfica com propriedades<br>
matemática. Como ferramenta gráfica são utilizadas como comunicação visual, como fluxogra-<br>
mas, por exemplo, e como ferramenta matemática podem configurar modelos matemáticos que<br>
regem o comportamento dos sistemas. A grade premissa desta ferramenta é descrever sistemas<br>
de processamento de informações caracterizados como concorrentes, assíncronos, distribuídos,<br>
paralelos, não deterministas e/ou estocásticos (MURATA, 1989).<br>
As redes de petri são representados como grafos direcionais compostos por nós e arcos,<br>
conforme <span class='f1 c_117' id='c_117_1' href='#c_117_2' cs_f='.c_117' >apresentado na Figura</span> 9. Os nós representam as transições e eventos e os arcos<br>
representam os pesos. Dentro desta representação, os arcos e eventos são componentes passivos<br>
enquanto as transições são ativos. A principal vantagem da utilização das redes de petri esta<br>
relacionado ao chamado "Token game" que consiste no comportamento da rede de petri, em<br>
outras palavras, representa <span class='f1 c_52' id='c_52_1' href='#c_52_2' cs_f='.c_52' >o funcionamento do</span> sistema representado pela rede(HALDER;<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 23<br>
VENKATESWARLU, 2006).<br>
Figure 9 – Rede de petri<br>
Fonte: (HALDER; VENKATESWARLU, 2006)<br>
Descrever o funcionamento da RP apresentado na IMG<br>
Descrever quais propriedades podem ser verificadas com RP e onde será utilizado no seu<br>
trabalho.<br>
2.2.5 Verificação <span class='f1 c_106' id='c_106_1' href='#c_106_2' cs_f='.c_106' >de hardware<br>
Para</span> a verificação de hardware diversas técnicas têm sido propostas (). Por meio da Apresentar<br>
exem-<br>
plos<br>
com<br>
refer-<br>
ências<br>
simulação, visa assegurar que uma implemetação, descrição do hardware em qualquer qualquer<br>
nível de abstração da hierarquia de hardware, atinja suas especificações, propriedades que devem<br>
ser respeitadas para que a corretude do mesmo seja comprovada (GUPTA, 1992). A Verificação<br>
formal de hardware consiste na utilização de técnicas para corretude de circuitos lógicos, ou<br>
seja, consiste na utilização de modelos matemáticos para descrição de propriedade e/ou de<br>
comportamento de um dado sistema (KROPF, 2013).<br>
Entre as abordagens utilizadas na verificação formal de hardware consiste tanto na imple-<br>
mentação quanto a especificação estarem descritas em lógica formal, <span class='f1 c_120' id='c_120_1' href='#c_120_2' cs_f='.c_120' >neste caso a</span> corretude será<br>
obtida através da comprovada relação entre a implementação e a especificação (SEGER, 1992).<br>
A especificação formal consiste na descrição do comportamento, bem como, das propriedades<br>
do sistema em linguagem matemática, tornando-se crucial para <span class='f1 c_45' id='c_45_1' href='#c_45_2' cs_f='.c_45' >o processo de</span> verificação. Na<br>
implementação formal, o nível de abstração, tais como, Gate level e RTL são importantes infor-<br>
mações para <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >o desenvolvimento do</span> formalismo, bem como as classes, por exemplo se o circuito<br>
é sequencial ou combinacional, se utiliza pipeline, etc (KROPF, 2013).<br>
Apresentar <span class='f1 c_10' id='c_10_1' href='#c_10_2' cs_f='.c_10' >um exemplo de</span> RTL<br>
A utilização de Model Checking também se faz presente nos modelos formais de ver-<br>
ificação de hardware, onde apenas é utilizado o comportamento dos circuitos na verificação,<br>
de modo a verificar a se as propriedades presentes são satisfeitas. Para isso, são utilizados os<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 24<br>
conceitos da lógica proposicional, que por meio da utilização de fórmulas que representem as<br>
propriedades dos estados, é possível realizar as verificações necessárias (SEGER, 1992).<br>
Apresentar um exemplo com um circuito e como este pode ser verificando com model<br>
checking<br>
2.2.6 Verificação formal de software<br>
Observa-se que <span class='f1 c_50' id='c_50_1' href='#c_50_2' cs_f='.c_50' >o uso de</span> verificacão de software tem sido feito aplicado em muitas áreas,<br>
tais como, infraestruturas industriais de missão critica e de segurança. Logo, existe a necessidade<br>
de garantir a corretude destes sistemas. Devido a isso, a verificação formal tem sido utilizada em<br>
três principais abordagens, sendo elas (COUSOT; COUSOT, 2010; D’SILVA et al., 2008):<br>
Apresentar exemplos para os métodos apresentados abaixo<br>
• Métodos dedutivos: Produzem provas matemáticas formais de corretude usando provadores<br>
de teoremas ou assistentes de prova para execução da prova e necessitam da interação<br>
humana para prover os argumentos (COUSOT; COUSOT, 2010);<br>
• Verificação de modelos: Exploram exaustivamente modelos de execuções de programa,<br>
que podem ser sujeitos a explosão combinatória, necessário a intervenção humana para<br>
geração dos modelos (ROCHA et al., 2015b);<br>
• Analise estática: Engloba diversas técnicas para calcular automaticamente informações<br>
sobre o comportamento de um programa sem executá-lo, sendo utilizado em otimização<br>
de código e verificação em compiladres (D’SILVA et al., 2008).<br>
Segundo ROCHA et al., na verificação formal de software apresentam-se dificuldades,<br>
tais como: quais as propriedades são de interesse na verificação em tempo de execução; e<br>
impossibilidade matemática de provar a corretude de propriedades não triviais no comportamento<br>
de programas (COUSOT; COUSOT, 2010).<br>
2.2.7 Lógica proposicional<br>
A lógica proposicional é uma linguagem formal onde é definida um alfabeto e conectivos<br>
proposicionais, e um <span class='f1 c_1' id='c_1_1' href='#c_1_2' cs_f='.c_1' >conjunto de regras</span> gramaticais, as quais serão utilizadas para construção<br>
das proposições (SOUZA, 2017). Porém apesar de importante, ela é limitada, não podendo<br>
expressar sentenças elementares importantes, tais como a da aritmética elementar. Por exemplo:<br>
1. Todos são mortais.<br>
2. Alguém é bondoso.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 25<br>
Na lógica preposicional, não poderiam ser analisadas, pois não teria como decompor<br>
ambas em sentença e assim não teria como analisar as diferenças entre ambas(ABE, 2002).<br>
Contudo, no exemplo: Existem cavalos com patas verdes. A relação criada pela frase poderia a<br>
ser analisada pela lógica proposicional(ABE, 2002). Descrever<br>
como<br>
seria<br>
está<br>
analise<br>
Segundo SOUZA, alfabeto da lógica proposicional é formado por símbolo de pontuação,<br>
símbolos proposicionais e conectivos proposicionais, onde cada um apresenta uma função em<br>
específico, sendo:<br>
• Símbolos de pontuação: Apenas dois símbolos de pontuação são utilizados o "(" e o ")".<br>
• Símbolos proposicionais: São utilizados para representar as proposições, onde um sím-<br>
bolo P pode ser utilizado para representar uma proposição qualquer, por exemplo: P="Está<br>
chovendo". O conjunto de símbolos proposicionais é infinito e enumerável, sendo possível<br>
representar infinitos e enumerável conjunto de proposições.<br>
• Conectivos proposicionais: São os símbolos usando frequentemente na matemática. Os<br>
símbolos recebem a seguinte denominação:<br>
1. ¬: Representa a partícula de negação, ou seja, "Não".<br>
2. ?: Representa a partícula "Ou"<br>
3. ?: Representa a partícula "E"<br>
4. ?: Representa a partícula "Se então ou implica".<br>
5. ?: Representa a partícula "Se, e somente se".<br>
Ainda segundo SOUZA, existem as fórmulas que são constituídas de forma indutiva, <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >a<br>
partir de</span> símbolos do alfabeto conforme as regras apresentadas abaixo:<br>
• Todo o símbolo preposicional é uma fórmula<br>
• Se H é uma fórmula, então (¬H), a negação de H, é uma fórmula.<br>
• Se H e G são fórmulas, então a disjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a conjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o antecedente e G consequente da fórmula.<br>
• Se H e G são fórmulas, então a bi-implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o lado esquerdo e G o lado direito da fórmula.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 26<br>
2.2.8 Linguagem de especificação de propriedades<br>
Linguagem de especificação de propriedades, do inglês Property Specification Language<br>
- PSL, é uma notação formal para especificação de comportamento em sistemas eletrônicos,<br>
compatível com <span class='f1 c_9' id='c_9_1' href='#c_9_2' cs_f='.c_9' >as linguagens VHDL</span>, Verilog, SystemC e SystemVerilog. Destina-se a utilização Adicionar<br>
refer-<br>
ência<br>
a cada<br>
Ling<br>
citada<br>
para a especificação funcional, mas também para entrada de ferramentas de verificação. A<br>
especificação do PSL é a utilização de assertivas sobre propriedades de um sistema, sendo estas<br>
propriedades constituídas de três elementos: expressões boolenas, expressões sequenciais e<br>
operadores temporais (IEEE. . . , 2010).<br>
Corrigir a apresentação da citação IEEE... estranho<br>
Segundo (IEEE. . . , 2010), o PSL foi totalmente desenvolvida com o intuito fornecer<br>
leitura e escrita de fácil entendimento, sintaxe concisa, semântica formal e rigorosamente bem<br>
definida e ser matematicamente precisa, visto a utilização da mesma em processo de verificação.<br>
O PSL pode ser utilizado para capturar requisitos relativos ao comportamento total do projeto,<br>
bem como, sobre o modo que o mesmo deverá operar no ambiente, ms também para capturar<br>
requisitos comportamentais e os pressupostos que surgem <span class='f1 c_130' id='c_130_1' href='#c_130_2' cs_f='.c_130' >durante o processo de</span> design. Ambas<br>
podem ser utilizadas para verificação de sistemas.<br>
Apresentar exemplos de uso da PSL<br>
2.2.9 Verificação baseada em assertivas<br>
Verificação baseada em assertivas, do inglês Assertion-Based Verification - ABV, é um<br>
paradigma de verificação igualente adequado para verificação formal e abordagens baseadas em<br>
simulação (BOULE; ZILIC, 2005) e <span class='f1 c_56' id='c_56_1' href='#c_56_2' cs_f='.c_56' >em conjunto com</span> a tecnica de PSL tem ganhado aceitação<br>
como um método essencial para verificação funcional do hardware (DAHAN et al., 2005).<br>
Na ABV as assertivas são declaração adicionadas ao projeto com o intuito de especificar<br>
o comportamento do projeto (BOULE; ZILIC, 2005), podendo escritos em PSL ou em SVA<br>
(System Verilog Assertions). No caso deste projeto será utilizado a PSL, devido a mesma ser<br>
utilizada juntamente <span class='f1 c_35' id='c_35_1' href='#c_35_2' cs_f='.c_35' >com a linguagem VHDL</span>.<br>
Com a utilização de ABV o circuito pode ser verificado usando técnicas de simulação<br>
e/ou verificação, por exemplo, model checking, para garantir que o mesmo esteja de acordo<br>
com o pretendido projeto (DAHAN et al., 2005). Na Figura 19 apresenta o modelo de assertiva<br>
utilizada no projeto, utilizando de um modelo próprio para assertivas, unindo as funcionalidades<br>
já existentes nas assertivas do VHDL, mas também novas (serão apresentadas nas próximas<br>
seções), fornecendo assim mais propriedades a serem analisadas.<br>
Descrever qual o objetivo da assert apresentado<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 27<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 e n t i t y AND_ent i s<br>
5 p o r t ( x , y : i n b i t ;<br>
6 F : o u t b i t<br>
7 ) ;<br>
8 end AND_ent ;<br>
9<br>
10 a r c h i t e c t u r e behav1 of AND_ent i s<br>
11 b e g i n<br>
12 ??@c2vhdl : ASSERT<br>
13 ??a s s e r t n o t ( x= ’ 0 ’ and y= ’ 1 ’ )<br>
14 ?? r e p o r t " Both v a l u e s o f s i g n a l s x and y a r e e q u a l t o 1 "<br>
15 ??s e v e r i t y ERROR;<br>
16 ??@c2vhdl :END<br>
17<br>
18 p r o c e s s ( x , y )<br>
19 b e g i n<br>
20 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
21 F &lt;= ’ 1 ’ ;<br>
22 e l s e<br>
23 F &lt;= ’ 0 ’ ;<br>
24 end i f ;<br>
25 end p r o c e s s ; 4<br>
26 end behav1 ;<br>
Fonte: Própria.<br>
2.2.10 Propriedades de segurança<br>
Propriedades de segurança é um meio de validação do comportamento de um determinado<br>
sistema, de modo que se uma dada propriedade de segurança for violada, então através de<br>
uma execução finita, é possível verificar tal erro. Algumas propriedades de segurança, no<br>
entanto, podem impor requisitos em fragmentos de caminho finito e não podem ser verificadas<br>
considerando apenas os estados alcançáveis. (BAIER et al., 2008).<br>
Segundo (CLARKE et al., 2003), podemos definir uma propriedade de segurança como:<br>
dado <span class='f1 c_105' id='c_105_1' href='#c_105_2' cs_f='.c_105' >um sistema de</span> transições ST = (S, S0, E), seja um conjunto B ? S que especifica um<br>
conjunto de maus estados tais que S0 ?B = ?, pode-se dizer que ST é seguro com relação a B,<br>
denotado por ST |= AG¬B se não existe um caminho no sistema de transição do estado inicial<br>
S0 até o estado B, de outro modo é dito que ST não é seguro.<br>
Adicionar exemplos de propriedades de segurança em hardware<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 28<br>
2.3 Técnicas de compiladores<br>
Compiladores são sistemas de software utilizados para tradução de uma linguagem de<br>
programação para outra, ou seja, o programa da linguagem fonte é lido e traduzido para um<br>
código equivalente na outra linguagem, ou linguagem alvo. Geralmente utilizada para transformar<br>
trechos de código em uma linguagem a ser executada pelo computador (AHO et al., 2007).<br>
Diversas técnicas podem ser utilizadas nas diversas etapas, até que o código seja traduzido,<br>
tais como LL(1) e LR na análise sintática; eliminação de código morto; propagação de constante<br>
e Peephole na otimização de código(AHO et al., 2007). Neste projeto serão focados as áreas de<br>
transformações de código e otimização de código.<br>
2.3.1 Transformações de código<br>
Transformações de código correspondem a uma complexa função que envolve analise <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >de<br>
fluxo de dados</span> e modificação completa do programa que são parte integral da alta performance e<br>
sistemas computacionais. Podem ser classificados em transformações escalares que reduzem<br>
o número de instruções a serem executadas no programa ou transformações paralelas que<br>
maximizam o paralelismo (SRIKANT; SHANKAR, 2002).<br>
A Figura 11 representa o trecho de código <span class='f1 c_117' id='c_117_1' href='#c_117_2' cs_f='.c_117' >apresentado na Figura 19. O</span> trecho representa<br>
o comportamento das entradas, neste caso de um código da porta AND. E a figura Figura 12<br>
representa a tradução deste trecho em código na linguagem C. Esta tradução foi realizada pela<br>
ferramenta V2C, utilizada neste projeto. Adicionar<br>
refer-<br>
ência<br>
Figure 11 – Trecho de código em VHDL representando porta AND.<br>
1 p r o c e s s ( x , y )<br>
2 b e g i n<br>
3 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
4 F &lt;= ’ 1 ’ ;<br>
5 e l s e<br>
6 F &lt;= ’ 0 ’ ;<br>
7 end i f ;<br>
8 end p r o c e s s ;<br>
Fonte: Própria.<br>
Expandir esta seção. Apresentar propriedades de transformação e técnicas para avaliar a<br>
transformação<br>
2.3.2 Otimização de código<br>
A otimização de código consiste na melhoria do código intermediário gerado pelos<br>
algoritmos de compilação com o objetivo de obter um menor tempo de execução do programa,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 29<br>
Figure 12 – Trecho de código traduzido para linguagem C.<br>
1 /? S t a r t o f T r a n s l a t i o n ? /<br>
2 /? p0 : ? /<br>
3 i f ( chg [ x ] | | chg [ y ] ) {<br>
4 i f ( ( ( o l d [ x ]==1) && ( o l d [ y ]==1) ) ) {<br>
5 new [ f ] = 1 ;<br>
6 }<br>
7 e l s e {<br>
8 new [ f ] = 0 ;<br>
9 }<br>
10 }<br>
11 /? End o f T r a n s l a t i o n ? /<br>
Fonte: Própria.<br>
porém outros fatores podem ser introduzidos, como algoritmos menores. Este fato não implica<br>
em afirmar que o melhor código é gerado, visto que dada a complexidade, raramente pode ser<br>
obtido que o código gerado pode ser o melhor possível (AHO et al., 2007).<br>
Segundo AHO et al., otimização local de código consiste na otimização <span class='f1 c_108' id='c_108_1' href='#c_108_2' cs_f='.c_108' >de um bloco</span><br>
básico de código, ou seja, a otimização ocorre em um trecho especifico de código. Os blocos<br>
básicos são trecho onde não ocorrem saltos ou loops, para nenhuma outra parte do código. A<br>
otimização global de código é baseado na analise <span class='f1 c_63' id='c_63_1' href='#c_63_2' cs_f='.c_63' >do fluxo de dados, de</span> modo que ocorra as<br>
elminação de instruções não necessárias ou substituição mais facil. A otimização global consite<br>
na analise completa do código. Neste sentido, nas próximas seções serão apresentadas algumas<br>
importantes técnicas de otimizações.<br>
2.3.2.1 Grafo Acliclico Direcional - GAD<br>
Grafo Aciclico Direcional é utilizado para diversos fins dentro <span class='f1 c_101' id='c_101_1' href='#c_101_2' cs_f='.c_101' >da estrutura de</span> compi-<br>
ladores, principalmente para geração da parse tree otimização de código. <span class='f1 c_129' id='c_129_1' href='#c_129_2' cs_f='.c_129' >Pode ser usado</span> na<br>
representação de instruções unicas blocos básicos de código(AHO et al., 2007). <span class='f1 c_50' id='c_50_1' href='#c_50_2' cs_f='.c_50' >O uso de</span> GAD<br>
permite a melhoria de de código, tais como:<br>
• Elminação de subexpressões locais comuns, ou seja, expressões que o valor já foi com-<br>
putado anteriomente;<br>
• Eliminação de código morto;<br>
• Reordernamento de declarações buscando reduzir o tempo que o valor temporário necessita<br>
ser preservado em um registro;<br>
A Figura 13 apresenta um bloco básico com algumas instruções, no caso apresentando<br>
são 4 operações entre somas e multiplicação e a partir deste bloco a Figura 14 apresenta o GDA<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 30<br>
Figure 13 – Exemplo de bloco basico de código.<br>
1 <span class='f1 c_81' id='c_81_1' href='#c_81_2' cs_f='.c_81' >a = b + c</span><br>
2 b = a ? d<br>
3 c = b + c<br>
4 d = a ? d<br>
Fonte: (AHO et al., 2007)<br>
Figure 14 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
deste trecho de código. Nele apresenta cada nó como uma operação especifica e os terminais<br>
como as parcelas das operações.<br>
2.3.2.2 Grafo <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >de Fluxo de</span> Controle - GFC<br>
Grafo <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >de fluxo de</span> controle corresponde a um grafo direcionado, no qual cada nó rep-<br>
resenta blocos básicos e cada aresta representa os caminhos de fluxo entre os blocos basi-<br>
cos (ALLEN, 1970). É importante ressaltar que saltos determinam o final de um determinado<br>
bloco básico, ou seja, saltos indicam um caminho para uma nova região de código básico (AHO<br>
et al., 2007).<br>
Apresentar <span class='f1 c_10' id='c_10_1' href='#c_10_2' cs_f='.c_10' >um exemplo de</span> como e utilizado em código<br>
2.3.2.3 Eliminção de código morto<br>
A eliminacação de código morto é uma técnica que busca a eficiência de um programa<br>
evitando a execução de instruções não necessária em tempo de execução (KNOOP et al., 1994).<br>
O código morto consiste em instruções que não serão alcançáveis durante o fluxo do programa,<br>
sendo esta técnica basicamente a retirada de qualquer variável que não será utilizada em qualquer<br>
outro nó do grafo (AHO et al., 2007).<br>
A utilização de GAD corresponde na eliminação de qualquer nó raiz, ou seja, nó sem<br>
ancestrais, as quais não esteja ativa anexada a mesma. A execução repetida desta operação<br>
removerá todos os nós correspondentes a código morto (AHO et al., 2007).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 31<br>
Figure 15 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
Na Figura 15, supondo que os nós <span class='f1 c_89' id='c_89_1' href='#c_89_2' cs_f='.c_89' >a, b e</span> c estejam ativa, porém o nó énão esteja, o último Corrigir<br>
nó é?pode ser eliminado imediatamente. Os nós restantes continuam no GDA, a menos que não tenho<br>
variáveis ativas atreladas aos nós (AHO et al., 2007).<br>
2.3.2.4 Análise <span class='f1 c_63' id='c_63_1' href='#c_63_2' cs_f='.c_63' >do fluxo de dados</span><br>
Análise <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >de fluxo de dados</span> refere-se ao conjunto de técnicas que derivam informações<br>
sobre <span class='f1 c_3' id='c_3_1' href='#c_3_2' cs_f='.c_3' >o fluxo de dados</span> ao longo dos caminhos de execução do programa. Para análise do<br>
programa, é necessário considerar todas as posiveis execuções através do grafo <span class='f1 c_12' id='c_12_1' href='#c_12_2' cs_f='.c_12' >de fluxo de</span><br>
controle (AHO et al., 2007).<br>
Apresentar exemplos<br>
2.3.2.5 Gerador de código<br>
O gerador de código é responsavél pela tradução final do programa-fonte para o programa-<br>
alvo, o mesmo recebe como entrada um código intermediário juntamente com a tabela de<br>
símbolos. Faz-se necessário que o programa-fonte tenha sido analisado sintatica e lexicamente,<br>
assim evitando que erros possam ser passados para o programa-alvo, <span class='f1 c_19' id='c_19_1' href='#c_19_2' cs_f='.c_19' >por outro lado</span> a existência<br>
de uma nível de otimização, faz-se opicional neste caso (AHO et al., 2007).<br>
O gerador de código possui três tarefas primarias, sendo as mesmas seleção de instrução,<br>
alocação de registros e atribuições. A seleção de instruções envolve a escolha das instruções<br>
apropriadas da máquina-alvo para implementar as declarações do código intermediario. A<br>
atribuição e atribuição de registros envolve a decisão sobre os valores a serem registrados nos<br>
registros(AHO et al., 2007).<br>
Apresentar exemplo<br>
32<br>
3 TRABALHOS CORRELATOS<br>
Sugiro apenas mencionar que foi feito a revisão sistemática; o que já foi feito e os resul-<br>
tados. As outras seções sobre RS e mover para apêndice.<br>
3.1 Revisão sistemática<br>
A revisão sistemática consiste é um método de identificação, análise e interpretação de<br>
pesquisas relevantes em determinada área ou questão de pesquisa. Para execução da revisão sis-<br>
temática se requer um esforço maior, em comparação as pesquisas tradicionais, sendo necessário<br>
seguir uma sequência de passos metodológicos sobre a área ou questão de pesquisa ao qual<br>
deseja ser feita a pesquisa (KITCHENHAM, 2004).<br>
Para a execução da revisão sistemática, é necessário um esforço considerável, se com-<br>
parado a uma revisão informal a literatura. Enquanto que a revisão de literatura informal é<br>
conduzida de forma ad-hoc, sem planejamento e critérios de seleção estabelecidos a priori,<br>
a revisão sistemática requer um protocolo formal bem definido, com uma sequência de pas-<br>
sos metodológicos, para conduzir uma pesquisa sobre o tema ao qual deseja-se realizar a<br>
pesquisa (MAFRA; TRAVASSOS, 2006).<br>
A aplicação da revisão sistemática requer que seja seguido um conjunto bem definido e<br>
sequêncial de passos, seguindo um protocolo de pesquisa desenvolvido previamente. Através<br>
deste método é possível realizar uma extensa pesquisa, contemplando uma grande quantidade<br>
de informações sobre o assunto pesquisado (MAFRA; TRAVASSOS, 2006). Este protocolo é<br>
construído considerando um tema específico <span class='f1 c_66' id='c_66_1' href='#c_66_2' cs_f='.c_66' >que representa o</span> elemento central da investigação,<br>
onde os passos da pesquisa, as estratégias definidas para coletar as evidências e o foco das<br>
questões de pesquisa são definidas explicitamente, de tal forma que outros pesquisadores sejam<br>
capazes de reproduzir o mesmo protocolo de pesquisa (BIOLCHINI et al., 2005).<br>
Segundo MAFRA; TRAVASSOS, o processo para a condução de revisões sistemáticas<br>
envolve três etapas:<br>
1. Planejamento da Revisão: os objetivos da pesquisa são listados e o protocolo da revisão<br>
é definido.<br>
2. Condução da Revisão:nesta atividade, as fontes para a revisão sistemática são sele-<br>
cionadas, os estudos primários são identificados, selecionados e avaliados de acordo com<br>
os critérios de inclusão, exclusão, e de qualidade estabelecidos durante o protocolo da<br>
revisão.<br>
Chapter 3. TRABALHOS CORRELATOS 33<br>
3. Análise dos Resultados: os dados dos estudos são extraídos e sintetizados para análise e<br>
apresentação dos resultados.<br>
Vale ressaltar que como o objetivo deste trabalho é realizar um estudo exploratório de<br>
caracterização de área podemos dizer que esta revisão sistemática se caracteriza como uma quasi-<br>
sistemática (TRAVASSOS et al., 2008), pois segue o mesmo processo da revisão sistemática e<br>
preserva o rigor e mesmo formalismo para as fases metodológicas de elaboração de protocolo e<br>
execução da revisão, mas sem a aplicação de uma meta-análise a princípio, que pode ser aplicada<br>
posteriormente.<br>
3.1.1 Planejamento da Revisão Sistemática<br>
Objetivo: Este estudo tem o objetivo esquematizado <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >a partir da</span> estrutura do paradigma<br>
GQM (do ingles Goal,Question and Metric)(BASILI et al., 1994).<br>
Analisar Publicações científicas através de um estudo baseado em revisão sis-<br>
temática<br>
Com propósito de Identifica-las<br>
Com relação as Vantagens e desvantagens da utilização de assertiva e transformações<br>
de código na verificação do código na linguagem de descrição VHDL<br>
Do ponto de vista do Pesquisador<br>
No contexto Acadêmico ou industrial para verificação de assertivas na linguagem<br>
de descrição VHDL<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM<br>
Formulação da Pergunta: Buscamos respostas para as seguintes perguntas:<br>
• Q1: Quais são os métodos para verificação de circuitos lógicos descritos na linguagem de<br>
programação VHDL?<br>
– Q1.1: Foi desenvolvido e está disponível alguma ferramenta para aplicação do<br>
método?<br>
– Q1.2: Qual a técnica de exploração de estados para circuitos lógicos?<br>
– Q1.3: O método proposto é baseado em técnicas de verificação de software?<br>
– Q1.4: Como o método proposto valida pré e pós condições no programa?<br>
– Q1.3: Foi utilizado algum benchmark de programas em VHDL para experimentação<br>
e o mesmo encontra-se disponível?<br>
– Q1.4: Quais as perspectivas futuras para melhorar da aplicação do método proposto?<br>
Escopo da pesquisa:Na delimitação do escopo da pesquisa foram estabelecidos critérios,<br>
buscando garantir a viabilidade da execução, acessibilidade dos dados e abrangência do estudo re-<br>
alizado. A pesquisa dar-se-á <span class='f1 c_25' id='c_25_1' href='#c_25_2' cs_f='.c_25' >a partir de</span> bibliotecas digitais através das suas respectivas máquinas<br>
Chapter 3. TRABALHOS CORRELATOS 34<br>
de busca e, quando os dados não estiverem disponíveis eletronicamente, através de consultas<br>
manuais.<br>
Critérios de Seleção de Fontes. Para as bibliotecas digitais é desejado:<br>
• Possuir uma máquina de busca que permita <span class='f1 c_50' id='c_50_1' href='#c_50_2' cs_f='.c_50' >o uso de</span> expressões lógicas ou mecanismo<br>
equivalente.<br>
• Incluir em sua base, publicações de exatas ou correlatas que possuam relação direta com o<br>
tema a ser pesquisado<br>
• As máquinas de busca deverão permitir a busca no texto completo das publicações.<br>
Segundo ROCHA et al., os mecanismos de busca utilizados devem garantir resultados<br>
únicos através da busca de um mesmo conjunto de palavras-chaves (string de busca). Quando<br>
isto não for possível, deve-se estudar e documentar uma forma de minimizar os potenciais efeitos<br>
colaterais desta limitação.<br>
Métodos de Busca das Publicações. As fontes digitais foram acessadas via Web, através<br>
de expressões de busca pré-estabelecidas. A biblioteca digital consultada foi a Scopus, acessível<br>
em http://www.scopus.com. Segundo a editora ELSEVIER, a Scopus é uma das maiores bases<br>
<span class='f1 c_121' id='c_121_1' href='#c_121_2' cs_f='.c_121' >de dados de</span> resumos e citações da literatura de pesquisa peer-reviewed com mais de 22, 800<br>
títulos de mais de 5, 000 editoras internacionais abrangendo as áreas de tecnologia, medicina,<br>
artes, ciências sócias e com atualizações diárias. Entre as editoras podemos citar: Springer<br>
(SPRINGER, 2018); IEEE Xplore Digital Library (IEEE, 2018);ACM Digital Library (ACM,<br>
2018) ; ScienceDirect/Elsevier (B.V, 2018); Wiley Online Library (SONS, 2018); dentre outras.<br>
String de Busca. A string de busca foi definida segundo o padrão PICO (do inglês<br>
Population, Intervention, Comparison, Outcomes) (KITCHENHAM et al., 2009), conforme a<br>
estrutura abaixo:<br>
• População: Trabalhos publicados em conferências e periódicos que relacionam verificação<br>
de propriedades de circuitos lógicos em códigos para a descrição de hardware.<br>
• Intervenção: Verificação de propriedades relacionadas a verificação de circuitos para as<br>
diferentes estruturas <span class='f1 c_46' id='c_46_1' href='#c_46_2' cs_f='.c_46' >das linguagens de</span> descrição de hardware;<br>
• Comparação: análise de cobertura e suporte das abordagens identificadas para a verificação<br>
de propriedades <span class='f1 c_46' id='c_46_1' href='#c_46_2' cs_f='.c_46' >das linguagens de</span> descrição de hardware;<br>
• Resultados: <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >a partir da</span> descrição das abordagens pretende-se verificar a cobertura que cada<br>
abordagem apresenta na manipulação das diferentes estruturas da linguagem de descrição<br>
<span class='f1 c_106' id='c_106_1' href='#c_106_2' cs_f='.c_106' >de hardware para</span> a verificação de propriedades baseada em assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 35<br>
Segundo ROCHA et al., como este estudo representa um estudo de mapeamento/caracteri-<br>
zação, a string de busca foi definida de acordo com dois aspectos: População e Intervenção, como<br>
é apresentado na estrutura abaixo. Posteriormente esta mesma string de busca será executada<br>
na biblioteca Scopus para busca de artigos e publicações de modo a gerar uma interseção entre<br>
população e intervenção.<br>
• População: publicações que fazem referência a verificação de propriedades de circuitos<br>
lógicos e sinônimos:<br>
– Palavras-chaves: "circuit checker" OR "circuit verification" OR "contract based<br>
verification" OR "code analysis" OR "static analysis" OR "dynamic analysis" OR<br>
"safety verification" OR "RTL analysis" OR "program analysis" OR "property veri-<br>
fication" OR "formal verification" OR "model checking" OR "model checker" OR<br>
"hardware checker" OR "hardware verification" OR "validity checker" OR "hard-<br>
ware assertion" OR "assertion checker" OR "assert verification" OR "assertion-based<br>
verification" OR "assertion based verification" OR "assertion-based design" OR "bit<br>
level verification"<br>
• Intervenção: Verificação de circuitos e sinônimos:<br>
– Palavras-chaves:"hardware statement" OR "hardware code" OR "hardware source<br>
code" OR "hardware semantics" OR "hardware property" OR "logical gates" OR<br>
"sequential circuit" OR "parallel circuit" OR "real circuits" OR "complex circuits"<br>
OR "control circuitry" OR ”software netlist” OR “hardware emulation” OR “silicon<br>
debug”<br>
3.1.1.1 Procedimentos de Seleção e Critérios<br>
A estratégia de busca será aplicada por um pesquisador para identificar as publicações<br>
em potencial. A seleção das publicações dar-se-á em 2 etapas, conforme apresentado a seguir.<br>
1. Seleção e catalogação preliminar dos dados coletados: A seleção preliminar das publi-<br>
cações será feita <span class='f1 c_28' id='c_28_1' href='#c_28_2' cs_f='.c_28' >a partir da</span> aplicação da string de busca na biblioteca Scopus, o resultado<br>
desta busca corresponde a seleção preliminar. Todas as publicações serão armazenadas<br>
para análise posterior;<br>
2. Seleção dos dados relevantes - [1 filtro]: A seleção preliminar com o uso da expressão<br>
de busca não garante que todo o material coletado seja útil no contexto da pesquisa, pois a<br>
aplicação das expressões de busca é restrita ao aspecto sintático. Por isso, é necessário a<br>
criação de filtros de exclusão e inclusão, de modo a classificar os artigos e publicações que<br>
se enquadram no contexto da pesquisa realizada. Nesta epata apenas serão lidos o título,<br>
abstracts, e palavras-chaves e classificar de acordo com os filtros, ou seja, se será aceito ou<br>
excluído. Devem ser excluídas as publicações contidas no conjunto preliminar que:<br>
Chapter 3. TRABALHOS CORRELATOS 36<br>
• CE1-01: Não serão selecionadas publicações em que as palavras-chave da busca<br>
não apareçam no título, resumo e/ou texto da publicação (excluem-se os seguintes<br>
campos: as seções de agradecimentos, biografia dos autores, referências bibliográficas<br>
e anexas).<br>
• CE1-02: Não serão selecionadas publicações em que descrevam e/ou apresentam<br>
‘keynote speeches’, tutoriais, cursos e similares.<br>
• CE1-03: Não serão selecionadas publicações <span class='f1 c_78' id='c_78_1' href='#c_78_2' cs_f='.c_78' >em que o</span> contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação/validação de códigos para descrição de hardware.<br>
• CE1-04: Não serão selecionadas publicações <span class='f1 c_78' id='c_78_1' href='#c_78_2' cs_f='.c_78' >em que o</span> contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação de código de descrição de hardware baseado em assertivas ou propriedades<br>
de verificação <span class='f1 c_37' id='c_37_1' href='#c_37_2' cs_f='.c_37' >de hardware.<br>
Podem</span> ser incluídas apenas as publicações contidas no conjunto preliminar que:<br>
• CI1-01:Podem ser selecionadas publicações <span class='f1 c_78' id='c_78_1' href='#c_78_2' cs_f='.c_78' >em que o</span> contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita uma abordagem para verificação<br>
de código de descrição de hardware baseado em assertivas ou propriedades de<br>
verificação de hardware.<br>
• CI1-02:Podem ser selecionadas publicações <span class='f1 c_78' id='c_78_1' href='#c_78_2' cs_f='.c_78' >em que o</span> contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita recomendações de melhoria<br>
na utilização de abordagens para verificação de código de descrição de hardware<br>
baseado em assertivas ou propriedades de verificação de hardware.<br>
3. Seleção dos dados relevantes - [2 filtro]: Apesar do 1o filtro limitar o universo de busca,<br>
infelizmente não há garantias de que todo material selecionado no filtro anterior seja útil<br>
no contexto da pesquisa. Neste caso, novos filtros são gerados, buscando, <span class='f1 c_73' id='c_73_1' href='#c_73_2' cs_f='.c_73' >da mesma forma<br>
que</span> o primeiro filtro, classificar os artigos e publicações que se enquadram no contexto<br>
da pesquisa. Para este filtro é necessário a leitura na integras dos artigos selecionados<br>
anteriormente. O objetivo é identificar que relacionam assertivas e/ou propriedade de<br>
verificação de hardware.<br>
• CS2 -ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware e não citam assertivas<br>
• CS2 +ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware, mas citam assertivas<br>
• CS2 -ASS +VER_HARD: Não devem ser selecionadas publicações que contextual-<br>
izam verificação de hardware, mas citam assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 37<br>
Dessa forma, todas as publicações devem respeitar o critério abaixo:<br>
• CS3 +ASS +VER_HARD: Serão selecionadas publicações que contextualizam<br>
verificação de hardware e citam assertivas em seu contexto.<br>
Devido ao tempo necessário para o desenvolvimento execução dos filtros da revisão<br>
sistemática serem extensos, apenas o primeiro filtro foi executado neste projeto, mesmo que<br>
os parâmetros para o segundo filtro já tenho sido desenvolvidos. Em contra partida foram<br>
selecionados 6 artigos que serviram como ferramentas de estudo para o desenvolvimento da<br>
metodologia que será apesentada no Capítulo 4.<br>
3.2 Revisão da literatura<br>
Nesta sessão serão apresentados trabalho relevantes para <span class='f1 c_17' id='c_17_1' href='#c_17_2' cs_f='.c_17' >o desenvolvimento do</span> método<br>
proposto que foram identificados utlizando a revisão sistemática mencionado anteriormente.<br>
Os artigos apresentam técnicas de transformações de código, utilização de Assertion-Based<br>
Verification e PSL para verificação de hardware.<br>
3.2.1 V2c-A verilog to C translator<br>
O artigo de MUKHERJEE et al. apresenta uma ferramenta implementada em C++<br>
chamada v2c para transformação de código da linguagem de descrição Verilog para linguagem<br>
de programação C. A ferramenta é executada a nível de palavra, visto que esta abordagem garante<br>
uma aumento na escalabilidade, mas também proporionando que técnicas, como interpolaçãoe adicionar<br>
refer-<br>
ência<br>
aceleração de looppossam ser utilizadas para verificação, algo inviavél, caso a tradução fosse<br>
adicionar<br>
refer-<br>
ência<br>
executada a nível de bit. O sistema recebe como entrada um código em Verilg, onde são aplicadas<br>
regras semânticas e mapeando os bit de operação, chamado software netlist. Após isso, o código<br>
intermediário é convertido para C.<br>
A contribuição deste trabalhoconsiste na utilização de transformações de código como<br>
Qual<br>
tra-<br>
balho?<br>
base principal e partindo deste pressuposto torna-se vantajoso devido a utilização de outras<br>
ferramentas que não apresente suporte a certas linguagens, tais com a ferramenta ESBMC,<br>
utilizada neste trabalho, não apresenta suporte a VHDL, porém apresenta suporte as linguagens<br>
C/C++. Em outras palavras, a contribuição deste trabalhofoi a utilização de traduções de códigos<br>
Qual<br>
tra-<br>
balho?<br>
e utilizado este conceito como modelo de entrada para analise de circuitos.<br>
3.2.2 Unbounded safety verification for hardware using software ana-<br>
lyzers<br>
No artigo de MUKHERJEE et al. foi apresentado uma metodologia que aborda a utiliza-<br>
ção de técnicas e analisadores de software, com o objetivo de de abordar a análise de circuitos e<br>
Chapter 3. TRABALHOS CORRELATOS 38<br>
com isso trançar um paralelo entre as abordagens. Para testes foram utilizadas três metodologias<br>
de análise, usando interpolação, k-inductione tecnologias hibrídas. Como resultante dos testes, foi adicionar<br>
refer-<br>
ência<br>
adicionar<br>
refer-<br>
ência<br>
observado as principais causas de erros, por exemplo, bits não preciso e no caso das operações<br>
a bit-level ocorria perda de informações. Também foi obeservado que apesar de não serem<br>
otimizadas para análises de hardware, alguns analisadores de softaware podem, dependendo da<br>
técnica utilizada no analisador, ser utilizada para analise de hardware.<br>
Descrever<br>
qual<br>
o mo-<br>
tivo.<br>
A utilização de técnicas de análise de software para o desenvolvimento de análise de<br>
hardware é o foco a ser abordado neste neste trabalho de maneira prática, utilizando os princípio<br>
analisados por (MUKHERJEE et al., 2016a). Neste contexto, o objetivo deste trabalho é a<br>
utilização de técnicas de software para análise de circuitos, diferente do artigo apresentado acima<br>
que busca utilização uma abordagem mais complexa provando a possibilidade da utilização de<br>
técnicas de analise de software no contexto da verificação de hardware.<br>
A última frase está confusa, no meu entedimento é o mesmo sentido.<br>
3.2.3 Formal verification of timed VHDL programs<br>
No trabalho apresentado por BARA et al. é proposto uma abordagem para a análise<br>
de tempo relacionado a cada porta lógica <span class='f1 c_31' id='c_31_1' href='#c_31_2' cs_f='.c_31' >dentro de um</span> dado circuito analisado. A abordagem<br>
apresenta a tradução <span class='f1 c_18' id='c_18_1' href='#c_18_2' cs_f='.c_18' >de um circuito</span> lógico codificado em VHDL para um formalismo baseado<br>
em automato de tempo. Tal formalismo é representado por uma automato de estados finitos referência<br>
com relogios simbólicos que evoluem em taxa uniforme. A tradução é executada de modo<br>
automatico, baseado na emulação da propagação de cada transação ao longo <span class='f1 c_91' id='c_91_1' href='#c_91_2' cs_f='.c_91' >de cada sinal</span>, o<br>
seja, são automatos programados e cronometrados do circuito. Após a tradução para automato, a<br>
analise é feita pela ferramenta UPPALque é um model checking de verificação de propriedades referência<br>
de tempo. Seguindo esta metodologia a análise pode ser extraida de modo independente de cada<br>
bloco, desta forma a análise é feita de forma mais precisa, podendo ser analisado inumeros<br>
fatores, tais como limites de intervalo e sinal de correlação.<br>
O artigo apresenta uma abordagem de tempo, que torna-se interessante adição ao método.<br>
Porém até o momento a função não foi implementada ficando a trabalho futuros.<br>
Expandir o texto acima, exemplo, descrever como o método poderia ser incluindo no seu<br>
TCC.<br>
3.2.4 On the use of assertions for embedded-software dynamic verifica-<br>
tion<br>
Em GUGLIELMO et al. é apresentado uma metodologia para a integração dinamica de<br>
Assertion-Based Verification para várias fases da análise da verificação de fluxo em sistemas<br>
embarcados, por exemplo, emulação, diagnosticos e Debug, mas também um ferramenta chamada<br>
Chapter 3. TRABALHOS CORRELATOS 39<br>
RadCheck. O metodo de aplicação, chamado V-model é dividido em fases de verificação em<br>
paralelo com as fases de design do circuito. Com base no V-model, o método é aplicado, iniciando<br>
com o nível de sistema e as especificação do sistema, neste caso especificado usando PSL.<br>
Neste nível é especificado todas as funcionalidades gerais da aplicação. No nível de integração<br>
visa investigar problemas de interação que possam ocorrer, definindo propriedades que cobrem<br>
incrementalmente as unidades estruturais interativas de aplicação. No nível de unidade descrevem<br>
comportamentos internos e são definidas através de parâmetros de entrada/saída das unidade e<br>
estruturas de dados internas.<br>
A contribuição deste projeto está relacionado a utilização de assertivas no contexto da<br>
verificação de software. As assertivas são o principal meio de análise proposto neste projeto,<br>
visto que estas mesma assertivas serão analisadas pelo ESBMC. Aliado a isso em GUGLIELMO<br>
et al. é apresentado modelos de utilização de assertivas no processo de verificação de hardware,<br>
e tais assertivas foram adaptadas para um modelo proposto neste trabalho.<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation<br>
No trabalho de BOULE; ZILIC é apresentado <span class='f1 c_48' id='c_48_1' href='#c_48_2' cs_f='.c_48' >uma ferramenta de</span> geração de assertivas<br>
no contexto da emulação de circuitos, de modo que estas assertivas descrita em PSL possam<br>
transformadas para o modelo de linguagem de descrição de hardware. Inicialmente é realizada<br>
toda análise de cada assertiva e a mesma é traduzida em partes, levando em consideração <span class='f1 c_111' id='c_111_1' href='#c_111_2' cs_f='.c_111' >os<br>
operadores e</span> cada estrutura, por exemplo if-else, utilizado na declaração da assertiva.<br>
Apresentar um exemplo para explicar o texto acima<br>
trabalho de BOULE; ZILIC consolida e apresenta aspectos importantes, tais como a<br>
utilização de uma ferramenta para geração de assertivas, o que torna-se no contexto deste projeto,<br>
extremamente importante, visto que o modelo adotado atualmente consiste tanto na geração<br>
automática das assertivas, bem como a inserção manual por parte do usuário.<br>
40<br>
4 MÉTODO PROPOSTO<br>
Este Capítulo descreve o método proposto neste trabalho, baseado transformações de<br>
código para análise de circuitos lógicos descritos em VHDL utilizando Bounded Model Checking,<br>
neste caso o model checker ESBMC.<br>
4.1 Visão geral do método<br>
O método proposto consiste inicialmente em receber como entrada um circuito lógico<br>
descrito em VHDL, onde uma dada propriedade representada em uma assertiva será analisada,<br>
as assertivas serão inseridas de automaticamente pelo método ou pelo próprio usuário do método.<br>
O código VHDL analisado posteriomente é traduzido para linguagem C e recebe uma instrumen-<br>
tação de código (com funções especificas suportadas pelo método) para a posterior validação do<br>
mesmo. O Código em C automaticamente gerado, já instrumentado, será processado e analisado<br>
pelo ESBMC de acordo com as assertivas inseridas e ao final é apresentado o resultado. Caso<br>
alguma das assertivas seja violada, um contra-exemplo é apresentado ao usuário. Uma visão<br>
geral do método proposto é <span class='f1 c_117' id='c_117_1' href='#c_117_2' cs_f='.c_117' >apresentado na Figura 16 e</span> nas sessões a seguir serão apresentados<br>
cada etapa do método proposto neste trabalho.<br>
Figure 16 – Ciclo da ferramenta<br>
Fonte: Própria<br>
Com o intuito de auxiliar nas explicações apresentadas nas próximas sessões, o código<br>
na Figura 17 será utilizado nas explanações, bem como será apresentado todas as alterações do<br>
mesmo, conforme cada etapa do método.<br>
Chapter 4. MÉTODO PROPOSTO 41<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 ENTITY U l a _ t c c IS<br>
5 PORT(A, B , B i n v e r t i d o , Op1 , Op2 : IN BIT ;<br>
6 R e s u l t a d o :OUT BIT ) ;<br>
7 END U l a _ t c c ;<br>
8<br>
9 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
10 SIGNAL a n d _ p o r t : b i t ;<br>
11 SIGNAL o r _ p o r t : b i t ;<br>
12 SIGNAL x o r _ p o r t : b i t ;<br>
13 SIGNAL mux2x1 : b i t ;<br>
14 BEGIN<br>
15 PROCESS(A, B , B i n v e r t i d o , Op1 )<br>
16 BEGIN<br>
17 ??PORTA AND<br>
18 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
19 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
20 ELSE<br>
21 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
22 END IF ;<br>
23 ??PORTA OR<br>
24 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
25 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
26 ELSE<br>
27 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
28 END IF ;<br>
29 ??PORTA XOR<br>
30 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
31 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
32 ELSIF (A = ’ 1 ’ and mux2x1 = ’ 1 ’ ) THEN<br>
33 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
34 ELSE<br>
35 x o r _ p o r t &lt;= ’ 1 ’ ;<br>
36 END IF ;<br>
37 ??INVERSOR<br>
38 IF ( B i n v e r t i d o = ’ 0 ’ ) THEN<br>
39 mux2x1 &lt;= B ;<br>
40 ELSE<br>
41 mux2x1 &lt;= NOT B ;<br>
42 END IF ;<br>
43 ??MUX4X1<br>
44 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
45 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
46 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
47 R e s u l t a d o &lt;= o r _ p o r t ;<br>
48 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
49 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
50 <span class='f1 c_41' id='c_41_1' href='#c_41_2' cs_f='.c_41' >END IF ;<br>
51 END PROCESS ;<br>
52 END</span> U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 42<br>
4.2 Preprocessamento do VHDL e inserção de assertivas<br>
A fase inicial do método consiste no preprocessamento do código VHDL com as an-<br>
otações de código pelo usuário ou pelo método proposto de forma automática, incluindo as<br>
assertivas, conforme a Figura 16, na etapa A. O método não realiza qualquer tipo de verificação<br>
sobre o código VHDL, apenas utiliza o mesmo como entrada juntamente com as assertivas<br>
inseridas. Toda verificação é realizada sobre o código em linguagem C, que será traduzido a<br>
partir do código VHDL analisado, nas próximas etapas do método proposto. Vale ressaltar que<br>
mesmo <span class='f1 c_128' id='c_128_1' href='#c_128_2' cs_f='.c_128' >a linguagem VHDL</span> tendo um modelo de assertivas padrão, para o método tornou-se<br>
necessário a criação de um modelo (baseado em comentários) para que as funções do model<br>
checker adotado fossem suportadas, como a geração de valores não deterministicos.<br>
As assertivas manuais são adicionadas entre as tags @c2vhdl:ASSERT e @c2vhdl:END<br>
e todo trecho de código entre estas tags deve estar comentado, desta forma não apresentará<br>
erro na tradução do código em linguagem C, bem como na sintetização do código VHDL. Nas<br>
assertivas são incluidas as funções necessárias para a análise utilizando a ferramenta ESBMC. A<br>
assertiva apresenta três informações principais, sendo elas: condição, mensagem e gravidade.<br>
Ajustar está assertiva. Para quem não vê o código todo, ela não faz sentido<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR.<br>
1 ??@c2vhdl : ASSERT<br>
2 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ )<br>
3 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 "<br>
4 ??s e v e r i t y ERROR;<br>
5 ??@c2vhdl :END<br>
Fonte: Própria.<br>
A condição (na linha 2 da Figura 19) representa a assertiva propriamente dita e que será<br>
analisado pela aplicação. A condição será precedida de??assert e seguido ou não da palavra<br>
not, com isso a assertiva pode assumir valor negativo, conforme necessidade do usuário. <span class='f1 c_96' id='c_96_1' href='#c_96_2' cs_f='.c_96' >Na<br>
Figura 19 a</span> assertiva busca verificar se a variavél Resultado terá valor igual a 1. Qual a<br>
razão<br>
para<br>
isso,<br>
ex-<br>
plique!<br>
A mensagem (??report na linha 3 da Figura 19) é definida pelo usuário e será<br>
apresentado caso a assertiva apresente falha, assim a mensagem pode ser utilizada como um meio<br>
de depuração das propriedades validadas. A severidade (severity na linha 4 da Figura 19)<br>
pode ser definida como error, que representa um erro fatal e parada da verificação. A severidade<br>
do tipo warning que representa um erro não fatal, contabiliza as falhas das assertivas, porém<br>
não causa a parada da verificação. As mensagens futuramente pode ser integradas um framework<br>
para teste de unidade, contudo está é uma etapa ainda em planejamento neste trabalho.<br>
Juntamente com as assertivas outra função que pode ser utilizada é a função __ESBMC<br>
Chapter 4. MÉTODO PROPOSTO 43<br>
_assume() suportada pelo model checker ESBMC. Esta função utilizada em conjuto com a<br>
ferramenta ESBMC permite que durante a verificação uma variavél possa ter uma valor setado<br>
durante o tempo de execução da verificação. A importância desta função é fazer verificações onde<br>
se conhece os valores de entrada juntamente com o valor resultante, por exemplo, na verificação<br>
de portas lógicas.<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume().<br>
1 ??__ESBMC_assume (A = ’ 1 ’ )<br>
2 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
Fonte: Própria.<br>
A assertivas que serão verificadas são automáticas traduzidas a partir das entradas do<br>
código VHDL. Seja no modelo manual (assertivas escritas pelo usuário) ou automático (inferidas<br>
pelo método proposto por meio de análise estática), as entradas são mapeadas para serem<br>
utilizados na etapa de instrumentação. Desta forma, tais entradas podem ser utilizadas para gerar<br>
essas assertivas e então serem adicionadas diretamente ao código em linguagem C durante a fase<br>
de instrumentação.<br>
A Figura 20 apresenta o código juntamente com as assertivas conforme o padrão salien-<br>
tado na section 4.2. Neste exemplo foi implementado utilizado a inserção manual das assertivas<br>
e também da função __ESBMC_assume(), entretanto o objetivo é automatizar estas funções<br>
durante a execução da ferramenta.<br>
4.3 Tradução de código VHDL para a linguagem C<br>
Nesta etapa a tradução do código VHDL para linguagem C é executada, conforme<br>
<span class='f1 c_117' id='c_117_1' href='#c_117_2' cs_f='.c_117' >apresentado na Figura</span> 16, etapa <span class='f1 c_74' id='c_74_1' href='#c_74_2' cs_f='.c_74' >B. A partir</span> deste ponto, a ferramenta é executada de maneira<br>
propriamente dita, tendo todo o processo automatizado até a apresentação do resultado. Para<br>
esta etapa do método foi selecionado a ferramenta V2Cque realiza a tradução de VHDL para Adicionar<br>
refer-<br>
ência<br>
Linguagem C.<br>
A ferramenta V2C apresenta diversas vantagens em relação a equivalência de tradução<br>
de linguagens, contudo V2C apresenta certas limitação na tradução do código VHDL, em outras<br>
palavras, a mesma não reconhece algumas estruturas especificas do VHDL. A ferramenta aceita<br>
apenas entradas e saídas do tipo: bit, std_ulogic, qsim_state, std_ulogic_vector<br>
e interger. Na parte de arquitetura, a ferramenta aceita uma gama maior de estruturas, tra-<br>
balhando com expressoões do tipo: signal, variable, integers, strings e caracteres.<br>
Em expreções condicionais os operandos são AND, OR, NOT &lt;=, =&gt;,=,&lt;,&gt; e &lt;&gt;. Aceita<br>
também a estrutura de process, além da estutura block. A estrutura process é limitada<br>
Chapter 4. MÉTODO PROPOSTO 44<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 . . .<br>
4 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
5 SIGNAL a n d _ p o r t : b i t ;<br>
6 SIGNAL o r _ p o r t : b i t ;<br>
7 SIGNAL x o r _ p o r t : b i t ;<br>
8 SIGNAL mux2x1 : b i t ;<br>
9 BEGIN<br>
10 PROCESS(A, B , B i n v e r t i d o , Op1 ) IS<br>
11 BEGIN<br>
12 ??PORTA AND<br>
13 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
14 ??__ESBMC_assume (A = ’ 1 ’ )<br>
15 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
16 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
17 ELSE<br>
18 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
19 END IF ;<br>
20 . . .<br>
21 ??MUX4X1<br>
22 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
23 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
24 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
25 R e s u l t a d o &lt;= o r _ p o r t ;<br>
26 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
27 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
28 ??@c2vhdl : ASSERT<br>
29 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
30 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
31 ??s e v e r i t y ERROR;<br>
32 ??@c2vhdl :END<br>
33 <span class='f1 c_41' id='c_41_1' href='#c_41_2' cs_f='.c_41' >END IF ;<br>
34 END PROCESS ;<br>
35 END</span> U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
apenas a: if-else, case e loops. Como trabalho futuro, neste trabalho tem-se buscado<br>
novas abordagens para ampliar o suporte a estruturas não suportadas pelo V2C.<br>
Na tradução é necessário substituir os operadores originais por seus equivalentes em<br>
linguagem C. A excessão são os operadore específicos que gerenciam os valores de bit, tais<br>
como concatenação ou manipulação de partes vertoriais, para os quais são necessários construir<br>
procedimentos especificos em C.<br>
Conforme <span class='f1 c_14' id='c_14_1' href='#c_14_2' cs_f='.c_14' >mostrado na Figura</span> 21, na tradução são gerados vários vetores para suporte<br>
a tradução dos sinais representados no VHDL, sendo eles chg[], old[] e new[]. O vetor<br>
old[] contém o valor do sinais do passo anteriore a partir deste vetor o valor a ser usado nos Confuso<br>
issocálculo é obtido. O vetor new[] representa os novos valores a serem calculados pelos antigose<br>
Qual?<br>
Chapter 4. MÉTODO PROPOSTO 45<br>
o vetor chg[] contém um or exclusivo entre o valor novo e antigo e em caso de alteração entre<br>
os valores é copiado o valor de new[] para old[].<br>
O texto acima está muito confuso, corrigi rapidamente<br>
No código C gerado, os vetores in_data[] e out_data[] contêm <span class='f1 c_36' id='c_36_1' href='#c_36_2' cs_f='.c_36' >os sinais de<br>
entrada e</span> saída, respectivamente. No caso de circuitos sequênciais, o valor do status é inserido<br>
no primeiro (índice 0). A funçãoentão lerá os valores in_data[] e escreverá os resultados do qual?<br>
processamento em out_data[]. Ao final da operações os valores de estado são passado para<br>
out_data[].<br>
Conforme especificado e seguindo os parametros da ferramenta, a mesma realiza a<br>
tradução, mantendo inalterado qualquer fragmento de código que esteja comentado, neste caso,<br>
as assertivas presentes no código VHDL permanecem inalteradas, sendo utilizadas na próxima<br>
etapa do método proposto.<br>
4.4 Instrumentação de código<br>
As assertivas após a tradução permanecem comentadas, sendo necessário prepara-lás, ou<br>
seja traduzi-las, para verificação posterior do código na linguagem em C. Com isso é necessário<br>
uma instrumentação do código para prover suporte as assertivas traduzidas para análise, conforme<br>
<span class='f1 c_117' id='c_117_1' href='#c_117_2' cs_f='.c_117' >apresentado na Figura</span> 16, etapa C.<br>
Todas as etapas da instrumentação são realizados sobre o código C já traduzido. O passo<br>
inicial da instrumentação é a adição da macros no inicio do código C com as definição das<br>
assertivas a serem utilizadas. Na Figura 22 são apresentados os macros utilizadas no código C. A<br>
Linha 1 da figura corresponde a mensagem de erro a ser apresentada e a Linha 2 corresponde<br>
ao modelo da assertiva e a chamanda da macro definida na Linha 1 em caso de falha. Estas<br>
definições para as assertivas também podem ser utilizadas no código C traduzidos sem o uso do<br>
ESBMC.<br>
Figure 22 – Macros das assertivas implementadas em linguagem C<br>
1 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r ,M, __FILE__ , __LINE__ , # # __VA_ARGS__ )<br>
2 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
Fonte: Própria.<br>
O passo seguinte é a identificação das assertivas comentadas ao longo do corpo do<br>
código traduzido, utilizando o exemplo da Figura 23. As assertivas são identificadas através<br>
das tags @c2vhdl:ASSERT e @c2vhdl:END e a busca é realizado através destas tags. Ao<br>
ser encontrado a tag @c2vhdl:ASSERT, é realizado um loop até que seja encontrada a tag<br>
Chapter 4. MÉTODO PROPOSTO 46<br>
@c2vhdl:END e com isso toda a assertiva inserida possa ser passada a função de busca das<br>
informações da assertiva contidas entre as tags apresentadas.<br>
Com os dados das assertivas obtidos é realizado a busca da condição, mensagem e<br>
severidade através dos comandos ??assert, ??report e ??severity respectivamente.<br>
Estas informações são encontradas através do uso e uma Regex no código e que são adicionadas<br>
ao código C seguindo o modelo definido na macro. Este processo é repetido até outra assertiva<br>
ser encontrada ou caso chegue ao fina do código C.<br>
Com a função __ESBMC_assume() ocorre processo semelhante ao das assertivas.<br>
Utilizando novamente uma regex que realiza a busca por esta função no código e é retirado o<br>
comentário da mesma, desta forma a mesma passa a esta acessivél para o ESBMC, visto que a<br>
declaração da mesma já segue o modelo padrão a ser utilizado pelo ESBMC.<br>
Durante a instrumentação de código também é realizado a entrada de sinais não de-<br>
terministicos para variaveis não inicializadas ou argumentos de funções do código C gerado<br>
da tradução, utilizando a função __VERIFIER_nondet_int(). Esta função é utilizada em<br>
todas as variaveis <span class='f1 c_112' id='c_112_1' href='#c_112_2' cs_f='.c_112' >de entrada e</span> também nos sinais criados ao longo da arquitetura. Desta forma,<br>
todas as variavéis necessárias são inicializadas para verificação.<br>
Explicar <span class='f1 c_52' id='c_52_1' href='#c_52_2' cs_f='.c_52' >o funcionamento do</span> nondet com o ESBMC<br>
Em outras palavras, na instrumentação de código é realizado a traduçao das assertivas do<br>
modelo utilizado no código VHDL para para o modelo utilizado em linguagem C, além como de<br>
outras funções que possam ser utilizados pelo VHDL. Ao final da instrumentação o código C<br>
fica disponivel para que possa ser dado <span class='f1 c_6' id='c_6_1' href='#c_6_2' cs_f='.c_6' >como entrada para</span> outras ferramentas de verificação de<br>
código e não apenas o ESBMC.<br>
4.5 Verificação de assertivas usando Model Checker<br>
O model checker adotado <span class='f1 c_54' id='c_54_1' href='#c_54_2' cs_f='.c_54' >no desenvolvimento de</span> método é o ESBMCna versão 3.0.0 referência<br>
e conforme explicado na subsection 2.2.3, esta ferramenta recebe como entrada um código C<br>
ou C++ e devido a isso foi escolhida neste projeto. Nesta seção será apresentado a etapa D do apresentar<br>
outras<br>
vanta-<br>
gens<br>
métod proposto na Figura 16.<br>
Para a verificação, a primeira etapa é a identificação das assertivas no código C analisado,<br>
para isso é utilizado uma opção do ESBMC (??show-claims), mais especificamente as<br>
assertivas instrumentadas no código C analisado. Cada assertiva é identificada através de uma<br>
numeração de acordo com a ordem de busca do código analisado. Cada assertiva encontrada é<br>
armazenada para que seja realizada uma análise individual de cada claim, ou seja, assertiva.<br>
Chapter 4. MÉTODO PROPOSTO 47<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas.<br>
1 VAR<br>
2 c o n t a d o r : i n t e i r o<br>
3 c l a i m : l i s t a<br>
4 c l a i m _ s t r i n g : s t r i n g<br>
5<br>
6 FUNCAO c a l l _ e s b m c : a r q u i v o<br>
7 c o n t a d o r &lt;?0<br>
8 INICIO<br>
9 s a i d a &lt;?f un ca o de g e r <span class='f1 c_33' id='c_33_1' href='#c_33_2' cs_f='.c_33' >a c a</span> o das c l a i m s p e l o ESBMC<br>
10 ENQUANTO c o n t a d o r &lt; s a i d a FACA<br>
11 c o n t a d o r +=2<br>
12 r e g e x p a r a p r o c u r a r c l a i m e numeracao da c l a i m<br>
13 SE e n c o n t r a r c l a i m ENTAO<br>
14 r e g e x p a r a p r o c u r a r a p a l a v r a " a s s e r t i o n "<br>
15 SE e n c o n t r a r a p a l a v r a " a s s e r t i o n " ENTAO<br>
16 c o n t a d o r +=1<br>
17 A d i c i o n a a numeracao da c l a i m na l i s t a<br>
18 FIM?SE<br>
19 FIM?SE<br>
20 FIM?ENQUANTO<br>
21 FIM?FUNCAO<br>
Fonte: Própria.<br>
Na Linha 9 da Figura 24 é apresentado a chamada da ferramenta ESBMC que ocorre e<br>
através da opção ??show-claims lista todas as claims presentes no texto, como <span class='f1 c_117' id='c_117_1' href='#c_117_2' cs_f='.c_117' >apresentado<br>
na Figura</span> 25. Como o ESBMC infere de forma automatica assertivas a serem verificadas no<br>
código. Visando isolar somente as assertivas instrumentadas pelo método proposto, juntamente<br>
com a opção –show-claims é utilizado as opções:<br>
• ??no-pointer-check: para não realizar a checagem de ponteiros no código;<br>
• ??no-div-by-zero-check: para não realizar a checagem de divisões por zero no<br>
código; e<br>
• ??no-bounds-check: para não realizar a checagem de array bounds no código.<br>
Chapter 4. MÉTODO PROPOSTO 48<br>
Figure 25 – Imagem de claims contendo assertivas.<br>
Fonte:Própria<br>
Após a listagem das claims com assertivas ser gerada, outra função, indicada na Figura 26,<br>
é chamada para verificação de cada claim individualmente. Para cada claim, ocorre a chamada do<br>
ESBMC, utilizando as opções ??no-pointer-check, ??no-div-by-zero-check e<br>
??no-bounds-check, juntamente com a opção ??unwind em que realiza o número de<br>
desdobramentos dos laços no código analisado.<br>
Contudo, dependendo da complexidade da assertiva, faz-se necessário aumentar o número<br>
de desdobramentos que, por padrão são dez, conforme análise experimentais. A função é chamada<br>
na Linha 11 da Figura 26 e após a analise da claim é realizado a busca do resultado e exibição<br>
caso seja uma propriedade violada.<br>
Desta forma o ESBMC realiza apenas a checagem necessária dentro da assertiva, evitando<br>
que outros parâmetros sejam verificados, sem a devida necessidade do mesmo. Ao final de todos<br>
os desdobramentos é apresentado o resultado, <span class='f1 c_117' id='c_117_1' href='#c_117_2' cs_f='.c_117' >apresentado na Figura</span> 27, sendo positiva (sem<br>
erros) ou negativa (com violação de propriedades), dependendo da assertiva e do código analisado.<br>
Este processo se repete até a lista de assertivas ser finalizada.<br>
Chapter 4. MÉTODO PROPOSTO 49<br>
Figure 26 – Pseudocódigo da função de análise das claims.<br>
1 VAR<br>
2 c o n t a d o r 1 : i n t e i r o<br>
3 c o n t a d o r 2 : i n t e i r o<br>
4 r e s u l t a d o : l i s t a<br>
5<br>
6 FUNCAO esbmc_c la ims : l i s t a , a r q u i v o<br>
7 c o n t a d o r 1 &lt;?0<br>
8 c o n t a d o r 2 &lt;?0<br>
9 busca p e l <span class='f1 c_22' id='c_22_1' href='#c_22_2' cs_f='.c_22' >o nome da</span> fu nc a o no a r q u i v o<br>
10 ENQUANTO c o n t a d o r &lt; l i s t a FACA<br>
11 s a i d a &lt;?Execu ta comando de a n a l i s e da c l a i m<br>
numerada na l i s t a<br>
12 ENQUANTO c o n t a d o r 2 &lt; s a i d a<br>
13 Regex busca se a p r o p r i e d a d e f o i v i o l a d a<br>
14 SE p r o p r i e d a d e f o i v i o l a d a ENTAO<br>
15 Pu la p a r a l i n h a da v i o l a ç ã o<br>
16 A d i c i o n a o e r r o ao r e s u l t a d o<br>
17 FIM?SE<br>
18 FIM?ENQUANTO<br>
19 FIM?ENQUANTO<br>
20 FIM?FUNCAO<br>
Fonte: Própria.<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta.<br>
Fonte:Própria<br>
Ajustar os códigos, alguns estao muito grandes e com trechos desnecessário, não foi<br>
citado o link do repo da ferramenta<br>
Chapter 4. MÉTODO PROPOSTO 50<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C.<br>
1 void u l a _ t c c ( i n t i n _ d a t a [ ] , i n t o u t _ d a t a [ ] )<br>
2 {<br>
3 i n t _ i _ =0;<br>
4 i n t _c on t_ ;<br>
5 enum s e g n a l e {A, B , B i n v e r t i d o , Op1 , Op2 , R e s u l t a d o , and_po r t , o r _ p o r t ,<br>
6 x o r _ p o r t , mux2x1 , _MAX_} ;<br>
7 i n t o l d [_MAX_ ] ;<br>
8 i n t new [_MAX_ ] ;<br>
9 i n t chg [_MAX_ ] ;<br>
10 new [A] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
11 new [B] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
12 new [ B i n v e r t i d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
13 new [ Op1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
14 new [ Op2 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
15 new [ R e s u l t a d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
16 new [ a n d _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
17 new [ o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
18 new [ x o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
19 new [ mux2x1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
20<br>
21 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
22 {<br>
23 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
24 }<br>
25 new [A] = i n _ d a t a [ 1 ] ;<br>
26 new [B] = i n _ d a t a [ 2 ] ;<br>
27 new [ B i n v e r t i d o ] = i n _ d a t a [ 3 ] ;<br>
28 new [ Op1 ] = i n _ d a t a [ 4 ] ;<br>
29 new [ Op2 ] = i n _ d a t a [ 5 ] ;<br>
30<br>
31 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
32 {<br>
33 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
34 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
35 }<br>
36<br>
37 do {<br>
38 _ co n t _ =0;<br>
39 /? S t a r t o f T r a n s l a t i o n ? /<br>
40<br>
41 /? p0 : ? /<br>
42 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
43 /?PORTA AND ? /<br>
44 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
45 \ \ __ESBMC_assume ( o l d [A] = 1) ;<br>
46 \ \ __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
47 new [ a n d _ p o r t ] = 1 ;<br>
48 }<br>
49 e l s e {<br>
50 new [ a n d _ p o r t ] = 0 ;<br>
51 }<br>
52 /?PORTA OR ? /<br>
53 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
54 new [ a n d _ p o r t ] = 0 ;<br>
55 }<br>
56 e l s e {<br>
57 new [ a n d _ p o r t ] = 1 ;<br>
58 }<br>
59 /?PORTA XOR ? /<br>
60 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
61 new [ x o r _ p o r t ] = 0 ;<br>
62 }<br>
63 e l s e i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==1) ) {<br>
64 new [ x o r _ p o r t ] = 0 ;<br>
65 }<br>
66 e l s e {<br>
67 new [ x o r _ p o r t ] = 1 ;<br>
68 }<br>
69 /? INVERSOR ? /<br>
70 i f ( ( o l d [ B i n v e r t i d o ]==0) ) {<br>
71 i f ( chg [B ] ) {<br>
72 new [ mux2x1 ]= o l d [B ] ;<br>
73 }<br>
74 }<br>
75 e l s e {<br>
76 i f ( chg [B ] ) {<br>
77 new [ mux2x1 ]=~ o l d [B ] ;<br>
78 }<br>
79 }<br>
80 /?MUX4X1 ? /<br>
81 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
82 i f ( chg [ a n d _ p o r t ] ) {<br>
83 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
84 \ \ @c2vhdl : ASSERT<br>
85 \ \ a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
86 \ \ r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
87 \ \ s e v e r i t y ERROR;<br>
88 \ \ @c2vhdl :END<br>
89 }<br>
90 }<br>
91 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
92 i f ( chg [ o r _ p o r t ] ) {<br>
93 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
94 }<br>
95 }<br>
96 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
97 i f ( chg [ x o r _ p o r t ] ) {<br>
98 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
99 }<br>
100 }<br>
101 }<br>
102<br>
103 /? End o f T r a n s l a t i o n ? /<br>
104 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
105 {<br>
106 i f ( new [ _ i _ ] ! = o l d [ _ i _ ] ) _ con t_ =1;<br>
107 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
108 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
109 }<br>
110 } whi le ( _c on t_ ) ;<br>
111<br>
112 new [A] &= 0X01 ;<br>
113 new [B] &= 0X01 ;<br>
114 new [ B i n v e r t i d o ] &= 0X01 ;<br>
115 new [ Op1 ] &= 0X01 ;<br>
116 new [ Op2 ] &= 0X01 ;<br>
117 new [ R e s u l t a d o ] &= 0X01 ;<br>
118 new [ a n d _ p o r t ] &= 0X01 ;<br>
119 new [ o r _ p o r t ] &= 0X01 ;<br>
120 new [ x o r _ p o r t ] &= 0X01 ;<br>
121 new [ mux2x1 ] &= 0X01 ;<br>
122<br>
123 o u t _ d a t a [ 0 ] = 0 ; _ i _ =0;<br>
124 o u t _ d a t a [ 0 ] | = new [A] &lt;&lt; _ i _ ; _ i _ +=1;<br>
125 o u t _ d a t a [ 0 ] | = new [B] &lt;&lt; _ i _ ; _ i _ +=1;<br>
126 o u t _ d a t a [ 0 ] | = new [ B i n v e r t i d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
127 o u t _ d a t a [ 0 ] | = new [ Op1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
128 o u t _ d a t a [ 0 ] | = new [ Op2 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
129 o u t _ d a t a [ 0 ] | = new [ R e s u l t a d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
130 o u t _ d a t a [ 0 ] | = new [ a n d _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
131 o u t _ d a t a [ 0 ] | = new [ o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
132 o u t _ d a t a [ 0 ] | = new [ x o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
133 o u t _ d a t a [ 0 ] | = new [ mux2x1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
134<br>
135 o u t _ d a t a [ 1 ] = new [ R e s u l t a d o ] ;<br>
136 }<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 51<br>
Figure 23 – Código com assertivas traduzida para linguagem C<br>
1 # inc lude &lt; s t d i o . h&gt;<br>
2 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r , M , __FILE__ , __LINE__ , ##<br>
__VA_ARGS__ ) / / Update t o p r i n t t h e t r a c e<br>
3 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
4<br>
5 . . .<br>
6<br>
7 do {<br>
8 _co n t _ =0;<br>
9 /? S t a r t o f T r a n s l a t i o n ? /<br>
10 chg [A] = __VERIFIER_nondet_int ( ) ;<br>
11 chg [B] = __VERIFIER_nondet_int ( ) ;<br>
12 chg [ B i n v e r t i d o ] = __VERIFIER_nondet_int ( ) ;<br>
13 chg [ Op1 ] = __VERIFIER_nondet_int ( ) ;<br>
14 chg [ a n d _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
15 chg [ R e s u l t a d o ] = __VERIFIER_nondet_int ( ) ;<br>
16 chg [ o r _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
17 chg [ mux2x1 ] = __VERIFIER_nondet_int ( ) ;<br>
18<br>
19 /? p0 : ? /<br>
20 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
21 /?PORTA AND ? /<br>
22 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
23 __ESBMC_assume ( o l d [A] = 1) ;<br>
24 __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
25 new [ a n d _ p o r t ] = 1 ;<br>
26 }<br>
27 e l s e {<br>
28 new [ a n d _ p o r t ] = 0 ;<br>
29 }<br>
30<br>
31 . . .<br>
32<br>
33 /?MUX4X1 ? /<br>
34 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
35 i f ( chg [ a n d _ p o r t ] ) {<br>
36 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
37 __MY_asser t ( new [ R e s u l t a d o ] == 1 , "O r e s u l t a d o é d i f e r e n t e de 0 " ) ;<br>
38 }<br>
39 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
40 i f ( chg [ o r _ p o r t ] ) {<br>
41 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
42 }<br>
43 }<br>
44 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
45 i f ( chg [ x o r _ p o r t ] ) {<br>
46 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
47 }<br>
48 }<br>
49 }<br>
50<br>
51 /? End o f T r a n s l a t i o n ? /<br>
52 . . .<br>
Fonte: Própria.<br>
52<br>
5 CRONOGRAMA<br>
53<br>
6 CONSIDERAÇÕES PARCIAIS E<br>
TRABALHOS FUTUROS<br>
O trabalho aborda o desenvolvimento de um método para análise de circuitos lógicos de-<br>
scrito em VHDL através da aplicação de técnica de transformação de código e a técnica Bounded<br>
Model Cheking. Este método <span class='f1 c_64' id='c_64_1' href='#c_64_2' cs_f='.c_64' >tem como objetivo</span> de explorar os estados alcanç alcançáveis no<br>
circuito, e dessa forma identificar erros que possam resutar em mal funcionamento do sistema.<br>
Entre as dificuldade encontradas, a principal esta ligada a etapa de tradução de código.<br>
Devido a ferramenta utilizada inicialmente conter diversas limitações, a mesma diminui a eficácia<br>
da ferramenta, pois a quantidade de estruturas que podem ser utilizadas é limitada e com isso<br>
limitando também <span class='f1 c_45' id='c_45_1' href='#c_45_2' cs_f='.c_45' >o processo de</span> criação de protótipos.<br>
Os trabalhos futuros é necessário buscar uma nova ferramenta ou método de tradução<br>
que tenha uma gama maior de tradução, seja em estruturas ou palavras reservadas,deste forma<br>
o método desenvlvido torna-se mais eficiente e gerando uma menor intervenção do usuário no<br>
código VHDL. A melhoria na tradução de código também beneficia ageração das assertivas<br>
automáticamente, pois com uma gama maior de estruturas suportadas, mais assertivas podem ser<br>
geradas.<br>
Além disso a geração automática das assertivas é Outro ponto abordado, já sitado anterior-<br>
mente, é a geração automática das assertivas, visto que na estapa atual ainda nõ foi implementado.<br>
Este recuros visa da liberdade ao desenvolvedor promovendo de maneira automática os teste<br>
sobre o código, não necessitando que uma intervenção, tornando a inserção manual apenas em<br>
casos especificos de testes.<br>
54<br>
BIBLIOGRAPHY<br>
ABE, J. Introducao a Logica Para a Ciencia Da Computacao. Arte & Ciência, 2002. ISBN<br>
9788574730455. Disponível em: &lt;https://books.google.com.br/books?id=AgBJdjoNPwUC&gt;.<br>
ACM. 2018. Acessado em: 01 de março de 2018. Disponível em: &lt;http://dl.acm.org/&gt;.<br>
AHO, A. V.; SETHI, R.; ULLMAN, J. D. Compilers: principles, techniques, and tools. [S.l.]:<br>
Addison-wesley Reading, 2007. v. 2.<br>
ALLEN, F. E. Control flow analysis. In: ACM. ACM Sigplan Notices. [S.l.], 1970. v. 5, n. 7, p.<br>
1–19.<br>
BAIER, C.; KATOEN, J.-P.; LARSEN, K. G. Principles of model checking. [S.l.]: MIT press,<br>
2008.<br>
BARA, A. et al. Formal verification of timed vhdl programs. In: IET. FDL. [S.l.], 2010. p.<br>
80–85.<br>
BASILI, V. R.; CALDIERA, G.; ROMBACH, H. D. Experience factory. Encyclopedia of<br>
software engineering, Wiley Online Library, 1994.<br>
BENSALEM, S.; LAKHNECH, Y. Automatic generation of invariants. Formal Methods in<br>
System Design, Springer, v. 15, n. 1, p. 75–92, 1999.<br>
BIERE, A. The aiger and-inverter graph (aig) format. Available at http://fmv.jku.at/aiger, 2016.<br>
BIOLCHINI, J. et al. Systematic review in software engineering. System Engineering and<br>
<span class='f1 c_85' id='c_85_1' href='#c_85_2' cs_f='.c_85' >Computer Science Department</span> COPPE/UFRJ, Technical Report ES, v. 679, n. 05, p. 45, 2005.<br>
BOULE, M.; ZILIC, Z. Incorporating efficient assertion checkers into hardware emulation. In:<br>
IEEE. Computer Design: VLSI in Computers and Processors, 2005. ICCD 2005. Proceedings.<br>
2005 IEEE International Conference on. [S.l.], 2005. p. 221–228.<br>
BOULE, M.; ZILIC, Z. Efficient automata-based assertion-checker synthesis of seres for<br>
hardware emulation. In: IEEE COMPUTER SOCIETY. Proceedings of the 2007 Asia and South<br>
Pacific Design Automation Conference. [S.l.], 2007. p. 324–329.<br>
BRAYTON, R.; MISHCHENKO, A. Abc: An academic industrial-strength verification tool. In:<br>
SPRINGER. Computer Aided Verification. [S.l.], 2010. p. 24–40.<br>
B.V. 2018. Acessado em 1 de março de 2018. Disponível em: &lt;http://www.sciencedirect.com/&gt;.<br>
CABODI, G. et al. Hardware model checking competition 2014: an analysis and comparison of<br>
solvers and benchmarks. Journal on Satisfiability, Boolean Modeling and Computation, v. 9, p.<br>
135–172, 2016.<br>
CAPPELATTI, D. Praticando VHDL. Editora Feevale, 2010. ISBN 9788577171200. Disponível<br>
em: &lt;https://books.google.com.br/books?id=z4\_CYog\_UskC&gt;.<br>
Bibliography 55<br>
CHRISTEN, E.; BAKALAR, K. Vhdl-ams-a <span class='f1 c_102' id='c_102_1' href='#c_102_2' cs_f='.c_102' >hardware description language</span> for analog and<br>
mixed-signal applications. IEEE Transactions on Circuits and Systems II: Analog and Digital<br>
Signal Processing, IEEE, v. 46, n. 10, p. 1263–1272, 1999.<br>
CHU, P. P. RTL hardware design using VHDL: coding for efficiency, portability, and scalability.<br>
[S.l.]: John Wiley & Sons, 2006.<br>
CLARKE, E. et al. Verification of hybrid systems based on counterexample-guided abstraction<br>
refinement. In: SPRINGER. TACAS. [S.l.], 2003. v. 3, p. 192–207.<br>
CLARKE, E. M. The birth of model checking. In: 25 Years of Model Checking. [S.l.]: Springer,<br>
2008. p. 1–26.<br>
CLARKE, E. M.; GRUMBERG, O.; LONG, D. E. Model checking and abstraction. ACM<br>
transactions on Programming Languages and Systems (TOPLAS), ACM, v. 16, n. 5, p.<br>
1512–1542, 1994.<br>
CORDEIRO, L.; FISCHER, B.; MARQUES-SILVA, J. Smt-based bounded model checking for<br>
embedded ansi-c software. IEEE Transactions on Software Engineering, IEEE, v. 38, n. 4, p.<br>
957–974, 2012.<br>
COUSOT, P.; COUSOT, R. A gentle introduction to formal verification of computer systems by<br>
abstract interpretation. [S.l.]: IOS Press, 2010.<br>
DAHAN, A. et al. Combining system level modeling with assertion based verification. In: Sixth<br>
international symposium on quality electronic design (isqed’05). [S.l.: s.n.], 2005. p. 310–315.<br>
ISSN 1948-3287.<br>
D’SILVA, V.; KROENING, D.; WEISSENBACHER, G. A survey of automated techniques<br>
for formal software verification. IEEE Transactions on Computer-Aided Design of Integrated<br>
Circuits and Systems, IEEE, v. 27, n. 7, p. 1165–1178, 2008.<br>
ELSEVIER. 2017. Acessado em: 01 março 2018. Disponível<br>
em: &lt;https://www.elsevier.com/__data/assets/pdf_file/0007/69451/<br>
0597-Scopus-Content-Coverage-Guide-US-LETTER-v4-HI-singles-no-ticks.pdf&gt;.<br>
G1. Acidente foi provocado por falha em circuito eletrônico, diz se-<br>
cretário. 2012. Disponível em: &lt;http://g1.globo.com/sao-paulo/noticia/2012/05/<br>
acidente-foi-provocado-por-falha-em-circuito-eletronico-diz-secretario.html&gt;.<br>
GUGLIELMO, G. D. et al. On the use of assertions for embedded-software dynamic verification.<br>
In: IEEE. Design and Diagnostics of Electronic Circuits & Systems (DDECS), 2012 IEEE 15th<br>
International Symposium on. [S.l.], 2012. p. 330–335.<br>
GUPTA, A. Formal hardware verification methods: A survey. In: SPRINGER. Computer-Aided<br>
Verification. [S.l.], 1992. p. 5–92.<br>
HALDER, A.; VENKATESWARLU, A. A study of petri nets modeling analysis and simulation.<br>
Department of Aerospace Engineering Indian Institute of Technology Kharagpur, India, 2006.<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Interpolation and symbol elimination in vampire.<br>
Automated Reasoning, Springer, p. 188–195, 2010.<br>
Bibliography 56<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Case studies on invariant generation using a<br>
saturation theorem prover. Advances in Artificial Intelligence, Springer, p. 1–15, 2011.<br>
IDOETA, I. V.; CAPUANO, F. G. Elementos de eletrônica digital. [S.l.]: Livros Erica, 1982.<br>
IEC/IEEE International Standard - Behavioural languages - Part 1-1: VHDL Language<br>
Reference Manual. IEC 61691-1-1:2011(E) IEEE Std 1076-2008, p. 1–648, May 2011.<br>
IEEE. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http://ieeexplore.ieee.org/<br>
Xplore/home.jsp&gt;.<br>
IEEE Standard for Property Specification Language (PSL). IEEE Std 1850-2010 (Revision of<br>
IEEE Std 1850-2005), p. 1–182, April 2010.<br>
IEEE Standard for Verilog <span class='f1 c_102' id='c_102_1' href='#c_102_2' cs_f='.c_102' >Hardware Description Language</span>. IEEE Std 1364-2005 (Revision of<br>
IEEE Std 1364-2001), p. 1–560, 2006.<br>
KITCHENHAM, B. Procedures for performing systematic reviews. Keele, UK, Keele University,<br>
v. 33, n. 2004, p. 1–26, 2004.<br>
KITCHENHAM, B. et al. Systematic literature reviews in software engineering–a systematic<br>
literature review. Information and software technology, Elsevier, v. 51, n. 1, p. 7–15, 2009.<br>
KNOOP, J.; RÜTHING, O.; STEFFEN, B. Partial dead code elimination. [S.l.]: ACM, 1994.<br>
v. 29.<br>
KOSCIANSKI, A.; SOARES, M. dos S. Qualidade de Software - 2a Edição: Aprenda as<br>
metodologias e técnicas mais modernas para o desenvolvimento de software. Novatec,<br>
2007. ISBN 9788575221129. Disponível em: &lt;https://books.google.com.br/books?id=<br>
O9aWoUq6L88C&gt;.<br>
KROPF, T. Introduction to Formal Hardware Verification. Springer Berlin Heidelberg,<br>
2013. ISBN 9783662038093. Disponível em: &lt;https://books.google.com.br/books?id=<br>
7ImrCAAAQBAJ&gt;.<br>
MAFRA, S. N.; TRAVASSOS, G. H. Estudos primarios e secundarios apoiando a busca por<br>
evidencia em engenharia de software. Relatorio Tecnico, RT-ES, v. 687, n. 06, 2006.<br>
MUKHERJEE, R. et al. Unbounded safety verification for hardware using software analyzers.<br>
In: EDA CONSORTIUM. Proceedings of the 2016 Conference on Design, Automation & Test in<br>
Europe. [S.l.], 2016. p. 1152–1155.<br>
MUKHERJEE, R.; TAUTSCHNIG, M.; KROENING, D. v2c–a verilog to c translator. In:<br>
SPRINGER. International Conference on Tools and Algorithms for the Construction and<br>
Analysis of Systems. [S.l.], 2016. p. 580–586.<br>
MURATA, T. Petri nets: Properties, analysis and applications. Proceedings of the IEEE, IEEE,<br>
v. 77, n. 4, p. 541–580, 1989.<br>
RAMESH, U. B. K.; SENTILLES, S.; CRNKOVIC, I. Energy management in embedded<br>
systems: Towards a taxonomy. In: IEEE PRESS. Proceedings of the First International<br>
Workshop on Green and Sustainable Software. [S.l.], 2012. p. 41–44.<br>
ROCHA, H. et al. Exploiting safety properties in bounded model checking for test cases<br>
generation of c programs. 2010.<br>
Bibliography 57<br>
ROCHA, H. et al. Model checking embedded c software using k-induction and invariants<br>
(extended version). arXiv preprint arXiv:1509.02471, 2015.<br>
ROCHA, H. O. et al. Verificacao de sistemas de software baseada em transformacoes de codigo<br>
usando bounded model checking. Universidade Federal do Amazonas, 2015.<br>
SARGENT, R. G. Verification and validation of simulation models. In: WINTER SIMULATION<br>
CONFERENCE. Proceedings of the 37th conference on Winter simulation. [S.l.], 2005. p.<br>
130–143.<br>
SEGER, C.-J. An introduction to formal hardware verification. [S.l.]: University of British<br>
Columbia, Department of Computer Science, 1992.<br>
SOMMERVILLE, I. Engenharia de software. PEARSON BRASIL, 2011. ISBN 9788579361081.<br>
Disponível em: &lt;https://books.google.com.br/books?id=H4u5ygAACAAJ&gt;.<br>
SONS, J. W. . 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http:<br>
//onlinelibrary.wiley.com/&gt;.<br>
SOUZA, J. Lógica para Ciência da Computação. Elsevier Brasil, 2017. ISBN 9788535278255.<br>
Disponível em: &lt;https://books.google.com.br/books?id=Ds2sCQAAQBAJ&gt;.<br>
SPRINGER. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;https:<br>
//link.springer.com/&gt;.<br>
SRIKANT, Y.; SHANKAR, P. The Compiler Design Handbook: Optimizations and<br>
Machine Code Generation. CRC Press, 2002. ISBN 9781420040579. Disponível em:<br>
&lt;https://books.google.com.br/books?id=0K\_jIsgyNpoC&gt;.<br>
THOMAS, D.; MOORBY, P. The Verilog R© <span class='f1 c_102' id='c_102_1' href='#c_102_2' cs_f='.c_102' >Hardware Description Language</span>. Springer<br>
US, 2008. ISBN 9780387853444. Disponível em: &lt;https://books.google.com.br/books?id=<br>
DxQGrz7q-SwC&gt;.<br>
<span class='f1 c_51' id='c_51_1' href='#c_51_2' cs_f='.c_51' >TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L</span>. Sistemas digitais: princípios e aplicações. [S.l.]:<br>
Prentice Hall, 2003. v. 8.<br>
TRAVASSOS, G. H. et al. An environment to support large scale experimentation in software<br>
engineering. In: IEEE. Engineering of Complex Computer Systems, 2008. ICECCS 2008. 13th<br>
IEEE International Conference on. [S.l.], 2008. p</div>
<!-- DIVISOR_DIV_CANDIDATE -->

<div class='divisor divisor-texto' id="cand__file10"><hr class='text-separator'><br>Input file: <a href='#'>main.pdf</a> (12773 chunks)<br>File found: <a href='https://books.google.com.br/' target='_blank'>https://books.google.com.br/</a> (40 chunks)<br><br>Chunks in common: 0<br>Similarity: 0%<br><br><div class='textInfo'>The following is the content of the document <br>&nbsp;"<b>main.pdf</b>". <br>The terms in red were found in the document <br>&nbsp;"<b>https://books.google.com.br/</b>".<br><hr class='text-separator'></div>  UNIVERSIDADE FEDERAL DE RORAIMA<br>
PRÓ-REITORIA DE ENSINO E EXTENSÃO<br>
DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código<br>
com Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau<br>
de Bacharel em Ciência da Computação.<br>
Orientador: Dr. Herbert Oliveira Rocha<br>
Boa Vista - RR<br>
2018<br>
KEVIN COSTA AIRES OLIVEIRA<br>
Verificação formal de circuitos lógicos baseado em transformação de código com<br>
Bounded Model Checking<br>
Monografia de Graduação apresentada ao<br>
Departamento de Ciência da Computação<br>
da Universidade Federal de Roraima como<br>
requisito parcial para a obtenção do grau de<br>
Bacharel em Ciência da Computação.<br>
Defendido em 06 de março de 2017 e<br>
aprovado pela seguinte banca examinadora:<br>
Prof. Dr. Herbert Oliveira Rocha<br>
Orientador / Curso de Ciência da Computação -<br>
UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Prof. XXXX<br>
Curso de Ciência da Computação - UFRR<br>
Fazer dedicatória<br>
ACKNOWLEDGEMENTS<br>
Fazer agradecimentos!!<br>
Procurar frase massa!!<br>
ABSTRACT<br>
Fazer resumo!!<br>
Palavras-chaves: ??<br>
ABSTRACT<br>
Fazer Abstract!!<br>
Key-words: ??<br>
LISTA DE FIGURAS<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog. . . . . . . . . . . . . . . . 15<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL. . . . . . . . . . . . . . . . . 16<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade. . . . . . . . . . . . . . . 17<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL. . . . . . . . . . . . . . . . 17<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1. . . . . . . . . . 18<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas. . . . . . . . . 18<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas. . . . . . . . . . 19<br>
Figure 8 – Arvore de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
Figure 9 – Rede de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL. . . . . . . . . . . . . . . . . 27<br>
Figure 11 – Trecho de código em VHDL representando porta AND. . . . . . . . . . . . 28<br>
Figure 12 – Trecho de código traduzido para linguagem C. . . . . . . . . . . . . . . . . 29<br>
Figure 13 – Exemplo de bloco basico de código. . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 14 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 30<br>
Figure 15 – GAD do bloco básico da Figura 13 . . . . . . . . . . . . . . . . . . . . . . 31<br>
Figure 16 – Ciclo da ferramenta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR. . . . . . . 41<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR. . . . . . . . . . . . . . 42<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume(). . . . . . . . . . . 43<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19. . . . . . . . . . . . . . . 44<br>
Figure 22 – Macros das assertivas implementadas em linguagem C . . . . . . . . . . . . 45<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas. . . . . . . 47<br>
Figure 25 – Imagem de claims contendo assertivas. . . . . . . . . . . . . . . . . . . . . 48<br>
Figure 26 – Pseudocódigo da função de análise das claims. . . . . . . . . . . . . . . . . 49<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta. . . . . . . . . . . . . . 49<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C. . . . . . . . . . . . . 50<br>
Figure 23 – Código com assertivas traduzida para linguagem C . . . . . . . . . . . . . . 51<br>
LISTA DE TABELAS<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM . . . . . . . . . . . . . . . 33<br>
SUMÁRIO<br>
1 INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11<br>
1.1 Definição do problema . . . . . . . . . . . . . . . . . . . . . . . . . . . 12<br>
1.2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13<br>
1.3 Organização do trabalho . . . . . . . . . . . . . . . . . . . . . . . . . 14<br>
2 CONCEITOS E DEFINIÇÕES . . . . . . . . . . . . . . . . . . . . . . 15<br>
2.1 Linguagens de descrição de hardware . . . . . . . . . . . . . . . . . 15<br>
2.1.1 VHSIC Hardware Description Language - VHDL . . . . . . . . . . . . . 16<br>
2.1.2 Portas lógicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18<br>
2.2 Verificação de sistemas . . . . . . . . . . . . . . . . . . . . . . . . . . 19<br>
2.2.1 Diagrama de decisão binária . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.2 Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20<br>
2.2.3 Bounded Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . 21<br>
2.2.4 Redes de petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22<br>
2.2.5 Verificação de hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . 23<br>
2.2.6 Verificação formal de software . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.7 Lógica proposicional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24<br>
2.2.8 Linguagem de especificação de propriedades . . . . . . . . . . . . . . 26<br>
2.2.9 Verificação baseada em assertivas . . . . . . . . . . . . . . . . . . . . 26<br>
2.2.10 Propriedades de segurança . . . . . . . . . . . . . . . . . . . . . . . . 27<br>
2.3 Técnicas de compiladores . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.1 Transformações de código . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2 Otimização de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28<br>
2.3.2.1 Grafo Acliclico Direcional - GAD . . . . . . . . . . . . . . . . . . . . . . . . 29<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.3 Eliminção de código morto . . . . . . . . . . . . . . . . . . . . . . . . . . 30<br>
2.3.2.4 Análise do fluxo de dados . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
2.3.2.5 Gerador de código . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31<br>
3 TRABALHOS CORRELATOS . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1 Revisão sistemática . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32<br>
3.1.1 Planejamento da Revisão Sistemática . . . . . . . . . . . . . . . . . . 33<br>
3.1.1.1 Procedimentos de Seleção e Critérios . . . . . . . . . . . . . . . . . . . . 35<br>
3.2 Revisão da literatura . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.1 V2c-A verilog to C translator . . . . . . . . . . . . . . . . . . . . . . . . 37<br>
3.2.2 Unbounded safety verification for hardware using software analyzers . 37<br>
3.2.3 Formal verification of timed VHDL programs . . . . . . . . . . . . . . . 38<br>
3.2.4 On the use of assertions for embedded-software dynamic verification 38<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation . . 39<br>
4 MÉTODO PROPOSTO . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.1 Visão geral do método . . . . . . . . . . . . . . . . . . . . . . . . . . . 40<br>
4.2 Preprocessamento do VHDL e inserção de assertivas . . . . . . . 42<br>
4.3 Tradução de código VHDL para a linguagem C . . . . . . . . . . . . 43<br>
4.4 Instrumentação de código . . . . . . . . . . . . . . . . . . . . . . . . 45<br>
4.5 Verificação de assertivas usando Model Checker . . . . . . . . . . 46<br>
5 CRONOGRAMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52<br>
6 CONSIDERAÇÕES PARCIAIS E TRABALHOS FUTUROS . . . . . 53<br>
BIBLIOGRAPHY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54<br>
11<br>
1 INTRODUÇÃO<br>
A complexidade de sistemas computacionais cresce exponencialmente. Muitas compan- Exemplificar<br>
este<br>
cresci-<br>
mento.<br>
hias e organizações estão rotineiramente lidando com software que contém milhares de linhas<br>
de código, escritos por diferentes pessoas, que usam linguagens distintas, ferramentas, estilos e<br>
hardware projetados de diversas formas e combinações (HODER et al., 2011).<br>
No contexto de sistemas compostos de hardware e software, tem-se os sistemas embarca-<br>
dos (SE) que são dispositivos semicondutores com software integrados, os quais se conectam<br>
a outros dispositivos. Usualmente, o principal propósito dos SE é o controle e provimento de<br>
informações para uma função específica (RAMESH et al., 2012).<br>
Os SE são extremamente interativos com seu ambiente, operam geralmente em tempo real<br>
e estão disponíveis continuamente. No entanto, estes sistemas, por possuírem um curto espaço<br>
de tempo para a liberação do produto ao mercado, precisam ser desenvolvidos rapidamente e<br>
atingir um alto nível de qualidade, mas, devido a esta necessidade, os programadores podem<br>
cometer enganos durante a fase de desenvolvimento destes sistemas.<br>
Os SE têm se proliferado em partes consideráveis das atividades do nosso cotidiano,<br>
com a característica de possuir grande quantidade de complexidade e diversidade. Devido a esta<br>
complexidade, erros podem passar despercebidos, causando não apenas penalidades econômicas<br>
e/ou fracassos do produto no mercado, mas principalmente o risco de perda de vidas humanas<br>
(CABODI et al., 2016). Como, por exemplo, o acidente noticiado no (G1, 2012), no qual, de<br>
acordo com o secretário de transportes, uma falha na placa do circuito eletrônico responsável<br>
pelo controle de velocidade dos trens ocasionou a colisão entre duas composições na estação de<br>
metrô de São Paulo.<br>
Segundo ROCHA et al.2015b, para se obter um alto nível de qualidade no desenvolvi-<br>
mento dos sistemas de hardware e software, a execução desses sistemas deve ser controlada e da<br>
mesma forma deve-se buscar meios de garantir que as propriedades definidas sejam atingidas. Por<br>
exemplo, a partir do conhecimento prévio do modo de implementação de determinado hardware,<br>
é possível utilizá-lo de forma mais eficiente. Neste sentido, diversas estratégias de verificação e<br>
de teste estão sendo pesquisadas e aplicadas para garantir a qualidade do software e hardware<br>
(HODER et al., 2010; ROCHA et al., 2010; BRAYTON; MISHCHENKO, 2010; CORDEIRO et<br>
al., 2012; CABODI et al., 2016).<br>
Por este motivo, com o intuito de analisar e otimizar a descrição dos circuitos digitais,<br>
tem-se utilizado as linguagens de descrição de hardware (HDL). Estas se diferem das linguagens<br>
de programação por conseguirem gerar execuções não apenas sequenciais, como também con-<br>
correntes ou paralelas (CHU, 2006). Neste contexto, a VHSIC Hardware Description Language<br>
Chapter 1. INTRODUÇÃO 12<br>
(VHDL) é uma das linguagens de descrição de hardware mais utilizadas atualmente. A descrição<br>
em VHDL pode ser em vários níveis de abstração, sendo o mais alto o nível comportamen-<br>
tal que permite a descrição do circuito através de loops e processos, definido-o na forma de<br>
algoritmo. Como características das linguagens de descrição, o VHDL permite declarações se-<br>
quenciais ou concorrentes onde as declarações continuam ativas e sua ordem torna-se irrelevante<br>
(CAPPELATTI, 2010).<br>
Aliada à linguagem de descrição de hardware, a verificação formal de sistemas computa-<br>
cionais tem desempenhado um papel importante para assegurar a previsibilidade e a confiabili-<br>
dade na concepção de aplicações críticas. E, para isso, tem-se utilizado a técnica denominada<br>
model checking, que é baseada em formalismos matemáticos para provar propriedades de pro-<br>
gramas reativos (BENSALEM; LAKHNECH, 1999). Esta técnica gera uma busca exaustiva no<br>
espaço de estados do modelo para determinar se uma dada propriedade é válida ou não (BAIER<br>
et al., 2008), tendo como principal razão para o seu sucesso o funcionamento completamente<br>
automático, ou seja, sem qualquer intervenção do usuário.<br>
Visando contribuir com a verificação de sistemas embarcados no âmbito de sistemas<br>
computacionais, o contexto deste trabalho está situado no uso de metodologias e técnicas de<br>
verificação formal para programas escritos em VHDL (BIERE, 2016), focando principalmente<br>
no Bounded Model Checking (CORDEIRO et al., 2012; ROCHA et al., 2015a). Este trabalho está<br>
interessado especificamente na parte de: verificação de modelos de hardware descritos em níveis<br>
de circuitos de bits na linguagem VHDL, via transformações de código para gerar modelos (com<br>
assertivas) já suportados por model checkers, como o ESBMC (CORDEIRO et al., 2012).<br>
Dessa forma, o trabalho almeja analisar as propriedades de alcançabilidade para a<br>
identificação de localizações de erro, bem como, assertivas contendo propriedades de segurança.<br>
A propriedade de alcançabilidade ou propriedade do estado de erro é satisfatória (SAT), se um<br>
estado de erro é alcançável. Caso contrário, a propriedade é considerada insatisfatória (UNSAT).<br>
No caso SAT, o model checking também gera um rastreio da validação da propriedade (contra-<br>
exemplo), ou seja, uma sequência de estados que mostra como chegar ao erro a partir de um<br>
ponto inicial.<br>
1.1 Definição do problema<br>
O avanço da tecnologia, principalmente nas áreas de design e fabricação de eletrônicos,<br>
aumentou a importância do hardware nos dias atuais. Cada vez com mais funcionalidades<br>
integradas, aliada a velocidade e circuitos menores, faz com que a complexidade dos sistemas<br>
de hardware aumente. Entretanto, devido à complexidade cada vez maior, a detecção tardia<br>
de erros no sistema pode resultar em perda de produção, mas também custos associados ao<br>
desenvolvimento do sistema(GUPTA, 1992). Devido a isso, a verificação de hardware visa<br>
assegurar que o circuito atinja as especificações para o qual foi projetado, através de técnicas<br>
Chapter 1. INTRODUÇÃO 13<br>
formais ou dinâmicas (BOULE; ZILIC, 2007).<br>
Por esta razão, a utilização de métodos formais tornou-se uma abordagem atraente<br>
para superar as limitações inerentes à validação baseada em simulação. Portanto, a maioria<br>
das empresas de semicondutores têm investigado a sua aplicabilidade. Escolhas individuais de<br>
métodos, ferramentas e áreas de aplicação das empresas têm variado, assim como o seu nível<br>
de sucesso (CABODI et al., 2016). Com os recentes avanços na escalabilidade de automação<br>
dos model checkers e nas equivalências sequenciais de verificação, a maioria das empresas têm<br>
crescido ao contar com essas técnicas(CLARKE, 2008).<br>
O problema considerado neste trabalho é expresso na seguinte questão: Como comple-<br>
mentar e aprimorar a verificação de propriedades de segurança em circuitos lógicos, de tal<br>
forma que uma propriedade possa ser mapeada em um problema de alcançabilidade sim-<br>
bólica, ou seja, se é possível alcançar um estado específico (para uma dada propriedade) a<br>
partir do estado inicial?<br>
1.2 Objetivos<br>
O objetivo principal deste trabalho é projetar e avaliar um método para efetuar verificação<br>
de circuitos, de forma automática, descritos em VHDL com portas lógicas em nível de bit<br>
pela utilização de técnicas de transformação de códigos combinado com a técnica Bounded<br>
Model Checking para exploração de estados alcançáveis no circuito, visando identificar erros ou<br>
comportamentos indevidos ou inesperados que podem resultar no funcionamento incorreto de<br>
um dado sistema.<br>
Os objetivos específicos são:<br>
1. Propor um método para especificar pré e pós-condições de circuitos digitais em nível de<br>
portas lógicas descritos em VHDL;<br>
2. Analisar ferramentas de verificação de modelos que utilizam a técnica Bounded Model<br>
Checking;<br>
3. Especificar uma técnica de conversão de circuitos em linguagem de descrição de hardware<br>
VHDL para um modelo a ser verificado usando a técnica Bounded Model Checking;<br>
4. Desenvolver um método para identificação de estados de erros ou ocorrências indevidas,<br>
de um dado circuito analisado, em modelos de hardware descritos em nível de bit na<br>
linguagem de descrição VHDL.<br>
5. Validar a aplicação do método proposto sobre benchmarks públicos de programas em<br>
VHDL, a fim de examinar a sua eficácia e aplicabilidade.<br>
Chapter 1. INTRODUÇÃO 14<br>
1.3 Organização do trabalho<br>
A introdução deste trabalho apresentou: o contexto, definição do problema, e objetivos<br>
deste trabalho. Os próximos capítulos estão organizados da seguinte forma:<br>
No Capítulo 2 Conceitos e Definições, são apresentados os conceitos abordados neste<br>
trabalho, especificamente: Linguagens de descrição de hardware; Verificação e validação de<br>
sistemas; e Técnicas de compiladores.<br>
No Capítulo 3 Trabalhos Correlatos, serão apresentados o método de pesquisa bibli-<br>
ográfica utilizado, sendo ele a revisão sistemática, seguido do resultado encontrado com esta<br>
pesquisa e, por fim, a contribuição dos artigos utilizados no desenvolvimento do projeto.<br>
No Capítulo 4 Método Proposto, são descritas as etapas de execução do novo método<br>
proposto que consiste na transformação do código, instrumentação de assertivas e verificação de<br>
código utilizando um model checker.<br>
No Capítulo 5, será apresentado o cronograma de atividades a ser realizado na elaboração<br>
do método durante o desenvolvimento do projeto.<br>
E, por fim, no Capítulo 6 Considerações parciais e trabalhos futuros, serão apresentas<br>
as considerações parciais e as sugestões de trabalhos futuros que podem ser desenvolvidos.<br>
15<br>
2 CONCEITOS E DEFINIÇÕES<br>
Este capítulo tem apresenta os principais conceitos e definições abordados neste tra-<br>
balho, tais como: Linguagens de descrição de hardware, Verificação de sistemas e Técnicas de<br>
Compiladores.<br>
2.1 Linguagens de descrição de hardware<br>
As linguagens de descrição de hardware (HDL) foram desenvolvidas com o intuito de<br>
auxiliar a criação de circuitos lógicos com grande número de elementos e com uma gama de<br>
abstrações lógicas e eletrônicas (THOMAS; MOORBY, 2008). Entre os exemplos, podemos<br>
citar: VDHL (IEC/IEEE. . . , 2011), Verilog (IEEE. . . , 2006) e SystemC (??).<br>
Segundo CHRISTEN; BAKALAR,1999, linguagens de descrição de hardware são lingua-<br>
gens de programação utilizadas com o intuito de descrever o comportamento de um determinado<br>
circuito, técnica conhecida como modelagem. Os modelos descritos em HDL são utilizados<br>
como entrada para um simulador, onde o mesmo pode ter seu comportamento analisado.<br>
As HDL’s trazem consigo diversas vantagens, entre elas códigos independentes de tec-<br>
nologia e fabricante, podendo ser portáteis e reutilizáveis (CAPPELATTI, 2010). As linguagens<br>
mais modernas, tais como VHDL e Verilog, possuem suporte tanto a descrição do circuito pro-<br>
priamente dito, quanto ao comportamento que o mesmo deve exercer (CHRISTEN; BAKALAR,<br>
1999).<br>
A Verilog, como já citado, é uma linguagem de descrição de hardware que fornece<br>
diversos níveis de abstração para desenvolvimento de sistemas digitais(THOMAS; MOORBY,<br>
2008). A linguagem foi desenvolvida para ser simples e efetiva nos diversos níveis de abstração<br>
incluindo o suporte ao desenvolvimento, verificação, síntese e testes de software (IEEE. . . , 2006).<br>
Figure 1 – Exemplo de multiplexador descrito em Verilog.<br>
1 p r i m i t i v e m u l t i p l e x e r ( mux , c o n t r o l , dataA , da taB ) ;<br>
2 o u t p u t mux ;<br>
3 i n p u t c o n t r o l , dataA , da taB ;<br>
4 e n d p r i m i t i v e<br>
Fonte: Adaptado de (IEEE. . . , 2006).<br>
Na Figura 1 apresenta um exemplo de multiplexador descrito em Verilog utilizando a<br>
estrutura de modelagem, chamada UDP que permite a criação de novos primitivas para serem<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 16<br>
utilizada. Apresenta uma saída apenas(mux) e três entradas sendo uma de controle(control) e<br>
duas de dados(dataA e dataB).<br>
A VHDL é uma linguagem de descrição de hardware amplamente utilizada, concebida<br>
na década de 80, devido uma necessidade do Departamento de Defesa dos Estados Unidos<br>
da América (CAPPELATTI, 2010). Assim como a Verilog, esta linguagem também suporta o<br>
desenvolvimento, a verificação, a síntese, e os testes de hardware (IEC/IEEE. . . , 2011).<br>
Figure 2 – Exemplo de multiplexador descrito em VHDL.<br>
1 l i b r a r y IEEE ;<br>
2 use IEEE . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 use IEEE . s t d _ l o g i c _ u n s i g n e d . a l l ;<br>
4 e n t i t y mux2x1 i s<br>
5 p o r t ( s e l : i n STD_LOGIC ;<br>
6 a , b : i n STD_LOGIC ;<br>
7 y : o u t STD_LOGIC ) ;<br>
8 end mux2x1 ;<br>
9<br>
10 a r c h i t e c t u r e d a t a f l o w of mux2x1 i s b e g i n<br>
11 y &lt;= ( a AND NOT s e l ) OR ( b AND s e l ) ;<br>
12 end d a t a f l o w .<br>
Fonte: (CAPPELATTI, 2010).<br>
Na Figura 2 está descrito um multiplexador de duas entradas descrito em VHDL, apre-<br>
sentando na parte inicial as bibliotecas e na entidade(entity) a declaração das variáveis utilizadas.<br>
Na arquitetura(architecture) apresenta o funcionamento do multiplexador, relacionando en-<br>
tradas e saídas conforme tenham sido declarados. Este conceitos serão melhor apresentados na<br>
subsection 2.1.1.<br>
Conforme apresentado nas Figura 1 e Figura 2, ambas as linguagens apresentam difer-<br>
enças no modelos de declaração e utilização para descrição de hardware. Para este trabalho foi<br>
escolhido a VHDL devido a linguagem apresentar um melhor escopo para análise, facilitando o<br>
trabalho de análise proposto para este projeto.<br>
2.1.1 VHSIC Hardware Description Language - VHDL<br>
Revisar textos e verificar a necessidade de mais exemplo<br>
VHDL é uma linguagem de descrição de hardware destinada a ser utilizada em todas<br>
as etapas da criação de sistemas eletrônicos, sendo elas: desenvolvimento; verificação; síntese;<br>
e, teste de circuitos (IEC/IEEE. . . , 2011). Segundo (CAPPELATTI, 2010), a VHDL apresenta<br>
três principais pilares: abstração, que consiste na descrição com diferentes níveis de detalhes;<br>
modularidade, que permite a divisão do projeto em vários blocos ou módulos para posterior<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 17<br>
interconexão; e hierarquia, permite que módulos possam ser compostos por submódulos e, os<br>
mesmos tenham níveis de abstração diferentes, dependendo da necessidade do projeto. Devido a<br>
esta versatilidade que a linguagem VHDL foi selecionada para o trabalho proposto.<br>
Segundo IEC/IEEE. . . ,2011, é necessário um padrão para formatação da descrição em<br>
VHDL: Entity (Pinos de entrada/saída) e Architecture (Arquitetura). A Entity ou entidade repre-<br>
senta o bloco onde são declaradas as entradas e as saídas do circuito utilizadas em todo o sistema,<br>
conforme apresentado na Figura 3. A Architecture ou arquitetura, apresentado na Figura 4, define<br>
a relação entre entradas e saídas declaradas na entidade, podendo tais especificações serem<br>
completas ou parciais. Assim como em outras linguagens, bibliotecas podem ser adicionadas,<br>
para que novas funções e atributos possam ser utilizados no projeto.<br>
Figure 3 – Exemplo de declaração de bibliotecas e entidade.<br>
1 l i b r a r y i e e e ;<br>
2 use IEEE . STD_LOGIC_1164 . ALL<br>
3<br>
4 ENTITY f u l l _ a d d e r IS PORT(<br>
5 x1 , x2 , c i n : i n s t d _ l o g i c ;<br>
6 S , c o u n t : o u t s t d _ l o g i c ) ;<br>
7 END f u l l _ a d d e r ;<br>
Fonte: Própria.<br>
Figure 4 – Exemplo de declaração da arquitetura no VHDL.<br>
1 ARCHITECTURE b e h a v i o r a l OF f u l l _ a d d e r IS<br>
2 BEGIN<br>
3 s &lt;=x1 XOR x2 XOR c i n ;<br>
4 cout &lt;=( x1 AND x2 ) OR ( x1 AND c i n ) OR ( b<br>
AND c i n ) ;<br>
5 END b e h a v i o r a l ;<br>
Fonte: Própria.<br>
Segundo CAPPELATTI,2010 uma descrição em VHDL pode conter diferentes níveis de<br>
abstração:<br>
• Comportamental: Permite descrever o circuito através de laços e processos. O circuito<br>
é definido em forma de um algoritmo, utilizando construção similares as utilizadas em<br>
linguagem de programação.<br>
• Transferência de registradores: Englobando a representação do dispositivo em nível de<br>
transferência entre registradores, que consiste na utilização de funções lógicas combina-<br>
cionais e de registradores.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 18<br>
• Estrutural: O circuito é descrito mais próximo da implementação real, podendo ser<br>
definidas portas lógicas com atrasos unitários ou com atrasos detalhados.<br>
2.1.2 Portas lógicas<br>
Segundo (IDOETA; CAPUANO, 1982), o conceito de portas lógicas é baseado na<br>
conhecida álgebra de Boole ou álgebra booleana, desenvolvida pelo matemático inglês George<br>
Boole em 1854. A álgebra booleana é representada por apenas dois valores, sendo eles o 0 e 1 e,<br>
através disso, expressa a relação entre entrada e saída dentro de um circuito. As portas lógicas<br>
podem ser construídas a partir de diodos, transistores e resistores interconectados de modo que a<br>
saída seja o resultante de uma operação lógica básica realizada sobre as entradas (TOCCI et al.,<br>
2003). A Figura 5 apresenta um exemplo de álgebra booleana sem a utilização de diagramas.<br>
Figure 5 – Exemplo de algebra booleana, onde A=0, B=1, C=1 e D=1.<br>
Fonte: (TOCCI et al., 2003)<br>
Ainda segundo TOCCI et al.,2003, devido a esta característica, a álgebra booleana possui<br>
três operações básicas, OR (ou), AND (e) e NOT (não). Tal conjunto de operações também é<br>
denominado de operações booleanas e, por meio da utilização de tabelas verdade é possível<br>
descrever as saídas baseando-se nas entradas e na operação aplicada. Cada operação booleana<br>
possui sua tabela verdade ( Figura 6), bem como sua representação em forma de diagrama.<br>
Figure 6 – Símbolo e tabela verdade para uma porta OR de três entradas.<br>
Fonte: (TOCCI et al., 2003)<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 19<br>
Figure 7 – Representação de circuito lógico, utilizando portas lógicas.<br>
Fonte: (TOCCI et al., 2003)<br>
A Figura 7 apresenta um circuito lógico formado pelas portas básicas da álgebra booleana.<br>
O circuito apresenta três entradas representadas pelas letras A, B e C, mas também formada<br>
por duas portas AND, uma porta NOT e uma porta OR. Cada uma destas portas representando<br>
operações a serem realizadas, podendo receber como entrada um valor inicial ou resultante de<br>
outra porta, como no exemplo ocorre com a última porta AND.<br>
Entetanto, segundo (KROPF, 2013), a análise de circuitos é extremamente complexa,<br>
resultando em um problema NP-Completo, algoritmos possuem tempo de execução exponencial.<br>
Contudo, este tempo de execução exponencial é uma complexidade exponencial para o pior caso,<br>
resultando crescimento exponencial da execução a medida que o tamanho do problema aumenta.<br>
Ainda, segundo (KROPF, 2013) a avaliação das funções booleanas podem ser ver-<br>
dadeiras(True) ou falso(False), com isso, para um função com n variáveis, apresenta 2n possibili-<br>
dades de avaliação. Utilizando o exemplo da Figura 7 que apresenta 3 entradas, logo apresenta 8<br>
possibilidade de avaliação ao final e este número aumenta à medida que o número de variáveis<br>
tambe aumenta<br>
2.2 Verificação de sistemas<br>
No contexto de verificação de sistemas, faz-se necessário a diferenciação entre verificação<br>
e validação. Verificação e validação possuem o intuíto de mostrar que determinado sistema fun-<br>
cione conforme o especificado, além de satisfazer as especificações do cliente (SOMMERVILLE,<br>
2011).<br>
Segundo (SARGENT, 2005), verificação é o processo de determinar se um modelo<br>
computacional obtido por discretização de um modelo matemático de um evento físico e o<br>
código que implementa o modelo computacional pode ser usado para representar o modelo<br>
matemático do evento com precisão suficiente e validação é o processo de determinar se um<br>
modelo matemático de um evento físico representa o evento físico real com precisão suficiente.<br>
A verificação consite identificação de erros e provavéis problemas que um componente<br>
pronto possa apresentar, enquanto a validação busca analisar se tal componete esta seguindo<br>
os requisitos pré-definidos para sua construção (KOSCIANSKI; SOARES, 2007). O teste de<br>
programa, na qual o software é executado com dados de teste é a principal forma de validação,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 20<br>
porém, tecnicas de verificação, tais como, inspeção e revisões também podem integrar a etapa de<br>
validação (SOMMERVILLE, 2011).<br>
2.2.1 Diagrama de decisão binária<br>
Um diagrama de decisão binária(DDB) pode ser definido como um grafo aciclico para<br>
representação de funcões boolenas. Existe uma ordem rigorosa na ocorrência de variáveis à me-<br>
dida que se percorre o grafo da raiz para a folha. Dado como exemplo a formula f=(a?b)?(c?d)<br>
e utilizando a ordenação de variavél a &lt; b &lt; c &lt; d, na Figura 8. Dada a atribuição de valores<br>
booleanos as variaveis a, b, c e d, pode-se decidir se a atribuição torna a fórmula verdadeira<br>
atravessando o início do gráfico na raiz e ramificação em cada nó. Definindo a, c e d = 1 e c = 0<br>
leva a folha de rótulo 1, portanto, a fórmula é verdadeira para essa tarefa (CLARKE et al., 1994).<br>
Figure 8 – Arvore de decisão binária<br>
Fonte: (CLARKE et al., 1994)<br>
Adicionar mais detalhes e descrever onde DDB é utilizado.<br>
O DDB permite o teste eficiente de satisfabilidade, validade e eficiência (KROPF, 2013).<br>
O uso e DDB em conjunto com Model Checking e técnicas de abstração permitiu o aumento na<br>
capacidade de verificação, de modo que sistemas mais realistas podessem ser verificados(??)<br>
2.2.2 Model Checking<br>
Model checking é uma técnica de verificação formal que explora todos os possíveis<br>
estados do sistema, de modo a provar se um modelo satisfaz determinada propriedade. Pode ser<br>
aplicada em uma ampla gama de aplicações, tais como sistema embarcados, design de hardware<br>
e engenharia de software (BAIER et al., 2008).<br>
Entre as vantagens da utilização de Model Checking estão:<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 21<br>
• Possuem suporte a verificação parcial, em outras palavras, a verificação individual de<br>
propriedades, permitido foco primeiro as propriedades essenciais(BAIER et al., 2008).<br>
• Não requer qualquer interação do usuário, nem um alto grau de especialização para o uso<br>
de model checking(BAIER et al., 2008).<br>
• Possui como base a teoria de grafos, estruturas de dados e lógica no desenvolvimento da<br>
solução(BAIER et al., 2008).<br>
• Útil para fins de depuração, pois formece informações em caso de uma propriedade seja<br>
invalidada(BAIER et al., 2008).<br>
Por outro lado, apresenta também algumas desvantagens:<br>
• Sofre do problema de explosão de espaço de estados, ou seja, a quantidade de estados<br>
necessários pode ser maior que a memória disponivel pelo sistema(BAIER et al., 2008).<br>
• Faz a verificação apenas dos requisios declarados, logo, não a garantia de integridade.<br>
Baseado nisso, a validade de propriedades não verificadas não pode ser julgada(BAIER et<br>
al., 2008).<br>
• A verificação de modelos geralmente não é computável, isso deve-se a questões de decidi-<br>
bilidade utilizada (BAIER et al., 2008).<br>
Outras técnicas foram implementadas em conjuntos com Model checkings com o intuito<br>
de aumentas a capacidade de verificação, como a técnica SAT na qual não sofre do problema de<br>
explosão de estados existente usando DDB. A técnica SAT em conjuto com Model Checking é<br>
conhecida como Bounded Model Checking (??).<br>
2.2.3 Bounded Model Checking<br>
Segundo ROCHA et al., Bounded Model Checking (BMC) é um tipo especial de Model<br>
Checking que usualmente adota o método de satisfabilidade booleana, o qual tem sido introduzido<br>
como uma técnica complementar para diagrama de decisão binaria para aliviar o problema da<br>
explosão de estados, visto que a técnica de Model Checking busca todos os estados possíveis<br>
para verificação.<br>
Bounded Model Checking é uma técnica para a verificação de uma dada propriedade<br>
em uma determinada profundidade do sistema analisado. Logo, dado um sistema de transições<br>
M, uma propriedade ?, e um limite (bound) k, o BMC desenrola o sistema k vezes e traduz o<br>
sistema em uma condição de verificação(CV) ? tal que ? é satisfeito se e somente se ? tem um<br>
contra-exemplo de profundidade menor ou igual a k (ROCHA et al., 2015b).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 22<br>
O Extended SMT-Based Bounded Model Checker (ESBMC) é um Bounded Model<br>
Checking baseado em satisfabilidade booleana (SAT) que permite verificação aritmética de Já tem<br>
su-<br>
porte<br>
a<br>
SMT<br>
adi-<br>
cionar<br>
ao<br>
texto<br>
overflow e undeflow, segurança de ponteiros, limite de array, de gerar propriedades de segurança<br>
em programas em C/C++. ESBMC utiliza uma versão modificada do CBMC no front-end para<br>
analisar o código ANSI-C e para gerar as condições de verificação através de execução simbólica<br>
(CORDEIRO et al., 2012; ROCHA et al., 2015b).<br>
No ESBMC, o programa analisado é modelado em um sistema de transição de estados,<br>
conforme a trupla: M = (S,R, S0), o qual é gerado um grafo de controle de fluxo (GFC), onde<br>
S representa o conjunto de estados, R ? SxS representa as transições e S ? S representa<br>
o conjuto de estados iniciais. Um estado s ? S consiste no valor do contador de programa<br>
(PC) e os valores de todas as variáveis dos programas. O estado inicial S0 atribui o inicio do<br>
programa GFC ao PC, desta forma o ESBMC identifica as transições, conforme a formula lógica,<br>
?=(Si,Si+1) que captura as retrições sobre os valores correspondntes do PC e das variáveis do<br>
programa (CORDEIRO et al., 2012).<br>
Segundo o site do ESBMC(??), a ferramenta permite ao usuário indicar propriedades<br>
adicionaisusando assertivas que também são verificadas. O ESBMC converte as condições Descrever<br>
quais<br>
pro-<br>
priedades<br>
o<br>
esbmc<br>
su-<br>
porta<br>
usando diferentes técnicas de backgroundpara posteriormente passar para verificador SMT. Outra<br>
apresentar<br>
exem-<br>
plo<br>
vantagem é a ferramenta permitir verificação de software single-thread e multi-thread.<br>
Descrever qual a razão da escolha para o trabalho, apresentar resultados do SV-COMP<br>
dos últimos 3 anos<br>
2.2.4 Redes de petri<br>
Apresentar definição formal para RP<br>
corrigir o texto abaixo RP não é uma ferramenta e sim um método de modelagem<br>
Redes de petri são utilizadas como ferramentas de modelagem gráfica com propriedades<br>
matemática. Como ferramenta gráfica são utilizadas como comunicação visual, como fluxogra-<br>
mas, por exemplo, e como ferramenta matemática podem configurar modelos matemáticos que<br>
regem o comportamento dos sistemas. A grade premissa desta ferramenta é descrever sistemas<br>
de processamento de informações caracterizados como concorrentes, assíncronos, distribuídos,<br>
paralelos, não deterministas e/ou estocásticos (MURATA, 1989).<br>
As redes de petri são representados como grafos direcionais compostos por nós e arcos,<br>
conforme apresentado na Figura 9. Os nós representam as transições e eventos e os arcos<br>
representam os pesos. Dentro desta representação, os arcos e eventos são componentes passivos<br>
enquanto as transições são ativos. A principal vantagem da utilização das redes de petri esta<br>
relacionado ao chamado "Token game" que consiste no comportamento da rede de petri, em<br>
outras palavras, representa o funcionamento do sistema representado pela rede(HALDER;<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 23<br>
VENKATESWARLU, 2006).<br>
Figure 9 – Rede de petri<br>
Fonte: (HALDER; VENKATESWARLU, 2006)<br>
Descrever o funcionamento da RP apresentado na IMG<br>
Descrever quais propriedades podem ser verificadas com RP e onde será utilizado no seu<br>
trabalho.<br>
2.2.5 Verificação de hardware<br>
Para a verificação de hardware diversas técnicas têm sido propostas (). Por meio da Apresentar<br>
exem-<br>
plos<br>
com<br>
refer-<br>
ências<br>
simulação, visa assegurar que uma implemetação, descrição do hardware em qualquer qualquer<br>
nível de abstração da hierarquia de hardware, atinja suas especificações, propriedades que devem<br>
ser respeitadas para que a corretude do mesmo seja comprovada (GUPTA, 1992). A Verificação<br>
formal de hardware consiste na utilização de técnicas para corretude de circuitos lógicos, ou<br>
seja, consiste na utilização de modelos matemáticos para descrição de propriedade e/ou de<br>
comportamento de um dado sistema (KROPF, 2013).<br>
Entre as abordagens utilizadas na verificação formal de hardware consiste tanto na imple-<br>
mentação quanto a especificação estarem descritas em lógica formal, neste caso a corretude será<br>
obtida através da comprovada relação entre a implementação e a especificação (SEGER, 1992).<br>
A especificação formal consiste na descrição do comportamento, bem como, das propriedades<br>
do sistema em linguagem matemática, tornando-se crucial para o processo de verificação. Na<br>
implementação formal, o nível de abstração, tais como, Gate level e RTL são importantes infor-<br>
mações para o desenvolvimento do formalismo, bem como as classes, por exemplo se o circuito<br>
é sequencial ou combinacional, se utiliza pipeline, etc (KROPF, 2013).<br>
Apresentar um exemplo de RTL<br>
A utilização de Model Checking também se faz presente nos modelos formais de ver-<br>
ificação de hardware, onde apenas é utilizado o comportamento dos circuitos na verificação,<br>
de modo a verificar a se as propriedades presentes são satisfeitas. Para isso, são utilizados os<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 24<br>
conceitos da lógica proposicional, que por meio da utilização de fórmulas que representem as<br>
propriedades dos estados, é possível realizar as verificações necessárias (SEGER, 1992).<br>
Apresentar um exemplo com um circuito e como este pode ser verificando com model<br>
checking<br>
2.2.6 Verificação formal de software<br>
Observa-se que o uso de verificacão de software tem sido feito aplicado em muitas áreas,<br>
tais como, infraestruturas industriais de missão critica e de segurança. Logo, existe a necessidade<br>
de garantir a corretude destes sistemas. Devido a isso, a verificação formal tem sido utilizada em<br>
três principais abordagens, sendo elas (COUSOT; COUSOT, 2010; D’SILVA et al., 2008):<br>
Apresentar exemplos para os métodos apresentados abaixo<br>
• Métodos dedutivos: Produzem provas matemáticas formais de corretude usando provadores<br>
de teoremas ou assistentes de prova para execução da prova e necessitam da interação<br>
humana para prover os argumentos (COUSOT; COUSOT, 2010);<br>
• Verificação de modelos: Exploram exaustivamente modelos de execuções de programa,<br>
que podem ser sujeitos a explosão combinatória, necessário a intervenção humana para<br>
geração dos modelos (ROCHA et al., 2015b);<br>
• Analise estática: Engloba diversas técnicas para calcular automaticamente informações<br>
sobre o comportamento de um programa sem executá-lo, sendo utilizado em otimização<br>
de código e verificação em compiladres (D’SILVA et al., 2008).<br>
Segundo ROCHA et al., na verificação formal de software apresentam-se dificuldades,<br>
tais como: quais as propriedades são de interesse na verificação em tempo de execução; e<br>
impossibilidade matemática de provar a corretude de propriedades não triviais no comportamento<br>
de programas (COUSOT; COUSOT, 2010).<br>
2.2.7 Lógica proposicional<br>
A lógica proposicional é uma linguagem formal onde é definida um alfabeto e conectivos<br>
proposicionais, e um conjunto de regras gramaticais, as quais serão utilizadas para construção<br>
das proposições (SOUZA, 2017). Porém apesar de importante, ela é limitada, não podendo<br>
expressar sentenças elementares importantes, tais como a da aritmética elementar. Por exemplo:<br>
1. Todos são mortais.<br>
2. Alguém é bondoso.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 25<br>
Na lógica preposicional, não poderiam ser analisadas, pois não teria como decompor<br>
ambas em sentença e assim não teria como analisar as diferenças entre ambas(ABE, 2002).<br>
Contudo, no exemplo: Existem cavalos com patas verdes. A relação criada pela frase poderia a<br>
ser analisada pela lógica proposicional(ABE, 2002). Descrever<br>
como<br>
seria<br>
está<br>
analise<br>
Segundo SOUZA, alfabeto da lógica proposicional é formado por símbolo de pontuação,<br>
símbolos proposicionais e conectivos proposicionais, onde cada um apresenta uma função em<br>
específico, sendo:<br>
• Símbolos de pontuação: Apenas dois símbolos de pontuação são utilizados o "(" e o ")".<br>
• Símbolos proposicionais: São utilizados para representar as proposições, onde um sím-<br>
bolo P pode ser utilizado para representar uma proposição qualquer, por exemplo: P="Está<br>
chovendo". O conjunto de símbolos proposicionais é infinito e enumerável, sendo possível<br>
representar infinitos e enumerável conjunto de proposições.<br>
• Conectivos proposicionais: São os símbolos usando frequentemente na matemática. Os<br>
símbolos recebem a seguinte denominação:<br>
1. ¬: Representa a partícula de negação, ou seja, "Não".<br>
2. ?: Representa a partícula "Ou"<br>
3. ?: Representa a partícula "E"<br>
4. ?: Representa a partícula "Se então ou implica".<br>
5. ?: Representa a partícula "Se, e somente se".<br>
Ainda segundo SOUZA, existem as fórmulas que são constituídas de forma indutiva, a<br>
partir de símbolos do alfabeto conforme as regras apresentadas abaixo:<br>
• Todo o símbolo preposicional é uma fórmula<br>
• Se H é uma fórmula, então (¬H), a negação de H, é uma fórmula.<br>
• Se H e G são fórmulas, então a disjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a conjunção de H e G, dada por (H ? G), é uma fórmula.<br>
• Se H e G são fórmulas, então a implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o antecedente e G consequente da fórmula.<br>
• Se H e G são fórmulas, então a bi-implicação de H e G, dada por (H? G), é uma fórmula.<br>
Neste caso, H é o lado esquerdo e G o lado direito da fórmula.<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 26<br>
2.2.8 Linguagem de especificação de propriedades<br>
Linguagem de especificação de propriedades, do inglês Property Specification Language<br>
- PSL, é uma notação formal para especificação de comportamento em sistemas eletrônicos,<br>
compatível com as linguagens VHDL, Verilog, SystemC e SystemVerilog. Destina-se a utilização Adicionar<br>
refer-<br>
ência<br>
a cada<br>
Ling<br>
citada<br>
para a especificação funcional, mas também para entrada de ferramentas de verificação. A<br>
especificação do PSL é a utilização de assertivas sobre propriedades de um sistema, sendo estas<br>
propriedades constituídas de três elementos: expressões boolenas, expressões sequenciais e<br>
operadores temporais (IEEE. . . , 2010).<br>
Corrigir a apresentação da citação IEEE... estranho<br>
Segundo (IEEE. . . , 2010), o PSL foi totalmente desenvolvida com o intuito fornecer<br>
leitura e escrita de fácil entendimento, sintaxe concisa, semântica formal e rigorosamente bem<br>
definida e ser matematicamente precisa, visto a utilização da mesma em processo de verificação.<br>
O PSL pode ser utilizado para capturar requisitos relativos ao comportamento total do projeto,<br>
bem como, sobre o modo que o mesmo deverá operar no ambiente, ms também para capturar<br>
requisitos comportamentais e os pressupostos que surgem durante o processo de design. Ambas<br>
podem ser utilizadas para verificação de sistemas.<br>
Apresentar exemplos de uso da PSL<br>
2.2.9 Verificação baseada em assertivas<br>
Verificação baseada em assertivas, do inglês Assertion-Based Verification - ABV, é um<br>
paradigma de verificação igualente adequado para verificação formal e abordagens baseadas em<br>
simulação (BOULE; ZILIC, 2005) e em conjunto com a tecnica de PSL tem ganhado aceitação<br>
como um método essencial para verificação funcional do hardware (DAHAN et al., 2005).<br>
Na ABV as assertivas são declaração adicionadas ao projeto com o intuito de especificar<br>
o comportamento do projeto (BOULE; ZILIC, 2005), podendo escritos em PSL ou em SVA<br>
(System Verilog Assertions). No caso deste projeto será utilizado a PSL, devido a mesma ser<br>
utilizada juntamente com a linguagem VHDL.<br>
Com a utilização de ABV o circuito pode ser verificado usando técnicas de simulação<br>
e/ou verificação, por exemplo, model checking, para garantir que o mesmo esteja de acordo<br>
com o pretendido projeto (DAHAN et al., 2005). Na Figura 19 apresenta o modelo de assertiva<br>
utilizada no projeto, utilizando de um modelo próprio para assertivas, unindo as funcionalidades<br>
já existentes nas assertivas do VHDL, mas também novas (serão apresentadas nas próximas<br>
seções), fornecendo assim mais propriedades a serem analisadas.<br>
Descrever qual o objetivo da assert apresentado<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 27<br>
Figure 10 – Exemplo de declaração de assertiva no VHDL.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 e n t i t y AND_ent i s<br>
5 p o r t ( x , y : i n b i t ;<br>
6 F : o u t b i t<br>
7 ) ;<br>
8 end AND_ent ;<br>
9<br>
10 a r c h i t e c t u r e behav1 of AND_ent i s<br>
11 b e g i n<br>
12 ??@c2vhdl : ASSERT<br>
13 ??a s s e r t n o t ( x= ’ 0 ’ and y= ’ 1 ’ )<br>
14 ?? r e p o r t " Both v a l u e s o f s i g n a l s x and y a r e e q u a l t o 1 "<br>
15 ??s e v e r i t y ERROR;<br>
16 ??@c2vhdl :END<br>
17<br>
18 p r o c e s s ( x , y )<br>
19 b e g i n<br>
20 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
21 F &lt;= ’ 1 ’ ;<br>
22 e l s e<br>
23 F &lt;= ’ 0 ’ ;<br>
24 end i f ;<br>
25 end p r o c e s s ; 4<br>
26 end behav1 ;<br>
Fonte: Própria.<br>
2.2.10 Propriedades de segurança<br>
Propriedades de segurança é um meio de validação do comportamento de um determinado<br>
sistema, de modo que se uma dada propriedade de segurança for violada, então através de<br>
uma execução finita, é possível verificar tal erro. Algumas propriedades de segurança, no<br>
entanto, podem impor requisitos em fragmentos de caminho finito e não podem ser verificadas<br>
considerando apenas os estados alcançáveis. (BAIER et al., 2008).<br>
Segundo (CLARKE et al., 2003), podemos definir uma propriedade de segurança como:<br>
dado um sistema de transições ST = (S, S0, E), seja um conjunto B ? S que especifica um<br>
conjunto de maus estados tais que S0 ?B = ?, pode-se dizer que ST é seguro com relação a B,<br>
denotado por ST |= AG¬B se não existe um caminho no sistema de transição do estado inicial<br>
S0 até o estado B, de outro modo é dito que ST não é seguro.<br>
Adicionar exemplos de propriedades de segurança em hardware<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 28<br>
2.3 Técnicas de compiladores<br>
Compiladores são sistemas de software utilizados para tradução de uma linguagem de<br>
programação para outra, ou seja, o programa da linguagem fonte é lido e traduzido para um<br>
código equivalente na outra linguagem, ou linguagem alvo. Geralmente utilizada para transformar<br>
trechos de código em uma linguagem a ser executada pelo computador (AHO et al., 2007).<br>
Diversas técnicas podem ser utilizadas nas diversas etapas, até que o código seja traduzido,<br>
tais como LL(1) e LR na análise sintática; eliminação de código morto; propagação de constante<br>
e Peephole na otimização de código(AHO et al., 2007). Neste projeto serão focados as áreas de<br>
transformações de código e otimização de código.<br>
2.3.1 Transformações de código<br>
Transformações de código correspondem a uma complexa função que envolve analise de<br>
fluxo de dados e modificação completa do programa que são parte integral da alta performance e<br>
sistemas computacionais. Podem ser classificados em transformações escalares que reduzem<br>
o número de instruções a serem executadas no programa ou transformações paralelas que<br>
maximizam o paralelismo (SRIKANT; SHANKAR, 2002).<br>
A Figura 11 representa o trecho de código apresentado na Figura 19. O trecho representa<br>
o comportamento das entradas, neste caso de um código da porta AND. E a figura Figura 12<br>
representa a tradução deste trecho em código na linguagem C. Esta tradução foi realizada pela<br>
ferramenta V2C, utilizada neste projeto. Adicionar<br>
refer-<br>
ência<br>
Figure 11 – Trecho de código em VHDL representando porta AND.<br>
1 p r o c e s s ( x , y )<br>
2 b e g i n<br>
3 i f ( ( x= ’ 1 ’ ) and ( y= ’ 1 ’ ) ) t h e n<br>
4 F &lt;= ’ 1 ’ ;<br>
5 e l s e<br>
6 F &lt;= ’ 0 ’ ;<br>
7 end i f ;<br>
8 end p r o c e s s ;<br>
Fonte: Própria.<br>
Expandir esta seção. Apresentar propriedades de transformação e técnicas para avaliar a<br>
transformação<br>
2.3.2 Otimização de código<br>
A otimização de código consiste na melhoria do código intermediário gerado pelos<br>
algoritmos de compilação com o objetivo de obter um menor tempo de execução do programa,<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 29<br>
Figure 12 – Trecho de código traduzido para linguagem C.<br>
1 /? S t a r t o f T r a n s l a t i o n ? /<br>
2 /? p0 : ? /<br>
3 i f ( chg [ x ] | | chg [ y ] ) {<br>
4 i f ( ( ( o l d [ x ]==1) && ( o l d [ y ]==1) ) ) {<br>
5 new [ f ] = 1 ;<br>
6 }<br>
7 e l s e {<br>
8 new [ f ] = 0 ;<br>
9 }<br>
10 }<br>
11 /? End o f T r a n s l a t i o n ? /<br>
Fonte: Própria.<br>
porém outros fatores podem ser introduzidos, como algoritmos menores. Este fato não implica<br>
em afirmar que o melhor código é gerado, visto que dada a complexidade, raramente pode ser<br>
obtido que o código gerado pode ser o melhor possível (AHO et al., 2007).<br>
Segundo AHO et al., otimização local de código consiste na otimização de um bloco<br>
básico de código, ou seja, a otimização ocorre em um trecho especifico de código. Os blocos<br>
básicos são trecho onde não ocorrem saltos ou loops, para nenhuma outra parte do código. A<br>
otimização global de código é baseado na analise do fluxo de dados, de modo que ocorra as<br>
elminação de instruções não necessárias ou substituição mais facil. A otimização global consite<br>
na analise completa do código. Neste sentido, nas próximas seções serão apresentadas algumas<br>
importantes técnicas de otimizações.<br>
2.3.2.1 Grafo Acliclico Direcional - GAD<br>
Grafo Aciclico Direcional é utilizado para diversos fins dentro da estrutura de compi-<br>
ladores, principalmente para geração da parse tree otimização de código. Pode ser usado na<br>
representação de instruções unicas blocos básicos de código(AHO et al., 2007). O uso de GAD<br>
permite a melhoria de de código, tais como:<br>
• Elminação de subexpressões locais comuns, ou seja, expressões que o valor já foi com-<br>
putado anteriomente;<br>
• Eliminação de código morto;<br>
• Reordernamento de declarações buscando reduzir o tempo que o valor temporário necessita<br>
ser preservado em um registro;<br>
A Figura 13 apresenta um bloco básico com algumas instruções, no caso apresentando<br>
são 4 operações entre somas e multiplicação e a partir deste bloco a Figura 14 apresenta o GDA<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 30<br>
Figure 13 – Exemplo de bloco basico de código.<br>
1 a = b + c<br>
2 b = a ? d<br>
3 c = b + c<br>
4 d = a ? d<br>
Fonte: (AHO et al., 2007)<br>
Figure 14 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
deste trecho de código. Nele apresenta cada nó como uma operação especifica e os terminais<br>
como as parcelas das operações.<br>
2.3.2.2 Grafo de Fluxo de Controle - GFC<br>
Grafo de fluxo de controle corresponde a um grafo direcionado, no qual cada nó rep-<br>
resenta blocos básicos e cada aresta representa os caminhos de fluxo entre os blocos basi-<br>
cos (ALLEN, 1970). É importante ressaltar que saltos determinam o final de um determinado<br>
bloco básico, ou seja, saltos indicam um caminho para uma nova região de código básico (AHO<br>
et al., 2007).<br>
Apresentar um exemplo de como e utilizado em código<br>
2.3.2.3 Eliminção de código morto<br>
A eliminacação de código morto é uma técnica que busca a eficiência de um programa<br>
evitando a execução de instruções não necessária em tempo de execução (KNOOP et al., 1994).<br>
O código morto consiste em instruções que não serão alcançáveis durante o fluxo do programa,<br>
sendo esta técnica basicamente a retirada de qualquer variável que não será utilizada em qualquer<br>
outro nó do grafo (AHO et al., 2007).<br>
A utilização de GAD corresponde na eliminação de qualquer nó raiz, ou seja, nó sem<br>
ancestrais, as quais não esteja ativa anexada a mesma. A execução repetida desta operação<br>
removerá todos os nós correspondentes a código morto (AHO et al., 2007).<br>
Chapter 2. CONCEITOS E DEFINIÇÕES 31<br>
Figure 15 – GAD do bloco básico da Figura 13<br>
Fonte: (AHO et al., 2007)<br>
Na Figura 15, supondo que os nós a, b e c estejam ativa, porém o nó énão esteja, o último Corrigir<br>
nó é?pode ser eliminado imediatamente. Os nós restantes continuam no GDA, a menos que não tenho<br>
variáveis ativas atreladas aos nós (AHO et al., 2007).<br>
2.3.2.4 Análise do fluxo de dados<br>
Análise de fluxo de dados refere-se ao conjunto de técnicas que derivam informações<br>
sobre o fluxo de dados ao longo dos caminhos de execução do programa. Para análise do<br>
programa, é necessário considerar todas as posiveis execuções através do grafo de fluxo de<br>
controle (AHO et al., 2007).<br>
Apresentar exemplos<br>
2.3.2.5 Gerador de código<br>
O gerador de código é responsavél pela tradução final do programa-fonte para o programa-<br>
alvo, o mesmo recebe como entrada um código intermediário juntamente com a tabela de<br>
símbolos. Faz-se necessário que o programa-fonte tenha sido analisado sintatica e lexicamente,<br>
assim evitando que erros possam ser passados para o programa-alvo, por outro lado a existência<br>
de uma nível de otimização, faz-se opicional neste caso (AHO et al., 2007).<br>
O gerador de código possui três tarefas primarias, sendo as mesmas seleção de instrução,<br>
alocação de registros e atribuições. A seleção de instruções envolve a escolha das instruções<br>
apropriadas da máquina-alvo para implementar as declarações do código intermediario. A<br>
atribuição e atribuição de registros envolve a decisão sobre os valores a serem registrados nos<br>
registros(AHO et al., 2007).<br>
Apresentar exemplo<br>
32<br>
3 TRABALHOS CORRELATOS<br>
Sugiro apenas mencionar que foi feito a revisão sistemática; o que já foi feito e os resul-<br>
tados. As outras seções sobre RS e mover para apêndice.<br>
3.1 Revisão sistemática<br>
A revisão sistemática consiste é um método de identificação, análise e interpretação de<br>
pesquisas relevantes em determinada área ou questão de pesquisa. Para execução da revisão sis-<br>
temática se requer um esforço maior, em comparação as pesquisas tradicionais, sendo necessário<br>
seguir uma sequência de passos metodológicos sobre a área ou questão de pesquisa ao qual<br>
deseja ser feita a pesquisa (KITCHENHAM, 2004).<br>
Para a execução da revisão sistemática, é necessário um esforço considerável, se com-<br>
parado a uma revisão informal a literatura. Enquanto que a revisão de literatura informal é<br>
conduzida de forma ad-hoc, sem planejamento e critérios de seleção estabelecidos a priori,<br>
a revisão sistemática requer um protocolo formal bem definido, com uma sequência de pas-<br>
sos metodológicos, para conduzir uma pesquisa sobre o tema ao qual deseja-se realizar a<br>
pesquisa (MAFRA; TRAVASSOS, 2006).<br>
A aplicação da revisão sistemática requer que seja seguido um conjunto bem definido e<br>
sequêncial de passos, seguindo um protocolo de pesquisa desenvolvido previamente. Através<br>
deste método é possível realizar uma extensa pesquisa, contemplando uma grande quantidade<br>
de informações sobre o assunto pesquisado (MAFRA; TRAVASSOS, 2006). Este protocolo é<br>
construído considerando um tema específico que representa o elemento central da investigação,<br>
onde os passos da pesquisa, as estratégias definidas para coletar as evidências e o foco das<br>
questões de pesquisa são definidas explicitamente, de tal forma que outros pesquisadores sejam<br>
capazes de reproduzir o mesmo protocolo de pesquisa (BIOLCHINI et al., 2005).<br>
Segundo MAFRA; TRAVASSOS, o processo para a condução de revisões sistemáticas<br>
envolve três etapas:<br>
1. Planejamento da Revisão: os objetivos da pesquisa são listados e o protocolo da revisão<br>
é definido.<br>
2. Condução da Revisão:nesta atividade, as fontes para a revisão sistemática são sele-<br>
cionadas, os estudos primários são identificados, selecionados e avaliados de acordo com<br>
os critérios de inclusão, exclusão, e de qualidade estabelecidos durante o protocolo da<br>
revisão.<br>
Chapter 3. TRABALHOS CORRELATOS 33<br>
3. Análise dos Resultados: os dados dos estudos são extraídos e sintetizados para análise e<br>
apresentação dos resultados.<br>
Vale ressaltar que como o objetivo deste trabalho é realizar um estudo exploratório de<br>
caracterização de área podemos dizer que esta revisão sistemática se caracteriza como uma quasi-<br>
sistemática (TRAVASSOS et al., 2008), pois segue o mesmo processo da revisão sistemática e<br>
preserva o rigor e mesmo formalismo para as fases metodológicas de elaboração de protocolo e<br>
execução da revisão, mas sem a aplicação de uma meta-análise a princípio, que pode ser aplicada<br>
posteriormente.<br>
3.1.1 Planejamento da Revisão Sistemática<br>
Objetivo: Este estudo tem o objetivo esquematizado a partir da estrutura do paradigma<br>
GQM (do ingles Goal,Question and Metric)(BASILI et al., 1994).<br>
Analisar Publicações científicas através de um estudo baseado em revisão sis-<br>
temática<br>
Com propósito de Identifica-las<br>
Com relação as Vantagens e desvantagens da utilização de assertiva e transformações<br>
de código na verificação do código na linguagem de descrição VHDL<br>
Do ponto de vista do Pesquisador<br>
No contexto Acadêmico ou industrial para verificação de assertivas na linguagem<br>
de descrição VHDL<br>
Table 1 – Objetivo do estudo utilizando o paradigma GQM<br>
Formulação da Pergunta: Buscamos respostas para as seguintes perguntas:<br>
• Q1: Quais são os métodos para verificação de circuitos lógicos descritos na linguagem de<br>
programação VHDL?<br>
– Q1.1: Foi desenvolvido e está disponível alguma ferramenta para aplicação do<br>
método?<br>
– Q1.2: Qual a técnica de exploração de estados para circuitos lógicos?<br>
– Q1.3: O método proposto é baseado em técnicas de verificação de software?<br>
– Q1.4: Como o método proposto valida pré e pós condições no programa?<br>
– Q1.3: Foi utilizado algum benchmark de programas em VHDL para experimentação<br>
e o mesmo encontra-se disponível?<br>
– Q1.4: Quais as perspectivas futuras para melhorar da aplicação do método proposto?<br>
Escopo da pesquisa:Na delimitação do escopo da pesquisa foram estabelecidos critérios,<br>
buscando garantir a viabilidade da execução, acessibilidade dos dados e abrangência do estudo re-<br>
alizado. A pesquisa dar-se-á a partir de bibliotecas digitais através das suas respectivas máquinas<br>
Chapter 3. TRABALHOS CORRELATOS 34<br>
de busca e, quando os dados não estiverem disponíveis eletronicamente, através de consultas<br>
manuais.<br>
Critérios de Seleção de Fontes. Para as bibliotecas digitais é desejado:<br>
• Possuir uma máquina de busca que permita o uso de expressões lógicas ou mecanismo<br>
equivalente.<br>
• Incluir em sua base, publicações de exatas ou correlatas que possuam relação direta com o<br>
tema a ser pesquisado<br>
• As máquinas de busca deverão permitir a busca no texto completo das publicações.<br>
Segundo ROCHA et al., os mecanismos de busca utilizados devem garantir resultados<br>
únicos através da busca de um mesmo conjunto de palavras-chaves (string de busca). Quando<br>
isto não for possível, deve-se estudar e documentar uma forma de minimizar os potenciais efeitos<br>
colaterais desta limitação.<br>
Métodos de Busca das Publicações. As fontes digitais foram acessadas via Web, através<br>
de expressões de busca pré-estabelecidas. A biblioteca digital consultada foi a Scopus, acessível<br>
em http://www.scopus.com. Segundo a editora ELSEVIER, a Scopus é uma das maiores bases<br>
de dados de resumos e citações da literatura de pesquisa peer-reviewed com mais de 22, 800<br>
títulos de mais de 5, 000 editoras internacionais abrangendo as áreas de tecnologia, medicina,<br>
artes, ciências sócias e com atualizações diárias. Entre as editoras podemos citar: Springer<br>
(SPRINGER, 2018); IEEE Xplore Digital Library (IEEE, 2018);ACM Digital Library (ACM,<br>
2018) ; ScienceDirect/Elsevier (B.V, 2018); Wiley Online Library (SONS, 2018); dentre outras.<br>
String de Busca. A string de busca foi definida segundo o padrão PICO (do inglês<br>
Population, Intervention, Comparison, Outcomes) (KITCHENHAM et al., 2009), conforme a<br>
estrutura abaixo:<br>
• População: Trabalhos publicados em conferências e periódicos que relacionam verificação<br>
de propriedades de circuitos lógicos em códigos para a descrição de hardware.<br>
• Intervenção: Verificação de propriedades relacionadas a verificação de circuitos para as<br>
diferentes estruturas das linguagens de descrição de hardware;<br>
• Comparação: análise de cobertura e suporte das abordagens identificadas para a verificação<br>
de propriedades das linguagens de descrição de hardware;<br>
• Resultados: a partir da descrição das abordagens pretende-se verificar a cobertura que cada<br>
abordagem apresenta na manipulação das diferentes estruturas da linguagem de descrição<br>
de hardware para a verificação de propriedades baseada em assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 35<br>
Segundo ROCHA et al., como este estudo representa um estudo de mapeamento/caracteri-<br>
zação, a string de busca foi definida de acordo com dois aspectos: População e Intervenção, como<br>
é apresentado na estrutura abaixo. Posteriormente esta mesma string de busca será executada<br>
na biblioteca Scopus para busca de artigos e publicações de modo a gerar uma interseção entre<br>
população e intervenção.<br>
• População: publicações que fazem referência a verificação de propriedades de circuitos<br>
lógicos e sinônimos:<br>
– Palavras-chaves: "circuit checker" OR "circuit verification" OR "contract based<br>
verification" OR "code analysis" OR "static analysis" OR "dynamic analysis" OR<br>
"safety verification" OR "RTL analysis" OR "program analysis" OR "property veri-<br>
fication" OR "formal verification" OR "model checking" OR "model checker" OR<br>
"hardware checker" OR "hardware verification" OR "validity checker" OR "hard-<br>
ware assertion" OR "assertion checker" OR "assert verification" OR "assertion-based<br>
verification" OR "assertion based verification" OR "assertion-based design" OR "bit<br>
level verification"<br>
• Intervenção: Verificação de circuitos e sinônimos:<br>
– Palavras-chaves:"hardware statement" OR "hardware code" OR "hardware source<br>
code" OR "hardware semantics" OR "hardware property" OR "logical gates" OR<br>
"sequential circuit" OR "parallel circuit" OR "real circuits" OR "complex circuits"<br>
OR "control circuitry" OR ”software netlist” OR “hardware emulation” OR “silicon<br>
debug”<br>
3.1.1.1 Procedimentos de Seleção e Critérios<br>
A estratégia de busca será aplicada por um pesquisador para identificar as publicações<br>
em potencial. A seleção das publicações dar-se-á em 2 etapas, conforme apresentado a seguir.<br>
1. Seleção e catalogação preliminar dos dados coletados: A seleção preliminar das publi-<br>
cações será feita a partir da aplicação da string de busca na biblioteca Scopus, o resultado<br>
desta busca corresponde a seleção preliminar. Todas as publicações serão armazenadas<br>
para análise posterior;<br>
2. Seleção dos dados relevantes - [1 filtro]: A seleção preliminar com o uso da expressão<br>
de busca não garante que todo o material coletado seja útil no contexto da pesquisa, pois a<br>
aplicação das expressões de busca é restrita ao aspecto sintático. Por isso, é necessário a<br>
criação de filtros de exclusão e inclusão, de modo a classificar os artigos e publicações que<br>
se enquadram no contexto da pesquisa realizada. Nesta epata apenas serão lidos o título,<br>
abstracts, e palavras-chaves e classificar de acordo com os filtros, ou seja, se será aceito ou<br>
excluído. Devem ser excluídas as publicações contidas no conjunto preliminar que:<br>
Chapter 3. TRABALHOS CORRELATOS 36<br>
• CE1-01: Não serão selecionadas publicações em que as palavras-chave da busca<br>
não apareçam no título, resumo e/ou texto da publicação (excluem-se os seguintes<br>
campos: as seções de agradecimentos, biografia dos autores, referências bibliográficas<br>
e anexas).<br>
• CE1-02: Não serão selecionadas publicações em que descrevam e/ou apresentam<br>
‘keynote speeches’, tutoriais, cursos e similares.<br>
• CE1-03: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação/validação de códigos para descrição de hardware.<br>
• CE1-04: Não serão selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação não cita uma abordagem para<br>
verificação de código de descrição de hardware baseado em assertivas ou propriedades<br>
de verificação de hardware.<br>
Podem ser incluídas apenas as publicações contidas no conjunto preliminar que:<br>
• CI1-01:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita uma abordagem para verificação<br>
de código de descrição de hardware baseado em assertivas ou propriedades de<br>
verificação de hardware.<br>
• CI1-02:Podem ser selecionadas publicações em que o contexto das palavras-chave<br>
utilizadas no artigo leve a crer que a publicação cita recomendações de melhoria<br>
na utilização de abordagens para verificação de código de descrição de hardware<br>
baseado em assertivas ou propriedades de verificação de hardware.<br>
3. Seleção dos dados relevantes - [2 filtro]: Apesar do 1o filtro limitar o universo de busca,<br>
infelizmente não há garantias de que todo material selecionado no filtro anterior seja útil<br>
no contexto da pesquisa. Neste caso, novos filtros são gerados, buscando, da mesma forma<br>
que o primeiro filtro, classificar os artigos e publicações que se enquadram no contexto<br>
da pesquisa. Para este filtro é necessário a leitura na integras dos artigos selecionados<br>
anteriormente. O objetivo é identificar que relacionam assertivas e/ou propriedade de<br>
verificação de hardware.<br>
• CS2 -ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware e não citam assertivas<br>
• CS2 +ASS -VER_HARD: Não devem ser selecionadas publicações que não contex-<br>
tualizem verificação de hardware, mas citam assertivas<br>
• CS2 -ASS +VER_HARD: Não devem ser selecionadas publicações que contextual-<br>
izam verificação de hardware, mas citam assertivas.<br>
Chapter 3. TRABALHOS CORRELATOS 37<br>
Dessa forma, todas as publicações devem respeitar o critério abaixo:<br>
• CS3 +ASS +VER_HARD: Serão selecionadas publicações que contextualizam<br>
verificação de hardware e citam assertivas em seu contexto.<br>
Devido ao tempo necessário para o desenvolvimento execução dos filtros da revisão<br>
sistemática serem extensos, apenas o primeiro filtro foi executado neste projeto, mesmo que<br>
os parâmetros para o segundo filtro já tenho sido desenvolvidos. Em contra partida foram<br>
selecionados 6 artigos que serviram como ferramentas de estudo para o desenvolvimento da<br>
metodologia que será apesentada no Capítulo 4.<br>
3.2 Revisão da literatura<br>
Nesta sessão serão apresentados trabalho relevantes para o desenvolvimento do método<br>
proposto que foram identificados utlizando a revisão sistemática mencionado anteriormente.<br>
Os artigos apresentam técnicas de transformações de código, utilização de Assertion-Based<br>
Verification e PSL para verificação de hardware.<br>
3.2.1 V2c-A verilog to C translator<br>
O artigo de MUKHERJEE et al. apresenta uma ferramenta implementada em C++<br>
chamada v2c para transformação de código da linguagem de descrição Verilog para linguagem<br>
de programação C. A ferramenta é executada a nível de palavra, visto que esta abordagem garante<br>
uma aumento na escalabilidade, mas também proporionando que técnicas, como interpolaçãoe adicionar<br>
refer-<br>
ência<br>
aceleração de looppossam ser utilizadas para verificação, algo inviavél, caso a tradução fosse<br>
adicionar<br>
refer-<br>
ência<br>
executada a nível de bit. O sistema recebe como entrada um código em Verilg, onde são aplicadas<br>
regras semânticas e mapeando os bit de operação, chamado software netlist. Após isso, o código<br>
intermediário é convertido para C.<br>
A contribuição deste trabalhoconsiste na utilização de transformações de código como<br>
Qual<br>
tra-<br>
balho?<br>
base principal e partindo deste pressuposto torna-se vantajoso devido a utilização de outras<br>
ferramentas que não apresente suporte a certas linguagens, tais com a ferramenta ESBMC,<br>
utilizada neste trabalho, não apresenta suporte a VHDL, porém apresenta suporte as linguagens<br>
C/C++. Em outras palavras, a contribuição deste trabalhofoi a utilização de traduções de códigos<br>
Qual<br>
tra-<br>
balho?<br>
e utilizado este conceito como modelo de entrada para analise de circuitos.<br>
3.2.2 Unbounded safety verification for hardware using software ana-<br>
lyzers<br>
No artigo de MUKHERJEE et al. foi apresentado uma metodologia que aborda a utiliza-<br>
ção de técnicas e analisadores de software, com o objetivo de de abordar a análise de circuitos e<br>
Chapter 3. TRABALHOS CORRELATOS 38<br>
com isso trançar um paralelo entre as abordagens. Para testes foram utilizadas três metodologias<br>
de análise, usando interpolação, k-inductione tecnologias hibrídas. Como resultante dos testes, foi adicionar<br>
refer-<br>
ência<br>
adicionar<br>
refer-<br>
ência<br>
observado as principais causas de erros, por exemplo, bits não preciso e no caso das operações<br>
a bit-level ocorria perda de informações. Também foi obeservado que apesar de não serem<br>
otimizadas para análises de hardware, alguns analisadores de softaware podem, dependendo da<br>
técnica utilizada no analisador, ser utilizada para analise de hardware.<br>
Descrever<br>
qual<br>
o mo-<br>
tivo.<br>
A utilização de técnicas de análise de software para o desenvolvimento de análise de<br>
hardware é o foco a ser abordado neste neste trabalho de maneira prática, utilizando os princípio<br>
analisados por (MUKHERJEE et al., 2016a). Neste contexto, o objetivo deste trabalho é a<br>
utilização de técnicas de software para análise de circuitos, diferente do artigo apresentado acima<br>
que busca utilização uma abordagem mais complexa provando a possibilidade da utilização de<br>
técnicas de analise de software no contexto da verificação de hardware.<br>
A última frase está confusa, no meu entedimento é o mesmo sentido.<br>
3.2.3 Formal verification of timed VHDL programs<br>
No trabalho apresentado por BARA et al. é proposto uma abordagem para a análise<br>
de tempo relacionado a cada porta lógica dentro de um dado circuito analisado. A abordagem<br>
apresenta a tradução de um circuito lógico codificado em VHDL para um formalismo baseado<br>
em automato de tempo. Tal formalismo é representado por uma automato de estados finitos referência<br>
com relogios simbólicos que evoluem em taxa uniforme. A tradução é executada de modo<br>
automatico, baseado na emulação da propagação de cada transação ao longo de cada sinal, o<br>
seja, são automatos programados e cronometrados do circuito. Após a tradução para automato, a<br>
analise é feita pela ferramenta UPPALque é um model checking de verificação de propriedades referência<br>
de tempo. Seguindo esta metodologia a análise pode ser extraida de modo independente de cada<br>
bloco, desta forma a análise é feita de forma mais precisa, podendo ser analisado inumeros<br>
fatores, tais como limites de intervalo e sinal de correlação.<br>
O artigo apresenta uma abordagem de tempo, que torna-se interessante adição ao método.<br>
Porém até o momento a função não foi implementada ficando a trabalho futuros.<br>
Expandir o texto acima, exemplo, descrever como o método poderia ser incluindo no seu<br>
TCC.<br>
3.2.4 On the use of assertions for embedded-software dynamic verifica-<br>
tion<br>
Em GUGLIELMO et al. é apresentado uma metodologia para a integração dinamica de<br>
Assertion-Based Verification para várias fases da análise da verificação de fluxo em sistemas<br>
embarcados, por exemplo, emulação, diagnosticos e Debug, mas também um ferramenta chamada<br>
Chapter 3. TRABALHOS CORRELATOS 39<br>
RadCheck. O metodo de aplicação, chamado V-model é dividido em fases de verificação em<br>
paralelo com as fases de design do circuito. Com base no V-model, o método é aplicado, iniciando<br>
com o nível de sistema e as especificação do sistema, neste caso especificado usando PSL.<br>
Neste nível é especificado todas as funcionalidades gerais da aplicação. No nível de integração<br>
visa investigar problemas de interação que possam ocorrer, definindo propriedades que cobrem<br>
incrementalmente as unidades estruturais interativas de aplicação. No nível de unidade descrevem<br>
comportamentos internos e são definidas através de parâmetros de entrada/saída das unidade e<br>
estruturas de dados internas.<br>
A contribuição deste projeto está relacionado a utilização de assertivas no contexto da<br>
verificação de software. As assertivas são o principal meio de análise proposto neste projeto,<br>
visto que estas mesma assertivas serão analisadas pelo ESBMC. Aliado a isso em GUGLIELMO<br>
et al. é apresentado modelos de utilização de assertivas no processo de verificação de hardware,<br>
e tais assertivas foram adaptadas para um modelo proposto neste trabalho.<br>
3.2.5 Incorporating efficient assertion checkers into hardware emulation<br>
No trabalho de BOULE; ZILIC é apresentado uma ferramenta de geração de assertivas<br>
no contexto da emulação de circuitos, de modo que estas assertivas descrita em PSL possam<br>
transformadas para o modelo de linguagem de descrição de hardware. Inicialmente é realizada<br>
toda análise de cada assertiva e a mesma é traduzida em partes, levando em consideração os<br>
operadores e cada estrutura, por exemplo if-else, utilizado na declaração da assertiva.<br>
Apresentar um exemplo para explicar o texto acima<br>
trabalho de BOULE; ZILIC consolida e apresenta aspectos importantes, tais como a<br>
utilização de uma ferramenta para geração de assertivas, o que torna-se no contexto deste projeto,<br>
extremamente importante, visto que o modelo adotado atualmente consiste tanto na geração<br>
automática das assertivas, bem como a inserção manual por parte do usuário.<br>
40<br>
4 MÉTODO PROPOSTO<br>
Este Capítulo descreve o método proposto neste trabalho, baseado transformações de<br>
código para análise de circuitos lógicos descritos em VHDL utilizando Bounded Model Checking,<br>
neste caso o model checker ESBMC.<br>
4.1 Visão geral do método<br>
O método proposto consiste inicialmente em receber como entrada um circuito lógico<br>
descrito em VHDL, onde uma dada propriedade representada em uma assertiva será analisada,<br>
as assertivas serão inseridas de automaticamente pelo método ou pelo próprio usuário do método.<br>
O código VHDL analisado posteriomente é traduzido para linguagem C e recebe uma instrumen-<br>
tação de código (com funções especificas suportadas pelo método) para a posterior validação do<br>
mesmo. O Código em C automaticamente gerado, já instrumentado, será processado e analisado<br>
pelo ESBMC de acordo com as assertivas inseridas e ao final é apresentado o resultado. Caso<br>
alguma das assertivas seja violada, um contra-exemplo é apresentado ao usuário. Uma visão<br>
geral do método proposto é apresentado na Figura 16 e nas sessões a seguir serão apresentados<br>
cada etapa do método proposto neste trabalho.<br>
Figure 16 – Ciclo da ferramenta<br>
Fonte: Própria<br>
Com o intuito de auxiliar nas explicações apresentadas nas próximas sessões, o código<br>
na Figura 17 será utilizado nas explanações, bem como será apresentado todas as alterações do<br>
mesmo, conforme cada etapa do método.<br>
Chapter 4. MÉTODO PROPOSTO 41<br>
Figure 17 – Exemplo de código VHDL de ULA com portas AND, OR e XOR.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3<br>
4 ENTITY U l a _ t c c IS<br>
5 PORT(A, B , B i n v e r t i d o , Op1 , Op2 : IN BIT ;<br>
6 R e s u l t a d o :OUT BIT ) ;<br>
7 END U l a _ t c c ;<br>
8<br>
9 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
10 SIGNAL a n d _ p o r t : b i t ;<br>
11 SIGNAL o r _ p o r t : b i t ;<br>
12 SIGNAL x o r _ p o r t : b i t ;<br>
13 SIGNAL mux2x1 : b i t ;<br>
14 BEGIN<br>
15 PROCESS(A, B , B i n v e r t i d o , Op1 )<br>
16 BEGIN<br>
17 ??PORTA AND<br>
18 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
19 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
20 ELSE<br>
21 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
22 END IF ;<br>
23 ??PORTA OR<br>
24 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
25 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
26 ELSE<br>
27 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
28 END IF ;<br>
29 ??PORTA XOR<br>
30 IF (A = ’ 0 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
31 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
32 ELSIF (A = ’ 1 ’ and mux2x1 = ’ 1 ’ ) THEN<br>
33 x o r _ p o r t &lt;= ’ 0 ’ ;<br>
34 ELSE<br>
35 x o r _ p o r t &lt;= ’ 1 ’ ;<br>
36 END IF ;<br>
37 ??INVERSOR<br>
38 IF ( B i n v e r t i d o = ’ 0 ’ ) THEN<br>
39 mux2x1 &lt;= B ;<br>
40 ELSE<br>
41 mux2x1 &lt;= NOT B ;<br>
42 END IF ;<br>
43 ??MUX4X1<br>
44 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
45 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
46 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
47 R e s u l t a d o &lt;= o r _ p o r t ;<br>
48 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
49 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
50 END IF ;<br>
51 END PROCESS ;<br>
52 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 42<br>
4.2 Preprocessamento do VHDL e inserção de assertivas<br>
A fase inicial do método consiste no preprocessamento do código VHDL com as an-<br>
otações de código pelo usuário ou pelo método proposto de forma automática, incluindo as<br>
assertivas, conforme a Figura 16, na etapa A. O método não realiza qualquer tipo de verificação<br>
sobre o código VHDL, apenas utiliza o mesmo como entrada juntamente com as assertivas<br>
inseridas. Toda verificação é realizada sobre o código em linguagem C, que será traduzido a<br>
partir do código VHDL analisado, nas próximas etapas do método proposto. Vale ressaltar que<br>
mesmo a linguagem VHDL tendo um modelo de assertivas padrão, para o método tornou-se<br>
necessário a criação de um modelo (baseado em comentários) para que as funções do model<br>
checker adotado fossem suportadas, como a geração de valores não deterministicos.<br>
As assertivas manuais são adicionadas entre as tags @c2vhdl:ASSERT e @c2vhdl:END<br>
e todo trecho de código entre estas tags deve estar comentado, desta forma não apresentará<br>
erro na tradução do código em linguagem C, bem como na sintetização do código VHDL. Nas<br>
assertivas são incluidas as funções necessárias para a análise utilizando a ferramenta ESBMC. A<br>
assertiva apresenta três informações principais, sendo elas: condição, mensagem e gravidade.<br>
Ajustar está assertiva. Para quem não vê o código todo, ela não faz sentido<br>
Figure 18 – Exemplo de assertiva para verificação de porta XOR.<br>
1 ??@c2vhdl : ASSERT<br>
2 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ )<br>
3 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 "<br>
4 ??s e v e r i t y ERROR;<br>
5 ??@c2vhdl :END<br>
Fonte: Própria.<br>
A condição (na linha 2 da Figura 19) representa a assertiva propriamente dita e que será<br>
analisado pela aplicação. A condição será precedida de??assert e seguido ou não da palavra<br>
not, com isso a assertiva pode assumir valor negativo, conforme necessidade do usuário. Na<br>
Figura 19 a assertiva busca verificar se a variavél Resultado terá valor igual a 1. Qual a<br>
razão<br>
para<br>
isso,<br>
ex-<br>
plique!<br>
A mensagem (??report na linha 3 da Figura 19) é definida pelo usuário e será<br>
apresentado caso a assertiva apresente falha, assim a mensagem pode ser utilizada como um meio<br>
de depuração das propriedades validadas. A severidade (severity na linha 4 da Figura 19)<br>
pode ser definida como error, que representa um erro fatal e parada da verificação. A severidade<br>
do tipo warning que representa um erro não fatal, contabiliza as falhas das assertivas, porém<br>
não causa a parada da verificação. As mensagens futuramente pode ser integradas um framework<br>
para teste de unidade, contudo está é uma etapa ainda em planejamento neste trabalho.<br>
Juntamente com as assertivas outra função que pode ser utilizada é a função __ESBMC<br>
Chapter 4. MÉTODO PROPOSTO 43<br>
_assume() suportada pelo model checker ESBMC. Esta função utilizada em conjuto com a<br>
ferramenta ESBMC permite que durante a verificação uma variavél possa ter uma valor setado<br>
durante o tempo de execução da verificação. A importância desta função é fazer verificações onde<br>
se conhece os valores de entrada juntamente com o valor resultante, por exemplo, na verificação<br>
de portas lógicas.<br>
Figure 19 – Exemplo de utilização da função __ESBMC_assume().<br>
1 ??__ESBMC_assume (A = ’ 1 ’ )<br>
2 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
Fonte: Própria.<br>
A assertivas que serão verificadas são automáticas traduzidas a partir das entradas do<br>
código VHDL. Seja no modelo manual (assertivas escritas pelo usuário) ou automático (inferidas<br>
pelo método proposto por meio de análise estática), as entradas são mapeadas para serem<br>
utilizados na etapa de instrumentação. Desta forma, tais entradas podem ser utilizadas para gerar<br>
essas assertivas e então serem adicionadas diretamente ao código em linguagem C durante a fase<br>
de instrumentação.<br>
A Figura 20 apresenta o código juntamente com as assertivas conforme o padrão salien-<br>
tado na section 4.2. Neste exemplo foi implementado utilizado a inserção manual das assertivas<br>
e também da função __ESBMC_assume(), entretanto o objetivo é automatizar estas funções<br>
durante a execução da ferramenta.<br>
4.3 Tradução de código VHDL para a linguagem C<br>
Nesta etapa a tradução do código VHDL para linguagem C é executada, conforme<br>
apresentado na Figura 16, etapa B. A partir deste ponto, a ferramenta é executada de maneira<br>
propriamente dita, tendo todo o processo automatizado até a apresentação do resultado. Para<br>
esta etapa do método foi selecionado a ferramenta V2Cque realiza a tradução de VHDL para Adicionar<br>
refer-<br>
ência<br>
Linguagem C.<br>
A ferramenta V2C apresenta diversas vantagens em relação a equivalência de tradução<br>
de linguagens, contudo V2C apresenta certas limitação na tradução do código VHDL, em outras<br>
palavras, a mesma não reconhece algumas estruturas especificas do VHDL. A ferramenta aceita<br>
apenas entradas e saídas do tipo: bit, std_ulogic, qsim_state, std_ulogic_vector<br>
e interger. Na parte de arquitetura, a ferramenta aceita uma gama maior de estruturas, tra-<br>
balhando com expressoões do tipo: signal, variable, integers, strings e caracteres.<br>
Em expreções condicionais os operandos são AND, OR, NOT &lt;=, =&gt;,=,&lt;,&gt; e &lt;&gt;. Aceita<br>
também a estrutura de process, além da estutura block. A estrutura process é limitada<br>
Chapter 4. MÉTODO PROPOSTO 44<br>
Figure 20 – Código da Figura 17 com a assertiva da Figura 19.<br>
1 l i b r a r y i e e e ;<br>
2 use i e e e . s t d _ l o g i c _ 1 1 6 4 . a l l ;<br>
3 . . .<br>
4 ARCHITECTURE U l a _ t c c _ b e h a v l OF U l a _ t c c IS<br>
5 SIGNAL a n d _ p o r t : b i t ;<br>
6 SIGNAL o r _ p o r t : b i t ;<br>
7 SIGNAL x o r _ p o r t : b i t ;<br>
8 SIGNAL mux2x1 : b i t ;<br>
9 BEGIN<br>
10 PROCESS(A, B , B i n v e r t i d o , Op1 ) IS<br>
11 BEGIN<br>
12 ??PORTA AND<br>
13 IF (A = ’ 1 ’ and mux2x1 = ’ 0 ’ ) THEN<br>
14 ??__ESBMC_assume (A = ’ 1 ’ )<br>
15 ??__ESBMC_assume ( mux2x1 = ’ 0 ’ ) ;<br>
16 a n d _ p o r t &lt;= ’ 1 ’ ;<br>
17 ELSE<br>
18 a n d _ p o r t &lt;= ’ 0 ’ ;<br>
19 END IF ;<br>
20 . . .<br>
21 ??MUX4X1<br>
22 IF ( Op1 = ’ 0 ’ and Op2 = ’ 0 ’ ) THEN<br>
23 R e s u l t a d o &lt;= a n d _ p o r t ;<br>
24 ELSIF ( Op1 = ’ 0 ’ and Op2 = ’ 1 ’ ) THEN<br>
25 R e s u l t a d o &lt;= o r _ p o r t ;<br>
26 ELSIF ( Op1 = ’ 1 ’ and Op2 = ’ 0 ’ ) THEN<br>
27 R e s u l t a d o &lt;= x o r _ p o r t ;<br>
28 ??@c2vhdl : ASSERT<br>
29 ??a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
30 ?? r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
31 ??s e v e r i t y ERROR;<br>
32 ??@c2vhdl :END<br>
33 END IF ;<br>
34 END PROCESS ;<br>
35 END U l a _ t c c _ b e h a v l ;<br>
Fonte: Própria.<br>
apenas a: if-else, case e loops. Como trabalho futuro, neste trabalho tem-se buscado<br>
novas abordagens para ampliar o suporte a estruturas não suportadas pelo V2C.<br>
Na tradução é necessário substituir os operadores originais por seus equivalentes em<br>
linguagem C. A excessão são os operadore específicos que gerenciam os valores de bit, tais<br>
como concatenação ou manipulação de partes vertoriais, para os quais são necessários construir<br>
procedimentos especificos em C.<br>
Conforme mostrado na Figura 21, na tradução são gerados vários vetores para suporte<br>
a tradução dos sinais representados no VHDL, sendo eles chg[], old[] e new[]. O vetor<br>
old[] contém o valor do sinais do passo anteriore a partir deste vetor o valor a ser usado nos Confuso<br>
issocálculo é obtido. O vetor new[] representa os novos valores a serem calculados pelos antigose<br>
Qual?<br>
Chapter 4. MÉTODO PROPOSTO 45<br>
o vetor chg[] contém um or exclusivo entre o valor novo e antigo e em caso de alteração entre<br>
os valores é copiado o valor de new[] para old[].<br>
O texto acima está muito confuso, corrigi rapidamente<br>
No código C gerado, os vetores in_data[] e out_data[] contêm os sinais de<br>
entrada e saída, respectivamente. No caso de circuitos sequênciais, o valor do status é inserido<br>
no primeiro (índice 0). A funçãoentão lerá os valores in_data[] e escreverá os resultados do qual?<br>
processamento em out_data[]. Ao final da operações os valores de estado são passado para<br>
out_data[].<br>
Conforme especificado e seguindo os parametros da ferramenta, a mesma realiza a<br>
tradução, mantendo inalterado qualquer fragmento de código que esteja comentado, neste caso,<br>
as assertivas presentes no código VHDL permanecem inalteradas, sendo utilizadas na próxima<br>
etapa do método proposto.<br>
4.4 Instrumentação de código<br>
As assertivas após a tradução permanecem comentadas, sendo necessário prepara-lás, ou<br>
seja traduzi-las, para verificação posterior do código na linguagem em C. Com isso é necessário<br>
uma instrumentação do código para prover suporte as assertivas traduzidas para análise, conforme<br>
apresentado na Figura 16, etapa C.<br>
Todas as etapas da instrumentação são realizados sobre o código C já traduzido. O passo<br>
inicial da instrumentação é a adição da macros no inicio do código C com as definição das<br>
assertivas a serem utilizadas. Na Figura 22 são apresentados os macros utilizadas no código C. A<br>
Linha 1 da figura corresponde a mensagem de erro a ser apresentada e a Linha 2 corresponde<br>
ao modelo da assertiva e a chamanda da macro definida na Linha 1 em caso de falha. Estas<br>
definições para as assertivas também podem ser utilizadas no código C traduzidos sem o uso do<br>
ESBMC.<br>
Figure 22 – Macros das assertivas implementadas em linguagem C<br>
1 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r ,M, __FILE__ , __LINE__ , # # __VA_ARGS__ )<br>
2 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
Fonte: Própria.<br>
O passo seguinte é a identificação das assertivas comentadas ao longo do corpo do<br>
código traduzido, utilizando o exemplo da Figura 23. As assertivas são identificadas através<br>
das tags @c2vhdl:ASSERT e @c2vhdl:END e a busca é realizado através destas tags. Ao<br>
ser encontrado a tag @c2vhdl:ASSERT, é realizado um loop até que seja encontrada a tag<br>
Chapter 4. MÉTODO PROPOSTO 46<br>
@c2vhdl:END e com isso toda a assertiva inserida possa ser passada a função de busca das<br>
informações da assertiva contidas entre as tags apresentadas.<br>
Com os dados das assertivas obtidos é realizado a busca da condição, mensagem e<br>
severidade através dos comandos ??assert, ??report e ??severity respectivamente.<br>
Estas informações são encontradas através do uso e uma Regex no código e que são adicionadas<br>
ao código C seguindo o modelo definido na macro. Este processo é repetido até outra assertiva<br>
ser encontrada ou caso chegue ao fina do código C.<br>
Com a função __ESBMC_assume() ocorre processo semelhante ao das assertivas.<br>
Utilizando novamente uma regex que realiza a busca por esta função no código e é retirado o<br>
comentário da mesma, desta forma a mesma passa a esta acessivél para o ESBMC, visto que a<br>
declaração da mesma já segue o modelo padrão a ser utilizado pelo ESBMC.<br>
Durante a instrumentação de código também é realizado a entrada de sinais não de-<br>
terministicos para variaveis não inicializadas ou argumentos de funções do código C gerado<br>
da tradução, utilizando a função __VERIFIER_nondet_int(). Esta função é utilizada em<br>
todas as variaveis de entrada e também nos sinais criados ao longo da arquitetura. Desta forma,<br>
todas as variavéis necessárias são inicializadas para verificação.<br>
Explicar o funcionamento do nondet com o ESBMC<br>
Em outras palavras, na instrumentação de código é realizado a traduçao das assertivas do<br>
modelo utilizado no código VHDL para para o modelo utilizado em linguagem C, além como de<br>
outras funções que possam ser utilizados pelo VHDL. Ao final da instrumentação o código C<br>
fica disponivel para que possa ser dado como entrada para outras ferramentas de verificação de<br>
código e não apenas o ESBMC.<br>
4.5 Verificação de assertivas usando Model Checker<br>
O model checker adotado no desenvolvimento de método é o ESBMCna versão 3.0.0 referência<br>
e conforme explicado na subsection 2.2.3, esta ferramenta recebe como entrada um código C<br>
ou C++ e devido a isso foi escolhida neste projeto. Nesta seção será apresentado a etapa D do apresentar<br>
outras<br>
vanta-<br>
gens<br>
métod proposto na Figura 16.<br>
Para a verificação, a primeira etapa é a identificação das assertivas no código C analisado,<br>
para isso é utilizado uma opção do ESBMC (??show-claims), mais especificamente as<br>
assertivas instrumentadas no código C analisado. Cada assertiva é identificada através de uma<br>
numeração de acordo com a ordem de busca do código analisado. Cada assertiva encontrada é<br>
armazenada para que seja realizada uma análise individual de cada claim, ou seja, assertiva.<br>
Chapter 4. MÉTODO PROPOSTO 47<br>
Figure 24 – Código apresentando a função de busca das clains com assertivas.<br>
1 VAR<br>
2 c o n t a d o r : i n t e i r o<br>
3 c l a i m : l i s t a<br>
4 c l a i m _ s t r i n g : s t r i n g<br>
5<br>
6 FUNCAO c a l l _ e s b m c : a r q u i v o<br>
7 c o n t a d o r &lt;?0<br>
8 INICIO<br>
9 s a i d a &lt;?f un ca o de g e r a c a o das c l a i m s p e l o ESBMC<br>
10 ENQUANTO c o n t a d o r &lt; s a i d a FACA<br>
11 c o n t a d o r +=2<br>
12 r e g e x p a r a p r o c u r a r c l a i m e numeracao da c l a i m<br>
13 SE e n c o n t r a r c l a i m ENTAO<br>
14 r e g e x p a r a p r o c u r a r a p a l a v r a " a s s e r t i o n "<br>
15 SE e n c o n t r a r a p a l a v r a " a s s e r t i o n " ENTAO<br>
16 c o n t a d o r +=1<br>
17 A d i c i o n a a numeracao da c l a i m na l i s t a<br>
18 FIM?SE<br>
19 FIM?SE<br>
20 FIM?ENQUANTO<br>
21 FIM?FUNCAO<br>
Fonte: Própria.<br>
Na Linha 9 da Figura 24 é apresentado a chamada da ferramenta ESBMC que ocorre e<br>
através da opção ??show-claims lista todas as claims presentes no texto, como apresentado<br>
na Figura 25. Como o ESBMC infere de forma automatica assertivas a serem verificadas no<br>
código. Visando isolar somente as assertivas instrumentadas pelo método proposto, juntamente<br>
com a opção –show-claims é utilizado as opções:<br>
• ??no-pointer-check: para não realizar a checagem de ponteiros no código;<br>
• ??no-div-by-zero-check: para não realizar a checagem de divisões por zero no<br>
código; e<br>
• ??no-bounds-check: para não realizar a checagem de array bounds no código.<br>
Chapter 4. MÉTODO PROPOSTO 48<br>
Figure 25 – Imagem de claims contendo assertivas.<br>
Fonte:Própria<br>
Após a listagem das claims com assertivas ser gerada, outra função, indicada na Figura 26,<br>
é chamada para verificação de cada claim individualmente. Para cada claim, ocorre a chamada do<br>
ESBMC, utilizando as opções ??no-pointer-check, ??no-div-by-zero-check e<br>
??no-bounds-check, juntamente com a opção ??unwind em que realiza o número de<br>
desdobramentos dos laços no código analisado.<br>
Contudo, dependendo da complexidade da assertiva, faz-se necessário aumentar o número<br>
de desdobramentos que, por padrão são dez, conforme análise experimentais. A função é chamada<br>
na Linha 11 da Figura 26 e após a analise da claim é realizado a busca do resultado e exibição<br>
caso seja uma propriedade violada.<br>
Desta forma o ESBMC realiza apenas a checagem necessária dentro da assertiva, evitando<br>
que outros parâmetros sejam verificados, sem a devida necessidade do mesmo. Ao final de todos<br>
os desdobramentos é apresentado o resultado, apresentado na Figura 27, sendo positiva (sem<br>
erros) ou negativa (com violação de propriedades), dependendo da assertiva e do código analisado.<br>
Este processo se repete até a lista de assertivas ser finalizada.<br>
Chapter 4. MÉTODO PROPOSTO 49<br>
Figure 26 – Pseudocódigo da função de análise das claims.<br>
1 VAR<br>
2 c o n t a d o r 1 : i n t e i r o<br>
3 c o n t a d o r 2 : i n t e i r o<br>
4 r e s u l t a d o : l i s t a<br>
5<br>
6 FUNCAO esbmc_c la ims : l i s t a , a r q u i v o<br>
7 c o n t a d o r 1 &lt;?0<br>
8 c o n t a d o r 2 &lt;?0<br>
9 busca p e l o nome da fu nc a o no a r q u i v o<br>
10 ENQUANTO c o n t a d o r &lt; l i s t a FACA<br>
11 s a i d a &lt;?Execu ta comando de a n a l i s e da c l a i m<br>
numerada na l i s t a<br>
12 ENQUANTO c o n t a d o r 2 &lt; s a i d a<br>
13 Regex busca se a p r o p r i e d a d e f o i v i o l a d a<br>
14 SE p r o p r i e d a d e f o i v i o l a d a ENTAO<br>
15 Pu la p a r a l i n h a da v i o l a ç ã o<br>
16 A d i c i o n a o e r r o ao r e s u l t a d o<br>
17 FIM?SE<br>
18 FIM?ENQUANTO<br>
19 FIM?ENQUANTO<br>
20 FIM?FUNCAO<br>
Fonte: Própria.<br>
Figure 27 – Imagem de apresentação do resultado da ferramenta.<br>
Fonte:Própria<br>
Ajustar os códigos, alguns estao muito grandes e com trechos desnecessário, não foi<br>
citado o link do repo da ferramenta<br>
Chapter 4. MÉTODO PROPOSTO 50<br>
Figure 21 – Código da Figura 17 traduzido pela ferramenta V2C.<br>
1 void u l a _ t c c ( i n t i n _ d a t a [ ] , i n t o u t _ d a t a [ ] )<br>
2 {<br>
3 i n t _ i _ =0;<br>
4 i n t _c on t_ ;<br>
5 enum s e g n a l e {A, B , B i n v e r t i d o , Op1 , Op2 , R e s u l t a d o , and_po r t , o r _ p o r t ,<br>
6 x o r _ p o r t , mux2x1 , _MAX_} ;<br>
7 i n t o l d [_MAX_ ] ;<br>
8 i n t new [_MAX_ ] ;<br>
9 i n t chg [_MAX_ ] ;<br>
10 new [A] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
11 new [B] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
12 new [ B i n v e r t i d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
13 new [ Op1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
14 new [ Op2 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
15 new [ R e s u l t a d o ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
16 new [ a n d _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
17 new [ o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
18 new [ x o r _ p o r t ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
19 new [ mux2x1 ] = ( i n _ d a t a [0] &gt; &gt; _ i _ ) & 0X01 ; _ i _ +=1;<br>
20<br>
21 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
22 {<br>
23 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
24 }<br>
25 new [A] = i n _ d a t a [ 1 ] ;<br>
26 new [B] = i n _ d a t a [ 2 ] ;<br>
27 new [ B i n v e r t i d o ] = i n _ d a t a [ 3 ] ;<br>
28 new [ Op1 ] = i n _ d a t a [ 4 ] ;<br>
29 new [ Op2 ] = i n _ d a t a [ 5 ] ;<br>
30<br>
31 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
32 {<br>
33 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
34 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
35 }<br>
36<br>
37 do {<br>
38 _ co n t _ =0;<br>
39 /? S t a r t o f T r a n s l a t i o n ? /<br>
40<br>
41 /? p0 : ? /<br>
42 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
43 /?PORTA AND ? /<br>
44 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
45 \ \ __ESBMC_assume ( o l d [A] = 1) ;<br>
46 \ \ __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
47 new [ a n d _ p o r t ] = 1 ;<br>
48 }<br>
49 e l s e {<br>
50 new [ a n d _ p o r t ] = 0 ;<br>
51 }<br>
52 /?PORTA OR ? /<br>
53 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
54 new [ a n d _ p o r t ] = 0 ;<br>
55 }<br>
56 e l s e {<br>
57 new [ a n d _ p o r t ] = 1 ;<br>
58 }<br>
59 /?PORTA XOR ? /<br>
60 i f ( ( o l d [A]==0 && o l d [ mux2x1 ]==0) ) {<br>
61 new [ x o r _ p o r t ] = 0 ;<br>
62 }<br>
63 e l s e i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==1) ) {<br>
64 new [ x o r _ p o r t ] = 0 ;<br>
65 }<br>
66 e l s e {<br>
67 new [ x o r _ p o r t ] = 1 ;<br>
68 }<br>
69 /? INVERSOR ? /<br>
70 i f ( ( o l d [ B i n v e r t i d o ]==0) ) {<br>
71 i f ( chg [B ] ) {<br>
72 new [ mux2x1 ]= o l d [B ] ;<br>
73 }<br>
74 }<br>
75 e l s e {<br>
76 i f ( chg [B ] ) {<br>
77 new [ mux2x1 ]=~ o l d [B ] ;<br>
78 }<br>
79 }<br>
80 /?MUX4X1 ? /<br>
81 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
82 i f ( chg [ a n d _ p o r t ] ) {<br>
83 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
84 \ \ @c2vhdl : ASSERT<br>
85 \ \ a s s e r t ( R e s u l t a d o = ’ 1 ’ ) ;<br>
86 \ \ r e p o r t "O r e s u t a d o f o i d i f e r e n t e de 0 " ;<br>
87 \ \ s e v e r i t y ERROR;<br>
88 \ \ @c2vhdl :END<br>
89 }<br>
90 }<br>
91 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
92 i f ( chg [ o r _ p o r t ] ) {<br>
93 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
94 }<br>
95 }<br>
96 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
97 i f ( chg [ x o r _ p o r t ] ) {<br>
98 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
99 }<br>
100 }<br>
101 }<br>
102<br>
103 /? End o f T r a n s l a t i o n ? /<br>
104 f o r ( _ i _ =0; _i_ &lt;_MAX_; _ i _ ++)<br>
105 {<br>
106 i f ( new [ _ i _ ] ! = o l d [ _ i _ ] ) _ con t_ =1;<br>
107 chg [ _ i _ ]= o l d [ _ i _ ] ^ new [ _ i _ ] ;<br>
108 o l d [ _ i _ ]= new [ _ i _ ] ;<br>
109 }<br>
110 } whi le ( _c on t_ ) ;<br>
111<br>
112 new [A] &= 0X01 ;<br>
113 new [B] &= 0X01 ;<br>
114 new [ B i n v e r t i d o ] &= 0X01 ;<br>
115 new [ Op1 ] &= 0X01 ;<br>
116 new [ Op2 ] &= 0X01 ;<br>
117 new [ R e s u l t a d o ] &= 0X01 ;<br>
118 new [ a n d _ p o r t ] &= 0X01 ;<br>
119 new [ o r _ p o r t ] &= 0X01 ;<br>
120 new [ x o r _ p o r t ] &= 0X01 ;<br>
121 new [ mux2x1 ] &= 0X01 ;<br>
122<br>
123 o u t _ d a t a [ 0 ] = 0 ; _ i _ =0;<br>
124 o u t _ d a t a [ 0 ] | = new [A] &lt;&lt; _ i _ ; _ i _ +=1;<br>
125 o u t _ d a t a [ 0 ] | = new [B] &lt;&lt; _ i _ ; _ i _ +=1;<br>
126 o u t _ d a t a [ 0 ] | = new [ B i n v e r t i d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
127 o u t _ d a t a [ 0 ] | = new [ Op1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
128 o u t _ d a t a [ 0 ] | = new [ Op2 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
129 o u t _ d a t a [ 0 ] | = new [ R e s u l t a d o ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
130 o u t _ d a t a [ 0 ] | = new [ a n d _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
131 o u t _ d a t a [ 0 ] | = new [ o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
132 o u t _ d a t a [ 0 ] | = new [ x o r _ p o r t ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
133 o u t _ d a t a [ 0 ] | = new [ mux2x1 ] &lt;&lt; _ i _ ; _ i _ +=1;<br>
134<br>
135 o u t _ d a t a [ 1 ] = new [ R e s u l t a d o ] ;<br>
136 }<br>
Fonte: Própria.<br>
Chapter 4. MÉTODO PROPOSTO 51<br>
Figure 23 – Código com assertivas traduzida para linguagem C<br>
1 # inc lude &lt; s t d i o . h&gt;<br>
2 # d e f i n e l o g _ e r r o r (M, . . . ) f p r i n t f ( s t d e r r , M , __FILE__ , __LINE__ , ##<br>
__VA_ARGS__ ) / / Update t o p r i n t t h e t r a c e<br>
3 # d e f i n e __MY_asser t (A, M, . . . ) i f ( ! ( A) ) { l o g _ e r r o r (M, ##__VA_ARGS__ ) ;<br>
a s s e r t (A) ; }<br>
4<br>
5 . . .<br>
6<br>
7 do {<br>
8 _co n t _ =0;<br>
9 /? S t a r t o f T r a n s l a t i o n ? /<br>
10 chg [A] = __VERIFIER_nondet_int ( ) ;<br>
11 chg [B] = __VERIFIER_nondet_int ( ) ;<br>
12 chg [ B i n v e r t i d o ] = __VERIFIER_nondet_int ( ) ;<br>
13 chg [ Op1 ] = __VERIFIER_nondet_int ( ) ;<br>
14 chg [ a n d _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
15 chg [ R e s u l t a d o ] = __VERIFIER_nondet_int ( ) ;<br>
16 chg [ o r _ p o r t ] = __VERIFIER_nondet_int ( ) ;<br>
17 chg [ mux2x1 ] = __VERIFIER_nondet_int ( ) ;<br>
18<br>
19 /? p0 : ? /<br>
20 i f ( chg [A] | | chg [B] | | chg [ B i n v e r t i d o ] | | chg [ Op1 ] ) {<br>
21 /?PORTA AND ? /<br>
22 i f ( ( o l d [A]==1 && o l d [ mux2x1 ]==0) ) {<br>
23 __ESBMC_assume ( o l d [A] = 1) ;<br>
24 __ESBMC_assume ( o l d [ mux2x1 ] = 0) ;<br>
25 new [ a n d _ p o r t ] = 1 ;<br>
26 }<br>
27 e l s e {<br>
28 new [ a n d _ p o r t ] = 0 ;<br>
29 }<br>
30<br>
31 . . .<br>
32<br>
33 /?MUX4X1 ? /<br>
34 i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==0) ) {<br>
35 i f ( chg [ a n d _ p o r t ] ) {<br>
36 new [ R e s u l t a d o ]= o l d [ a n d _ p o r t ] ;<br>
37 __MY_asser t ( new [ R e s u l t a d o ] == 1 , "O r e s u l t a d o é d i f e r e n t e de 0 " ) ;<br>
38 }<br>
39 e l s e i f ( ( o l d [ Op1]==0 && o l d [ Op2 ]==1) ) {<br>
40 i f ( chg [ o r _ p o r t ] ) {<br>
41 new [ R e s u l t a d o ]= o l d [ o r _ p o r t ] ;<br>
42 }<br>
43 }<br>
44 e l s e i f ( ( o l d [ Op1]==1 && o l d [ Op2 ]==0) ) {<br>
45 i f ( chg [ x o r _ p o r t ] ) {<br>
46 new [ R e s u l t a d o ]= o l d [ x o r _ p o r t ] ;<br>
47 }<br>
48 }<br>
49 }<br>
50<br>
51 /? End o f T r a n s l a t i o n ? /<br>
52 . . .<br>
Fonte: Própria.<br>
52<br>
5 CRONOGRAMA<br>
53<br>
6 CONSIDERAÇÕES PARCIAIS E<br>
TRABALHOS FUTUROS<br>
O trabalho aborda o desenvolvimento de um método para análise de circuitos lógicos de-<br>
scrito em VHDL através da aplicação de técnica de transformação de código e a técnica Bounded<br>
Model Cheking. Este método tem como objetivo de explorar os estados alcanç alcançáveis no<br>
circuito, e dessa forma identificar erros que possam resutar em mal funcionamento do sistema.<br>
Entre as dificuldade encontradas, a principal esta ligada a etapa de tradução de código.<br>
Devido a ferramenta utilizada inicialmente conter diversas limitações, a mesma diminui a eficácia<br>
da ferramenta, pois a quantidade de estruturas que podem ser utilizadas é limitada e com isso<br>
limitando também o processo de criação de protótipos.<br>
Os trabalhos futuros é necessário buscar uma nova ferramenta ou método de tradução<br>
que tenha uma gama maior de tradução, seja em estruturas ou palavras reservadas,deste forma<br>
o método desenvlvido torna-se mais eficiente e gerando uma menor intervenção do usuário no<br>
código VHDL. A melhoria na tradução de código também beneficia ageração das assertivas<br>
automáticamente, pois com uma gama maior de estruturas suportadas, mais assertivas podem ser<br>
geradas.<br>
Além disso a geração automática das assertivas é Outro ponto abordado, já sitado anterior-<br>
mente, é a geração automática das assertivas, visto que na estapa atual ainda nõ foi implementado.<br>
Este recuros visa da liberdade ao desenvolvedor promovendo de maneira automática os teste<br>
sobre o código, não necessitando que uma intervenção, tornando a inserção manual apenas em<br>
casos especificos de testes.<br>
54<br>
BIBLIOGRAPHY<br>
ABE, J. Introducao a Logica Para a Ciencia Da Computacao. Arte & Ciência, 2002. ISBN<br>
9788574730455. Disponível em: &lt;https://books.google.com.br/books?id=AgBJdjoNPwUC&gt;.<br>
ACM. 2018. Acessado em: 01 de março de 2018. Disponível em: &lt;http://dl.acm.org/&gt;.<br>
AHO, A. V.; SETHI, R.; ULLMAN, J. D. Compilers: principles, techniques, and tools. [S.l.]:<br>
Addison-wesley Reading, 2007. v. 2.<br>
ALLEN, F. E. Control flow analysis. In: ACM. ACM Sigplan Notices. [S.l.], 1970. v. 5, n. 7, p.<br>
1–19.<br>
BAIER, C.; KATOEN, J.-P.; LARSEN, K. G. Principles of model checking. [S.l.]: MIT press,<br>
2008.<br>
BARA, A. et al. Formal verification of timed vhdl programs. In: IET. FDL. [S.l.], 2010. p.<br>
80–85.<br>
BASILI, V. R.; CALDIERA, G.; ROMBACH, H. D. Experience factory. Encyclopedia of<br>
software engineering, Wiley Online Library, 1994.<br>
BENSALEM, S.; LAKHNECH, Y. Automatic generation of invariants. Formal Methods in<br>
System Design, Springer, v. 15, n. 1, p. 75–92, 1999.<br>
BIERE, A. The aiger and-inverter graph (aig) format. Available at http://fmv.jku.at/aiger, 2016.<br>
BIOLCHINI, J. et al. Systematic review in software engineering. System Engineering and<br>
Computer Science Department COPPE/UFRJ, Technical Report ES, v. 679, n. 05, p. 45, 2005.<br>
BOULE, M.; ZILIC, Z. Incorporating efficient assertion checkers into hardware emulation. In:<br>
IEEE. Computer Design: VLSI in Computers and Processors, 2005. ICCD 2005. Proceedings.<br>
2005 IEEE International Conference on. [S.l.], 2005. p. 221–228.<br>
BOULE, M.; ZILIC, Z. Efficient automata-based assertion-checker synthesis of seres for<br>
hardware emulation. In: IEEE COMPUTER SOCIETY. Proceedings of the 2007 Asia and South<br>
Pacific Design Automation Conference. [S.l.], 2007. p. 324–329.<br>
BRAYTON, R.; MISHCHENKO, A. Abc: An academic industrial-strength verification tool. In:<br>
SPRINGER. Computer Aided Verification. [S.l.], 2010. p. 24–40.<br>
B.V. 2018. Acessado em 1 de março de 2018. Disponível em: &lt;http://www.sciencedirect.com/&gt;.<br>
CABODI, G. et al. Hardware model checking competition 2014: an analysis and comparison of<br>
solvers and benchmarks. Journal on Satisfiability, Boolean Modeling and Computation, v. 9, p.<br>
135–172, 2016.<br>
CAPPELATTI, D. Praticando VHDL. Editora Feevale, 2010. ISBN 9788577171200. Disponível<br>
em: &lt;https://books.google.com.br/books?id=z4\_CYog\_UskC&gt;.<br>
Bibliography 55<br>
CHRISTEN, E.; BAKALAR, K. Vhdl-ams-a hardware description language for analog and<br>
mixed-signal applications. IEEE Transactions on Circuits and Systems II: Analog and Digital<br>
Signal Processing, IEEE, v. 46, n. 10, p. 1263–1272, 1999.<br>
CHU, P. P. RTL hardware design using VHDL: coding for efficiency, portability, and scalability.<br>
[S.l.]: John Wiley & Sons, 2006.<br>
CLARKE, E. et al. Verification of hybrid systems based on counterexample-guided abstraction<br>
refinement. In: SPRINGER. TACAS. [S.l.], 2003. v. 3, p. 192–207.<br>
CLARKE, E. M. The birth of model checking. In: 25 Years of Model Checking. [S.l.]: Springer,<br>
2008. p. 1–26.<br>
CLARKE, E. M.; GRUMBERG, O.; LONG, D. E. Model checking and abstraction. ACM<br>
transactions on Programming Languages and Systems (TOPLAS), ACM, v. 16, n. 5, p.<br>
1512–1542, 1994.<br>
CORDEIRO, L.; FISCHER, B.; MARQUES-SILVA, J. Smt-based bounded model checking for<br>
embedded ansi-c software. IEEE Transactions on Software Engineering, IEEE, v. 38, n. 4, p.<br>
957–974, 2012.<br>
COUSOT, P.; COUSOT, R. A gentle introduction to formal verification of computer systems by<br>
abstract interpretation. [S.l.]: IOS Press, 2010.<br>
DAHAN, A. et al. Combining system level modeling with assertion based verification. In: Sixth<br>
international symposium on quality electronic design (isqed’05). [S.l.: s.n.], 2005. p. 310–315.<br>
ISSN 1948-3287.<br>
D’SILVA, V.; KROENING, D.; WEISSENBACHER, G. A survey of automated techniques<br>
for formal software verification. IEEE Transactions on Computer-Aided Design of Integrated<br>
Circuits and Systems, IEEE, v. 27, n. 7, p. 1165–1178, 2008.<br>
ELSEVIER. 2017. Acessado em: 01 março 2018. Disponível<br>
em: &lt;https://www.elsevier.com/__data/assets/pdf_file/0007/69451/<br>
0597-Scopus-Content-Coverage-Guide-US-LETTER-v4-HI-singles-no-ticks.pdf&gt;.<br>
G1. Acidente foi provocado por falha em circuito eletrônico, diz se-<br>
cretário. 2012. Disponível em: &lt;http://g1.globo.com/sao-paulo/noticia/2012/05/<br>
acidente-foi-provocado-por-falha-em-circuito-eletronico-diz-secretario.html&gt;.<br>
GUGLIELMO, G. D. et al. On the use of assertions for embedded-software dynamic verification.<br>
In: IEEE. Design and Diagnostics of Electronic Circuits & Systems (DDECS), 2012 IEEE 15th<br>
International Symposium on. [S.l.], 2012. p. 330–335.<br>
GUPTA, A. Formal hardware verification methods: A survey. In: SPRINGER. Computer-Aided<br>
Verification. [S.l.], 1992. p. 5–92.<br>
HALDER, A.; VENKATESWARLU, A. A study of petri nets modeling analysis and simulation.<br>
Department of Aerospace Engineering Indian Institute of Technology Kharagpur, India, 2006.<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Interpolation and symbol elimination in vampire.<br>
Automated Reasoning, Springer, p. 188–195, 2010.<br>
Bibliography 56<br>
HODER, K.; KOVÁCS, L.; VORONKOV, A. Case studies on invariant generation using a<br>
saturation theorem prover. Advances in Artificial Intelligence, Springer, p. 1–15, 2011.<br>
IDOETA, I. V.; CAPUANO, F. G. Elementos de eletrônica digital. [S.l.]: Livros Erica, 1982.<br>
IEC/IEEE International Standard - Behavioural languages - Part 1-1: VHDL Language<br>
Reference Manual. IEC 61691-1-1:2011(E) IEEE Std 1076-2008, p. 1–648, May 2011.<br>
IEEE. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http://ieeexplore.ieee.org/<br>
Xplore/home.jsp&gt;.<br>
IEEE Standard for Property Specification Language (PSL). IEEE Std 1850-2010 (Revision of<br>
IEEE Std 1850-2005), p. 1–182, April 2010.<br>
IEEE Standard for Verilog Hardware Description Language. IEEE Std 1364-2005 (Revision of<br>
IEEE Std 1364-2001), p. 1–560, 2006.<br>
KITCHENHAM, B. Procedures for performing systematic reviews. Keele, UK, Keele University,<br>
v. 33, n. 2004, p. 1–26, 2004.<br>
KITCHENHAM, B. et al. Systematic literature reviews in software engineering–a systematic<br>
literature review. Information and software technology, Elsevier, v. 51, n. 1, p. 7–15, 2009.<br>
KNOOP, J.; RÜTHING, O.; STEFFEN, B. Partial dead code elimination. [S.l.]: ACM, 1994.<br>
v. 29.<br>
KOSCIANSKI, A.; SOARES, M. dos S. Qualidade de Software - 2a Edição: Aprenda as<br>
metodologias e técnicas mais modernas para o desenvolvimento de software. Novatec,<br>
2007. ISBN 9788575221129. Disponível em: &lt;https://books.google.com.br/books?id=<br>
O9aWoUq6L88C&gt;.<br>
KROPF, T. Introduction to Formal Hardware Verification. Springer Berlin Heidelberg,<br>
2013. ISBN 9783662038093. Disponível em: &lt;https://books.google.com.br/books?id=<br>
7ImrCAAAQBAJ&gt;.<br>
MAFRA, S. N.; TRAVASSOS, G. H. Estudos primarios e secundarios apoiando a busca por<br>
evidencia em engenharia de software. Relatorio Tecnico, RT-ES, v. 687, n. 06, 2006.<br>
MUKHERJEE, R. et al. Unbounded safety verification for hardware using software analyzers.<br>
In: EDA CONSORTIUM. Proceedings of the 2016 Conference on Design, Automation & Test in<br>
Europe. [S.l.], 2016. p. 1152–1155.<br>
MUKHERJEE, R.; TAUTSCHNIG, M.; KROENING, D. v2c–a verilog to c translator. In:<br>
SPRINGER. International Conference on Tools and Algorithms for the Construction and<br>
Analysis of Systems. [S.l.], 2016. p. 580–586.<br>
MURATA, T. Petri nets: Properties, analysis and applications. Proceedings of the IEEE, IEEE,<br>
v. 77, n. 4, p. 541–580, 1989.<br>
RAMESH, U. B. K.; SENTILLES, S.; CRNKOVIC, I. Energy management in embedded<br>
systems: Towards a taxonomy. In: IEEE PRESS. Proceedings of the First International<br>
Workshop on Green and Sustainable Software. [S.l.], 2012. p. 41–44.<br>
ROCHA, H. et al. Exploiting safety properties in bounded model checking for test cases<br>
generation of c programs. 2010.<br>
Bibliography 57<br>
ROCHA, H. et al. Model checking embedded c software using k-induction and invariants<br>
(extended version). arXiv preprint arXiv:1509.02471, 2015.<br>
ROCHA, H. O. et al. Verificacao de sistemas de software baseada em transformacoes de codigo<br>
usando bounded model checking. Universidade Federal do Amazonas, 2015.<br>
SARGENT, R. G. Verification and validation of simulation models. In: WINTER SIMULATION<br>
CONFERENCE. Proceedings of the 37th conference on Winter simulation. [S.l.], 2005. p.<br>
130–143.<br>
SEGER, C.-J. An introduction to formal hardware verification. [S.l.]: University of British<br>
Columbia, Department of Computer Science, 1992.<br>
SOMMERVILLE, I. Engenharia de software. PEARSON BRASIL, 2011. ISBN 9788579361081.<br>
Disponível em: &lt;https://books.google.com.br/books?id=H4u5ygAACAAJ&gt;.<br>
SONS, J. W. . 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;http:<br>
//onlinelibrary.wiley.com/&gt;.<br>
SOUZA, J. Lógica para Ciência da Computação. Elsevier Brasil, 2017. ISBN 9788535278255.<br>
Disponível em: &lt;https://books.google.com.br/books?id=Ds2sCQAAQBAJ&gt;.<br>
SPRINGER. 2018. Acessado em: 1 de março de 2018. Disponível em: &lt;https:<br>
//link.springer.com/&gt;.<br>
SRIKANT, Y.; SHANKAR, P. The Compiler Design Handbook: Optimizations and<br>
Machine Code Generation. CRC Press, 2002. ISBN 9781420040579. Disponível em:<br>
&lt;https://books.google.com.br/books?id=0K\_jIsgyNpoC&gt;.<br>
THOMAS, D.; MOORBY, P. The Verilog R© Hardware Description Language. Springer<br>
US, 2008. ISBN 9780387853444. Disponível em: &lt;https://books.google.com.br/books?id=<br>
DxQGrz7q-SwC&gt;.<br>
TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L. Sistemas digitais: princípios e aplicações. [S.l.]:<br>
Prentice Hall, 2003. v. 8.<br>
TRAVASSOS, G. H. et al. An environment to support large scale experimentation in software<br>
engineering. In: IEEE. Engineering of Complex Computer Systems, 2008. ICECCS 2008. 13th<br>
IEEE International Conference on. [S.l.], 2008. p</div>
<!-- DIVISOR_DIV_CANDIDATE -->

</div><script   src="https://code.jquery.com/jquery-3.1.0.min.js"   integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s="   crossorigin="anonymous"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.6/cerulean/bootstrap.min.css" rel="stylesheet" integrity="sha384-fUMURLTdEcpeYHly3PAwggI3l2UvdHNg/I+8LRph7hLDcAZm77YfDx3Tjum9d3vK" crossorigin="anonymous">    <script type="text/javascript">	$(function() {		$("#table-indice-report")			.tablesorter({widthFixed: true, widgets: ["zebra"]})			/* .tablesorterPager({container: $("#pager")}); */	});	</script>